{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to \u201cIntroduction to Git\u201d course \u00b6 This material Here you will find the content of the workshop \u201cIntroduction to Git\u201d. Git repository for the course: https://github.com/hpc2n/course-intro-git . Content This course aims to give a brief, but comprehensive introduction to using Git from the command line, as well as using GitHub. You will learn about Basic commands Basic concepts The commit tree Branches merges conflicts Remote repositories Git in teamwork We aim to give this course every fall. Warning Target group This NAISS course is a given as a cooperation between trainers from the NAISS branches HPC2N and UPPMAX. It is open for anyone in Swedish academia. You will be using your own computer or other existing computer access for the course. If you do not have access to a computer that can run Git (or which you can install Git on), then there will be an option to use NAISS resources for this (Tetralith). Pre-requirements \u00b6 Basic knowledge of using the command line. Some material for self-study here: UPPMAX Linux getting started Linux tutorial and \u201ccheat sheet\u201d HPC2N\u2019s Linux intro course material (including link to recordings) Basic knowledge of using a text editor of your choice on your system. Information about Linux editors here: https://docs.hpc2n.umu.se/tutorials/linuxguide/#editors A GitHub user account (free - can be created for the course). A reasonably recent version of Git installed on your system. See the Git homepage . Some practicals \u00b6 Zoom \u00b6 You should have gotten an email with the links Main room for lectures (recorded) Possibly breakout rooms exercises, including a silent room for those who just want to work on their own without interruptions. help The lectures and demos will be recorded , but NOT the exercises . If you ask questions during the lectures, you may thus be recorded. If you do not wish to be recorded, then please keep your microphone muted and your camera off during lectures and write your questions in the Q/A document (see more information below about the collaboration documents which are also listed above). Use your REAL NAME. Please MUTE your microphone when you are not speaking Use the \u201cRaise hand\u201d functionality under the \u201cParticipants\u201d window during the lecture. Please do not clutter the Zoom chat. Behave politely! Q/A collabration document \u00b6 Use the Q/A page for the workshop with your questions. https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/EdGtUQbzqvRDu1UFAj1vrEEBegJLNy3wzrUlu3-oQYyYkw Create a new line for new questions. Take care if others are editing at the same time. Important info document \u00b6 There is an \u201cimportant info\u201d document with information for the course. You have gotten an email with a link to this: https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/Eapzrh9uWHBCj__7L63KFXkBAvUfBfEJfgvTfBHc-S0BiA?e=2GWXsM Recordings \u00b6 The recordings of the course lectures will be uploaded to HPC2N\u2019s YouTube channel: https://www.youtube.com/@HPC2N . Preliminary schedule \u00b6 Monday, 2025-11-03 Time Topic Activity Teacher 08:30 Optional installation help (Git) All 09:00 Introduction and course info Lecture Birgitte 09:10 0. Setup Lecture+code along Birgitte 09:30 1. Why use version management? Lecture Birgitte 10:00 Break (15 min) 10:15 2. Basic commands, part 1 Lecture+code along+exercises Pedro 11:15 Break (15 min) 11:30 2. Basic commands, part 2 Lecture+code along+exercises Pedro 12:00 End of first day Tuesday, 2025-11-04 Time Topic Activity Teacher 09:00 3. Basic concepts, part 1 Lecture+code along Birgitte 10:15 Break (15 min) 10:30 3. Basic concepts, part 2 Lecture+code along+exercises Birgitte 11:20 Break (10 min) 11:30 4. Traversing the commit tree, part 1 Lecture+code along Diana 12:00 End of second day Wednesday, 2025-11-05 Time Topic Activity Teacher 09:00 4. Traversing the commit tree, part 2 Lecture+code along+exercises Diana 10:15 Break (15 min) 10:30 4. Traversing the commit tree, part 3 Lecture+code along+exercises Diana 11:00 Break (10 min) 11:10 5. Branches, merges, and conflicts, part 1 Lecture+code along Diana 12:00 End of third day Thursday, 2025-11-06 Time Topic Activity Teacher 09:00 5. Branches, merges, and conflicts, part 2 Lecture+code along+exercises Diana 09:55 Break (10 min) 10:05 Brief intro to SSH-keys and using GitHub Lecture+code along Birgitte 10:15 6. Working with remotes, part 1 Lecture+code along Pedro 10:55 Break (10 min) 11:05 6. Working with remotes, part 2 Lecture+code along+exercises Pedro 12:00 End of fourth day Friday, 2025-11-07 Time Topic Activity Teacher 09:00 7. Teamwork, part 1 Lecture+code along+exercises Birgitte 09:55 Break (10 min) 10:05 7. Teamwork, part 2 exercises All 10:50 Break (10 min) 11:00 7. Team work, part 3 exercises All 11:50 Summary+evaluation 12:00 End of the course","title":"Home"},{"location":"#welcome__to__introduction__to__git__course","text":"This material Here you will find the content of the workshop \u201cIntroduction to Git\u201d. Git repository for the course: https://github.com/hpc2n/course-intro-git . Content This course aims to give a brief, but comprehensive introduction to using Git from the command line, as well as using GitHub. You will learn about Basic commands Basic concepts The commit tree Branches merges conflicts Remote repositories Git in teamwork We aim to give this course every fall. Warning Target group This NAISS course is a given as a cooperation between trainers from the NAISS branches HPC2N and UPPMAX. It is open for anyone in Swedish academia. You will be using your own computer or other existing computer access for the course. If you do not have access to a computer that can run Git (or which you can install Git on), then there will be an option to use NAISS resources for this (Tetralith).","title":"Welcome to &ldquo;Introduction to Git&rdquo; course"},{"location":"#pre-requirements","text":"Basic knowledge of using the command line. Some material for self-study here: UPPMAX Linux getting started Linux tutorial and \u201ccheat sheet\u201d HPC2N\u2019s Linux intro course material (including link to recordings) Basic knowledge of using a text editor of your choice on your system. Information about Linux editors here: https://docs.hpc2n.umu.se/tutorials/linuxguide/#editors A GitHub user account (free - can be created for the course). A reasonably recent version of Git installed on your system. See the Git homepage .","title":"Pre-requirements"},{"location":"#some__practicals","text":"","title":"Some practicals"},{"location":"#zoom","text":"You should have gotten an email with the links Main room for lectures (recorded) Possibly breakout rooms exercises, including a silent room for those who just want to work on their own without interruptions. help The lectures and demos will be recorded , but NOT the exercises . If you ask questions during the lectures, you may thus be recorded. If you do not wish to be recorded, then please keep your microphone muted and your camera off during lectures and write your questions in the Q/A document (see more information below about the collaboration documents which are also listed above). Use your REAL NAME. Please MUTE your microphone when you are not speaking Use the \u201cRaise hand\u201d functionality under the \u201cParticipants\u201d window during the lecture. Please do not clutter the Zoom chat. Behave politely!","title":"Zoom"},{"location":"#qa__collabration__document","text":"Use the Q/A page for the workshop with your questions. https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/EdGtUQbzqvRDu1UFAj1vrEEBegJLNy3wzrUlu3-oQYyYkw Create a new line for new questions. Take care if others are editing at the same time.","title":"Q/A collabration document"},{"location":"#important__info__document","text":"There is an \u201cimportant info\u201d document with information for the course. You have gotten an email with a link to this: https://umeauniversity.sharepoint.com/:w:/s/HPC2N630/Eapzrh9uWHBCj__7L63KFXkBAvUfBfEJfgvTfBHc-S0BiA?e=2GWXsM","title":"Important info document"},{"location":"#recordings","text":"The recordings of the course lectures will be uploaded to HPC2N\u2019s YouTube channel: https://www.youtube.com/@HPC2N .","title":"Recordings"},{"location":"#preliminary__schedule","text":"Monday, 2025-11-03 Time Topic Activity Teacher 08:30 Optional installation help (Git) All 09:00 Introduction and course info Lecture Birgitte 09:10 0. Setup Lecture+code along Birgitte 09:30 1. Why use version management? Lecture Birgitte 10:00 Break (15 min) 10:15 2. Basic commands, part 1 Lecture+code along+exercises Pedro 11:15 Break (15 min) 11:30 2. Basic commands, part 2 Lecture+code along+exercises Pedro 12:00 End of first day Tuesday, 2025-11-04 Time Topic Activity Teacher 09:00 3. Basic concepts, part 1 Lecture+code along Birgitte 10:15 Break (15 min) 10:30 3. Basic concepts, part 2 Lecture+code along+exercises Birgitte 11:20 Break (10 min) 11:30 4. Traversing the commit tree, part 1 Lecture+code along Diana 12:00 End of second day Wednesday, 2025-11-05 Time Topic Activity Teacher 09:00 4. Traversing the commit tree, part 2 Lecture+code along+exercises Diana 10:15 Break (15 min) 10:30 4. Traversing the commit tree, part 3 Lecture+code along+exercises Diana 11:00 Break (10 min) 11:10 5. Branches, merges, and conflicts, part 1 Lecture+code along Diana 12:00 End of third day Thursday, 2025-11-06 Time Topic Activity Teacher 09:00 5. Branches, merges, and conflicts, part 2 Lecture+code along+exercises Diana 09:55 Break (10 min) 10:05 Brief intro to SSH-keys and using GitHub Lecture+code along Birgitte 10:15 6. Working with remotes, part 1 Lecture+code along Pedro 10:55 Break (10 min) 11:05 6. Working with remotes, part 2 Lecture+code along+exercises Pedro 12:00 End of fourth day Friday, 2025-11-07 Time Topic Activity Teacher 09:00 7. Teamwork, part 1 Lecture+code along+exercises Birgitte 09:55 Break (10 min) 10:05 7. Teamwork, part 2 exercises All 10:50 Break (10 min) 11:00 7. Team work, part 3 exercises All 11:50 Summary+evaluation 12:00 End of the course","title":"Preliminary schedule"},{"location":"basic-commands-exercises/","text":"Exercises - Basic Commands \u00b6 Try out the basic commands \u00b6 The purpose of this exercise is to learn about basic commands further. Create a folder called \u201cmysecondrepo\u201d which will contain your repository. Tasks: initialize the repository create a README.md file and add this text on the first line: \u201cFile created on Sep. 30, 2020\u201d stage the file commit the changes create a second file \u201cPoem.md\u201d without any text (hint: use touch command), stage and commit it Copy and paste the two paragraphs below of the poem la lluvia by Jorge Luis Borges into the Poem.md file: Tasks: stage the first paragraph only confirm that the file has been partially staged by checking the status. check if the staged changes correspond to just the first paragraph by looking at the differences between: \u2013 the working directory vs. the staging area \u2013 the staging area vs. the committed changes region (Repo) commit the staged changes and check the status stage the second paragraph and commit the changes Bruscamente la tarde se ha aclarado Porque ya cae la lluvia minuciosa. Cae o cay\u00f3. La lluvia es una cosa Que sin duda sucede en el pasado. Quien la oye caer ha recobrado El tiempo en que la suerte venturosa Le revel\u00f3 una flor llamada rosa Y el curioso color del colorado. 3. Create a folder called \u201cFirstPoem\u201d and move the Poem.md file to this new folder (use git mv). Check the status to confirm that the file was moved. Commit the changes. 4. (Challenge task) Add the next paragraph of the poem: Esta lluvia que ciega los cristales Alegrar\u00e1 en perdidos arrabales Las negras uvas de una parra en cierto Patio que ya no existe. La mojada Tarde me trae la voz, la voz deseada, De mi padre que vuelve y que no ha muerto. stage the changes and commit them. Now, we have the last four commits refering to the same topic (same poem). The goal of this part of the exercise is to summarize those four commits into a single one. hint: git rebase -i HEAD~4 5. End of exercise git diff usage \u00b6 The purpose of this exercise is to show you the usage of the git diff command. Create a folder called \u201cmyfirstrepo\u201d which will contain your repository. Tasks: initialize the repository create a README.md file and add this text on the first line: \u201cFile created on Sep. 30, 2020\u201d stage the file commit the changes At this point, your working directory, the staging area, and the local repository (committed changes) are all synchronized. Make a change to the README.md file by adding a line with the string \u201cTODO list\u201d. Now, the staging area and the local repository are synchronized with each other but the working directory is not synchronized with them. check the differences between the working directory and the staging area (hint: git diff) check the differences between the working directory and the local repository (hint: git diff HEAD) confirm that the changes correspond to what you expected by looking at the diff outputs. Add the file README.md to the staging area. Now, the working directory and the staging area are synchronized with each other but they are not synchronized with the local repository. check the differences between the staging area and the local repository (hint: git diff \u2013staged) check the differences between the working directory and the local repository (hint: git diff HEAD) confirm that the changes correspond to what you expected by looking at the diff outputs. Make an additional modification to the README.md file by adding a line with the string \u201cAdd the support email\u201d. Now, all the three areas working directory, the staging area and the local repository are not synchronized with each other. check the differences between the working directory and the staging area (hint: git diff) check the differences between the staging area and the local repository (hint: git diff \u2013staged) check the differences between the working directory and the local repository (hint: git diff HEAD) confirm that the changes correspond to what you expected by looking at the diff outputs. End of exercise","title":"Basic commands"},{"location":"basic-commands-exercises/#exercises__-__basic__commands","text":"","title":"Exercises - Basic Commands"},{"location":"basic-commands-exercises/#try__out__the__basic__commands","text":"The purpose of this exercise is to learn about basic commands further. Create a folder called \u201cmysecondrepo\u201d which will contain your repository. Tasks: initialize the repository create a README.md file and add this text on the first line: \u201cFile created on Sep. 30, 2020\u201d stage the file commit the changes create a second file \u201cPoem.md\u201d without any text (hint: use touch command), stage and commit it Copy and paste the two paragraphs below of the poem la lluvia by Jorge Luis Borges into the Poem.md file: Tasks: stage the first paragraph only confirm that the file has been partially staged by checking the status. check if the staged changes correspond to just the first paragraph by looking at the differences between: \u2013 the working directory vs. the staging area \u2013 the staging area vs. the committed changes region (Repo) commit the staged changes and check the status stage the second paragraph and commit the changes Bruscamente la tarde se ha aclarado Porque ya cae la lluvia minuciosa. Cae o cay\u00f3. La lluvia es una cosa Que sin duda sucede en el pasado. Quien la oye caer ha recobrado El tiempo en que la suerte venturosa Le revel\u00f3 una flor llamada rosa Y el curioso color del colorado. 3. Create a folder called \u201cFirstPoem\u201d and move the Poem.md file to this new folder (use git mv). Check the status to confirm that the file was moved. Commit the changes. 4. (Challenge task) Add the next paragraph of the poem: Esta lluvia que ciega los cristales Alegrar\u00e1 en perdidos arrabales Las negras uvas de una parra en cierto Patio que ya no existe. La mojada Tarde me trae la voz, la voz deseada, De mi padre que vuelve y que no ha muerto. stage the changes and commit them. Now, we have the last four commits refering to the same topic (same poem). The goal of this part of the exercise is to summarize those four commits into a single one. hint: git rebase -i HEAD~4 5. End of exercise","title":"Try out the basic commands"},{"location":"basic-commands-exercises/#git__diff__usage","text":"The purpose of this exercise is to show you the usage of the git diff command. Create a folder called \u201cmyfirstrepo\u201d which will contain your repository. Tasks: initialize the repository create a README.md file and add this text on the first line: \u201cFile created on Sep. 30, 2020\u201d stage the file commit the changes At this point, your working directory, the staging area, and the local repository (committed changes) are all synchronized. Make a change to the README.md file by adding a line with the string \u201cTODO list\u201d. Now, the staging area and the local repository are synchronized with each other but the working directory is not synchronized with them. check the differences between the working directory and the staging area (hint: git diff) check the differences between the working directory and the local repository (hint: git diff HEAD) confirm that the changes correspond to what you expected by looking at the diff outputs. Add the file README.md to the staging area. Now, the working directory and the staging area are synchronized with each other but they are not synchronized with the local repository. check the differences between the staging area and the local repository (hint: git diff \u2013staged) check the differences between the working directory and the local repository (hint: git diff HEAD) confirm that the changes correspond to what you expected by looking at the diff outputs. Make an additional modification to the README.md file by adding a line with the string \u201cAdd the support email\u201d. Now, all the three areas working directory, the staging area and the local repository are not synchronized with each other. check the differences between the working directory and the staging area (hint: git diff) check the differences between the staging area and the local repository (hint: git diff \u2013staged) check the differences between the working directory and the local repository (hint: git diff HEAD) confirm that the changes correspond to what you expected by looking at the diff outputs. End of exercise","title":"git diff usage"},{"location":"basic-commands/","text":"Lecture 2: Basic commands \u00b6 Getting help \u00b6 $ git help <command> $ man git-<command> $ git help commit GIT-COMMIT(1) Git Manual GIT-COMMIT(1) NAME git-commit - Record changes to the repository SYNOPSIS git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend] [--dry-run] [(-c | -C | --fixup | --squash) <commit>] [-F <file> | -m <msg>] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author=<author>] [--date=<date>] [--cleanup=<mode>] [--[no-]status] [-i | -o] [-S[<keyid>]] [--] [<file>...] DESCRIPTION Creating a repository from scratch \u00b6 In case you want to start a project from scratch called myproject : $ mkdir myproject $ cd myproject $ git init Initialized empty Git repository in .../myproject/.git/ this will create a folder called .git in the current folder which contains the Git-related files. We can now ask about the status of the repository: $ git status On branch master No commits yet nothing to commit ( create/copy files and use \"git add\" to track ) Creating a repository by cloning an existing repository \u00b6 Use the command: $ git clone repository_location path_where_it_will_be repository_location is the path of the Git repository (if it is in your local machine) or a URL if it is on the internet. path_where_it_will_be is the path for the cloned repository. $ git clone https://github.com/aliceuser2020/my-first-project.git ./my-project Cloning into 'GitCourse/Alice/my-project'... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. Checking connectivity... done. $ cd ./my-project $ git status On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working directory clean Stages of files \u00b6 Monitoring the differences in files \u00b6 Differences or changes in files can be seen with the command $ git diff This command supports different options. Adding files\u2019 modifications \u00b6 After initializing the repository, we decide to create a file called first.txt $ echo \"This is my first file\" > first.txt If we ask about the status of the repository we will see the following message, $ git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) first.txt nothing added to commit but untracked files present (use \"git add\" to track) We can now add the first.txt file to the staging area: $ git add first.txt and then check the status of the repository: $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached <file>...\" to unstage) new file: first.txt Unstaging files\u2019 modifications part I \u00b6 If you want to unstage the changes (maybe you are not convinced of them) type the line suggested by Git: $ git rm --cached first.txt Notice that Git suggests this command because the repository is brand-new and nothing has been committed yet. Committing changes \u00b6 Once the changes are staged, they can be commited with the command $ git commit this will open a window of the default text editor in your system (in this case Vim ) First commit in myproject # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # # Initial commit # # Changes to be committed: # new file: first.txt # write a commit message and upon saving the file the changes will be committed. $ git commit [master (root-commit) 3a7625b] First commit in myproject 1 file changed, 1 insertion(+) create mode 100644 first.txt the status after committing is $ git status On branch master nothing to commit, working tree clean Fast (lazy?) commit option: $ git commit -a -m \"Commit message\" this command will add all files that were modified (and tracked) and commit them with the quoted message. Unstaging files\u2019 modifications part II \u00b6 Imagine that after doing the first commit for first.txt file, you modify this file and stage it ( git add first.txt ). If you check the status the output will be (version 2.25.1): On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) modified: first.txt For versions before 2.23 the status would look like: On branch master Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: first.txt Git suggests a different way to unstage the file as we saw before, because now there is a HEAD pointer. $ git restore --staged filename unstages the changes made to filename . From the website https://git-scm.com/docs/git-restore: THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE. $ git reset HEAD filename is an old command for unstaging, $ git rm --cached filename with this command Git will untrack filename (staging for removal) leaving the file in the working directory Content of a commit message \u00b6 why is this change needed? how is the problem approached? are there side effects? write structured text (~70 characters) one can include the ticket numbers for related issues for instance (#1112) Important: check that the code works before commiting. Here, test cases are very handy. Git kurz & gut, O\u2019Reillys, Nina Siessegger. Reverting to the previous commit \u00b6 If you made a commit and you regret it later, you can revert the changes to the previous commit with the command: $ git revert HEAD Adding multiple files \u00b6 In case you want to add multiple files, that follow a pattern, at the same time you can use Linux-type wild cards. As an example, we can add the files file1.txt, file2.txt, file3.txt at once with the commands (equivalent for this test case): $ git add file?.txt $ git add file [ 1 -3 ] .txt $ git add *.txt If we want to add all the files for staging we can do: $ git add -A ( all files including those in the parent folder ) $ git add . ( all files in the sub-folders ) Renaming files/folders \u00b6 Imagine that you want to change the name of the file first.txt to Readme.txt , in this case you can use the command: $ git mv oldfilename newfilename $ git mv first.txt Readme.txt Although there is not feedback from the command the status of the file has now changed $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) renamed: first.txt -> Readme.txt you can now commit the changes. Renaming files, instead of creating new ones, can help you to keep a consistent history of the files. Moving files \u00b6 Similar to the mv Linux command, the git mv command can be also used to move a file to a different location: $ git mv filename newlocation $ git mv first.txt src/ $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) renamed: first.txt -> src/first.txt Removing files \u00b6 If some file is not useful any longer and we want to delete it from our repository, we can issue the command, $ git rm location/filename $ git rm src/first.txt $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) deleted: src/first.txt Sometimes it is more convenient to rename files instead of deleting them to keep the history more consistent. Ignoring files \u00b6 If you want to ignore some files in your repository, for instance, temporary (.tmp) or binary (.bin) files. One way to accomplish this is by creating a file called .gitignore in the repository with some rules with a Linux-type wild cards syntax $ cat .gitignore *.tmp *.bin then, you will have to commit the .gitignore file as usual. One caveat of using a .gitignore file is that it will be shared with all the collaborators. One can instead use the local exclude file in .git/info/exclude to define the rules. This file won\u2019t be shared. # $ git ls-files --others --exclude-from = .git/info/exclude # Lines that start with '#' are comments. # For a project mostly in C, the following would be a good set of # exclude patterns ( uncomment them if you want to use them ) : # *. [ oa ] # *~ *.tmp *.bin ~ Generating aliases \u00b6 The following command shows a graph of the commits\u2019 tree in an organized way: $ git log -- all -- decorate -- oneline -- graph This command is too long to type/remember. Git allows you to create shortcuts/aliases for commands: $ git config -- global alias . shortcut < git command > $ git config -- global alias . graph \"log --all --graph --decorate --oneline\" In this way, you can use a customized git graph command: $ git graph * 39 ecba2 ( HEAD -> master ) Fourth commit * 3 cd651b Third commit * 7d ce2ff Second commit * 1f 2 cdcc First commit A second way to generate an alias is by adding it to your .bashrc file: alias graph = \"git log --all --decorate --oneline --graph\" which will make the command graph available on the command line. Intermediate/ Advanced commands \u00b6 Adding files\u2019 modifications interactively \u00b6 Suppose we create an empty file, stage it, and commit the changes as follows: touch first.txt git add first.txt git commit -m \"first file\" Now, we add a couple of lines to our file first.txt and now it looks like This is my first file * TODO list * Summary The status command tells us that we did some modifications to the file: On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: first.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Let\u2019s suppose that the new text (5 lines) refer to different topics: TODO list and Summary . Then, it would be better to have them in different commits. We can add the modifications interactively: $ git add -p first.txt diff --git a/first.txt b/first.txt index e69de29..96dd9a2 100644 --- a/first.txt +++ b/first.txt @@ -0,0 +1,5 @@ +This is my first file + +* TODO list + +* Summary (1/1) Stage this hunk [y,n,q,a,d,e,?]? choose the e edit option to enter the editing mode. # Manual hunk edit mode -- see bottom for a quick guide. @@ -0,0 +1,5 @@ +This is my first file + +* TODO list + +* Summary # --- # To remove '-' lines, make them ' ' lines ( context ) . # To remove '+' lines, delete them. # Lines starting with # will be removed. Because we don\u2019t want Summary in the first commit, we delete that line and save the file. You can now take a look at the status of the file $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) modified: first.txt Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: first.txt Notice that the file first.txt has been partially staged. The difference between staged changes and the unstaged ones can be seen with: $ git diff the difference between staged changes and the previous commit with: $ git diff --staged $ git diff --cached and the difference between the unstaged changes and the previous commit with: $ git diff HEAD At this point, you can commit the staged changes and later on stage and commit the remaining changes. Amending commits \u00b6 The following command will modify your last commit by adding more content to it: $ git commit --amend the flag -m will allow you to write a short message and - -no-edit will keep the message from the previous commit. Note: use this command in commits that haven\u2019t been pushed on public branches. This command modifies the history. Simplifying commits \u00b6 Suppose that you have a series of commits which are close-related in your local repo : $ git log -- all -- decorate -- oneline -- graph $ git graph * 39 ecba2 ( HEAD -> master ) Fourth commit * 3 cd651b Third commit * 7d ce2ff Second commit * 1f 2 cdcc First commit in this case, the three last commits are related and can be squashed into a single commit. $ git rebase - i HEAD ~ 3 pick 7d ce2ff Second commit pick 3 cd651b Third commit pick 39 ecba2 Fourth commit # Rebase 1f 2 cdcc . .39 ecba2 onto 1f 2 cdcc ( 3 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit ' s log message # x , exec < command > = run command ( the rest of the line ) using shell # b , break = stop here ( continue rebase later with ' git rebase -- continue ' ) # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [- C < commit > | - c < commit >] < label > [ # < oneline >] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out choose the option s (squash) pick 7d ce2ff Second commit s 3 cd651b Third commit s 39 ecba2 Fourth commit # Rebase 1f 2 cdcc . .39 ecba2 onto 1f 2 cdcc ( 3 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit ' s log message # x , exec < command > = run command ( the rest of the line ) using shell # b , break = stop here ( continue rebase later with ' git rebase -- continue ' ) # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [- C < commit > | - c < commit >] < label > [ # < oneline >] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out a text editor message will appear where you can type the message for the squashed commit: # This is a combination of 3 commits . # This is the 1 st commit message : Summary of three commits # Second commit # This is the commit message # 2 : # Third commit # This is the commit message # 3 : # Fourth commit # Please enter the commit message for your changes . Lines starting # with '#' will be ignored , and an empty message aborts the commit . # # Date : Mon Sep 21 16 : 48 : 36 2020 + 0200 # # interactive rebase in progress ; onto 1f 2 cdcc # Last commands done ( 3 commands done ): # s 3 cd651b Third commit # s 39 ecba2 Fourth commit # No commands remaining . # You are currently rebasing branch ' master ' on ' 1f 2 cdcc ' . # # Changes to be committed : # modified : Commits . txt # Finally, we check the log file and see that we have now only two commits with the new commit message: $ git log --all --decorate --oneline --graph $ git graph * 62f921f (HEAD -> master) Summary of three commits * 1f2cdcc First commit Note: use this command in commits that haven\u2019t been pushed on public branches. This command modifies the history. Advanced \u00b6 Git blame (Advanced) \u00b6 it displays information about the last modifications of authors line by line git blame filename $git blame 1. basic - commands / README . md ^ a18abd1 ( Birgitte Bryds\u00f6 2021 - 09 - 28 12 : 21 : 06 + 0200 9 ) - stage the file ^ a18abd1 ( Birgitte Bryds\u00f6 2021 - 09 - 28 12 : 21 : 06 + 0200 10 ) - commit the changes dd5db248 ( Pedro Ojeda - May 2021 - 11 - 02 10 : 53 : 01 + 0100 11 ) - create a second file \"Poem.md\" without any text ( hint : use touch command ), stage and commit it here we can see the commit, author, timestamp, line number and line content.","title":"Basic Commands"},{"location":"basic-commands/#lecture__2__basic__commands","text":"","title":"Lecture 2: Basic commands"},{"location":"basic-commands/#getting__help","text":"$ git help <command> $ man git-<command> $ git help commit GIT-COMMIT(1) Git Manual GIT-COMMIT(1) NAME git-commit - Record changes to the repository SYNOPSIS git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend] [--dry-run] [(-c | -C | --fixup | --squash) <commit>] [-F <file> | -m <msg>] [--reset-author] [--allow-empty] [--allow-empty-message] [--no-verify] [-e] [--author=<author>] [--date=<date>] [--cleanup=<mode>] [--[no-]status] [-i | -o] [-S[<keyid>]] [--] [<file>...] DESCRIPTION","title":"Getting help"},{"location":"basic-commands/#creating__a__repository__from__scratch","text":"In case you want to start a project from scratch called myproject : $ mkdir myproject $ cd myproject $ git init Initialized empty Git repository in .../myproject/.git/ this will create a folder called .git in the current folder which contains the Git-related files. We can now ask about the status of the repository: $ git status On branch master No commits yet nothing to commit ( create/copy files and use \"git add\" to track )","title":"Creating a repository from scratch"},{"location":"basic-commands/#creating__a__repository__by__cloning__an__existing__repository","text":"Use the command: $ git clone repository_location path_where_it_will_be repository_location is the path of the Git repository (if it is in your local machine) or a URL if it is on the internet. path_where_it_will_be is the path for the cloned repository. $ git clone https://github.com/aliceuser2020/my-first-project.git ./my-project Cloning into 'GitCourse/Alice/my-project'... remote: Enumerating objects: 3, done. remote: Counting objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. Checking connectivity... done. $ cd ./my-project $ git status On branch master Your branch is up-to-date with 'origin/master'. nothing to commit, working directory clean","title":"Creating a repository by cloning an existing repository"},{"location":"basic-commands/#stages__of__files","text":"","title":"Stages of files"},{"location":"basic-commands/#monitoring__the__differences__in__files","text":"Differences or changes in files can be seen with the command $ git diff This command supports different options.","title":"Monitoring the differences in files"},{"location":"basic-commands/#adding__files__modifications","text":"After initializing the repository, we decide to create a file called first.txt $ echo \"This is my first file\" > first.txt If we ask about the status of the repository we will see the following message, $ git status On branch master No commits yet Untracked files: (use \"git add <file>...\" to include in what will be committed) first.txt nothing added to commit but untracked files present (use \"git add\" to track) We can now add the first.txt file to the staging area: $ git add first.txt and then check the status of the repository: $ git status On branch master No commits yet Changes to be committed: (use \"git rm --cached <file>...\" to unstage) new file: first.txt","title":"Adding files&rsquo; modifications"},{"location":"basic-commands/#unstaging__files__modifications__part__i","text":"If you want to unstage the changes (maybe you are not convinced of them) type the line suggested by Git: $ git rm --cached first.txt Notice that Git suggests this command because the repository is brand-new and nothing has been committed yet.","title":"Unstaging files&rsquo; modifications part I"},{"location":"basic-commands/#committing__changes","text":"Once the changes are staged, they can be commited with the command $ git commit this will open a window of the default text editor in your system (in this case Vim ) First commit in myproject # Please enter the commit message for your changes. Lines starting # with '#' will be ignored, and an empty message aborts the commit. # # On branch master # # Initial commit # # Changes to be committed: # new file: first.txt # write a commit message and upon saving the file the changes will be committed. $ git commit [master (root-commit) 3a7625b] First commit in myproject 1 file changed, 1 insertion(+) create mode 100644 first.txt the status after committing is $ git status On branch master nothing to commit, working tree clean Fast (lazy?) commit option: $ git commit -a -m \"Commit message\" this command will add all files that were modified (and tracked) and commit them with the quoted message.","title":"Committing changes"},{"location":"basic-commands/#unstaging__files__modifications__part__ii","text":"Imagine that after doing the first commit for first.txt file, you modify this file and stage it ( git add first.txt ). If you check the status the output will be (version 2.25.1): On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) modified: first.txt For versions before 2.23 the status would look like: On branch master Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: first.txt Git suggests a different way to unstage the file as we saw before, because now there is a HEAD pointer. $ git restore --staged filename unstages the changes made to filename . From the website https://git-scm.com/docs/git-restore: THIS COMMAND IS EXPERIMENTAL. THE BEHAVIOR MAY CHANGE. $ git reset HEAD filename is an old command for unstaging, $ git rm --cached filename with this command Git will untrack filename (staging for removal) leaving the file in the working directory","title":"Unstaging files&rsquo; modifications part II"},{"location":"basic-commands/#content__of__a__commit__message","text":"why is this change needed? how is the problem approached? are there side effects? write structured text (~70 characters) one can include the ticket numbers for related issues for instance (#1112) Important: check that the code works before commiting. Here, test cases are very handy. Git kurz & gut, O\u2019Reillys, Nina Siessegger.","title":"Content of a commit message"},{"location":"basic-commands/#reverting__to__the__previous__commit","text":"If you made a commit and you regret it later, you can revert the changes to the previous commit with the command: $ git revert HEAD","title":"Reverting to the previous commit"},{"location":"basic-commands/#adding__multiple__files","text":"In case you want to add multiple files, that follow a pattern, at the same time you can use Linux-type wild cards. As an example, we can add the files file1.txt, file2.txt, file3.txt at once with the commands (equivalent for this test case): $ git add file?.txt $ git add file [ 1 -3 ] .txt $ git add *.txt If we want to add all the files for staging we can do: $ git add -A ( all files including those in the parent folder ) $ git add . ( all files in the sub-folders )","title":"Adding multiple files"},{"location":"basic-commands/#renaming__filesfolders","text":"Imagine that you want to change the name of the file first.txt to Readme.txt , in this case you can use the command: $ git mv oldfilename newfilename $ git mv first.txt Readme.txt Although there is not feedback from the command the status of the file has now changed $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) renamed: first.txt -> Readme.txt you can now commit the changes. Renaming files, instead of creating new ones, can help you to keep a consistent history of the files.","title":"Renaming files/folders"},{"location":"basic-commands/#moving__files","text":"Similar to the mv Linux command, the git mv command can be also used to move a file to a different location: $ git mv filename newlocation $ git mv first.txt src/ $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) renamed: first.txt -> src/first.txt","title":"Moving files"},{"location":"basic-commands/#removing__files","text":"If some file is not useful any longer and we want to delete it from our repository, we can issue the command, $ git rm location/filename $ git rm src/first.txt $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) deleted: src/first.txt Sometimes it is more convenient to rename files instead of deleting them to keep the history more consistent.","title":"Removing files"},{"location":"basic-commands/#ignoring__files","text":"If you want to ignore some files in your repository, for instance, temporary (.tmp) or binary (.bin) files. One way to accomplish this is by creating a file called .gitignore in the repository with some rules with a Linux-type wild cards syntax $ cat .gitignore *.tmp *.bin then, you will have to commit the .gitignore file as usual. One caveat of using a .gitignore file is that it will be shared with all the collaborators. One can instead use the local exclude file in .git/info/exclude to define the rules. This file won\u2019t be shared. # $ git ls-files --others --exclude-from = .git/info/exclude # Lines that start with '#' are comments. # For a project mostly in C, the following would be a good set of # exclude patterns ( uncomment them if you want to use them ) : # *. [ oa ] # *~ *.tmp *.bin ~","title":"Ignoring files"},{"location":"basic-commands/#generating__aliases","text":"The following command shows a graph of the commits\u2019 tree in an organized way: $ git log -- all -- decorate -- oneline -- graph This command is too long to type/remember. Git allows you to create shortcuts/aliases for commands: $ git config -- global alias . shortcut < git command > $ git config -- global alias . graph \"log --all --graph --decorate --oneline\" In this way, you can use a customized git graph command: $ git graph * 39 ecba2 ( HEAD -> master ) Fourth commit * 3 cd651b Third commit * 7d ce2ff Second commit * 1f 2 cdcc First commit A second way to generate an alias is by adding it to your .bashrc file: alias graph = \"git log --all --decorate --oneline --graph\" which will make the command graph available on the command line.","title":"Generating aliases"},{"location":"basic-commands/#intermediate__advanced__commands","text":"","title":"Intermediate/ Advanced commands"},{"location":"basic-commands/#adding__files__modifications__interactively","text":"Suppose we create an empty file, stage it, and commit the changes as follows: touch first.txt git add first.txt git commit -m \"first file\" Now, we add a couple of lines to our file first.txt and now it looks like This is my first file * TODO list * Summary The status command tells us that we did some modifications to the file: On branch master Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: first.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") Let\u2019s suppose that the new text (5 lines) refer to different topics: TODO list and Summary . Then, it would be better to have them in different commits. We can add the modifications interactively: $ git add -p first.txt diff --git a/first.txt b/first.txt index e69de29..96dd9a2 100644 --- a/first.txt +++ b/first.txt @@ -0,0 +1,5 @@ +This is my first file + +* TODO list + +* Summary (1/1) Stage this hunk [y,n,q,a,d,e,?]? choose the e edit option to enter the editing mode. # Manual hunk edit mode -- see bottom for a quick guide. @@ -0,0 +1,5 @@ +This is my first file + +* TODO list + +* Summary # --- # To remove '-' lines, make them ' ' lines ( context ) . # To remove '+' lines, delete them. # Lines starting with # will be removed. Because we don\u2019t want Summary in the first commit, we delete that line and save the file. You can now take a look at the status of the file $ git status On branch master Changes to be committed: (use \"git restore --staged <file>...\" to unstage) modified: first.txt Changes not staged for commit: (use \"git add <file>...\" to update what will be committed) (use \"git restore <file>...\" to discard changes in working directory) modified: first.txt Notice that the file first.txt has been partially staged. The difference between staged changes and the unstaged ones can be seen with: $ git diff the difference between staged changes and the previous commit with: $ git diff --staged $ git diff --cached and the difference between the unstaged changes and the previous commit with: $ git diff HEAD At this point, you can commit the staged changes and later on stage and commit the remaining changes.","title":"Adding files&rsquo; modifications interactively"},{"location":"basic-commands/#amending__commits","text":"The following command will modify your last commit by adding more content to it: $ git commit --amend the flag -m will allow you to write a short message and - -no-edit will keep the message from the previous commit. Note: use this command in commits that haven\u2019t been pushed on public branches. This command modifies the history.","title":"Amending commits"},{"location":"basic-commands/#simplifying__commits","text":"Suppose that you have a series of commits which are close-related in your local repo : $ git log -- all -- decorate -- oneline -- graph $ git graph * 39 ecba2 ( HEAD -> master ) Fourth commit * 3 cd651b Third commit * 7d ce2ff Second commit * 1f 2 cdcc First commit in this case, the three last commits are related and can be squashed into a single commit. $ git rebase - i HEAD ~ 3 pick 7d ce2ff Second commit pick 3 cd651b Third commit pick 39 ecba2 Fourth commit # Rebase 1f 2 cdcc . .39 ecba2 onto 1f 2 cdcc ( 3 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit ' s log message # x , exec < command > = run command ( the rest of the line ) using shell # b , break = stop here ( continue rebase later with ' git rebase -- continue ' ) # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [- C < commit > | - c < commit >] < label > [ # < oneline >] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out choose the option s (squash) pick 7d ce2ff Second commit s 3 cd651b Third commit s 39 ecba2 Fourth commit # Rebase 1f 2 cdcc . .39 ecba2 onto 1f 2 cdcc ( 3 commands ) # # Commands : # p , pick < commit > = use commit # r , reword < commit > = use commit , but edit the commit message # e , edit < commit > = use commit , but stop for amending # s , squash < commit > = use commit , but meld into previous commit # f , fixup < commit > = like \"squash\" , but discard this commit ' s log message # x , exec < command > = run command ( the rest of the line ) using shell # b , break = stop here ( continue rebase later with ' git rebase -- continue ' ) # d , drop < commit > = remove commit # l , label < label > = label current HEAD with a name # t , reset < label > = reset HEAD to a label # m , merge [- C < commit > | - c < commit >] < label > [ # < oneline >] # . create a merge commit using the original merge commit ' s # . message ( or the oneline , if no original merge commit was # . specified ). Use - c < commit > to reword the commit message . # # These lines can be re - ordered ; they are executed from top to bottom . # # If you remove a line here THAT COMMIT WILL BE LOST . # # However , if you remove everything , the rebase will be aborted . # # Note that empty commits are commented out a text editor message will appear where you can type the message for the squashed commit: # This is a combination of 3 commits . # This is the 1 st commit message : Summary of three commits # Second commit # This is the commit message # 2 : # Third commit # This is the commit message # 3 : # Fourth commit # Please enter the commit message for your changes . Lines starting # with '#' will be ignored , and an empty message aborts the commit . # # Date : Mon Sep 21 16 : 48 : 36 2020 + 0200 # # interactive rebase in progress ; onto 1f 2 cdcc # Last commands done ( 3 commands done ): # s 3 cd651b Third commit # s 39 ecba2 Fourth commit # No commands remaining . # You are currently rebasing branch ' master ' on ' 1f 2 cdcc ' . # # Changes to be committed : # modified : Commits . txt # Finally, we check the log file and see that we have now only two commits with the new commit message: $ git log --all --decorate --oneline --graph $ git graph * 62f921f (HEAD -> master) Summary of three commits * 1f2cdcc First commit Note: use this command in commits that haven\u2019t been pushed on public branches. This command modifies the history.","title":"Simplifying commits"},{"location":"basic-commands/#advanced","text":"","title":"Advanced"},{"location":"basic-commands/#git__blame__advanced","text":"it displays information about the last modifications of authors line by line git blame filename $git blame 1. basic - commands / README . md ^ a18abd1 ( Birgitte Bryds\u00f6 2021 - 09 - 28 12 : 21 : 06 + 0200 9 ) - stage the file ^ a18abd1 ( Birgitte Bryds\u00f6 2021 - 09 - 28 12 : 21 : 06 + 0200 10 ) - commit the changes dd5db248 ( Pedro Ojeda - May 2021 - 11 - 02 10 : 53 : 01 + 0100 11 ) - create a second file \"Poem.md\" without any text ( hint : use touch command ), stage and commit it here we can see the commit, author, timestamp, line number and line content.","title":"Git blame (Advanced)"},{"location":"basic-concepts-exercises/","text":"Exercises - Basic Concepts \u00b6 Create a repository, add (stage) and commit a file mkdir repository cd repository git init nano file.txt git add file.txt git commit -m \"This is quite interesting\" 2. Take a look at the stuff under the .git directory cd repository tree .git git cat-file -p <hash> where is the various hash\u2019es you can see with tree .git Remember that the two-letter name of the subdirectory under objects-dir is included in the hash 3. Make some changes. Change one or more files. Add and commit. Make some changes. Add and commit. Look at what happens in the .git tree 4. Go to earlier commits and make a new branch Try go back to an earlier commit with \u201cgit checkout \u201d Make come changes to a file there, or try adding a new file (and add+commit) Create a new branch from that commit: \u201cgit checkout -b second_branch\u201d Find the hash of the commit the HEAD points to now cat .git/HEAD cat <path you got above> git cat-file -p < hash you just got from above command> 5. Go back on primary branch and merge the branches Go back to the primary branch (main or master) with \u201cgit checkout main\u201d or \u201cgit checkout master\u201d Merge the new branch you created to master with \u201cgit merge \u2013no-ff second_branch\u201d (or whatever you called the new branch) Fix any conflict by going into the conflicting file(s) and removing the stuff you don\u2019t want and also the git markers set there Add the fixed file and do \u201cgit merge \u2013continue\u201d Now look at what the HEAD is pointing to 6. Check out the commit tree You can also just try jump around in the commit tree with \u201cgit checkout \u201d and see how your working tree looks in various places (see that files are there or not, and with different content). You get the list of hash\u2019s and commit messages with \u201cgit log\u201d","title":"Basic concepts"},{"location":"basic-concepts-exercises/#exercises__-__basic__concepts","text":"Create a repository, add (stage) and commit a file mkdir repository cd repository git init nano file.txt git add file.txt git commit -m \"This is quite interesting\" 2. Take a look at the stuff under the .git directory cd repository tree .git git cat-file -p <hash> where is the various hash\u2019es you can see with tree .git Remember that the two-letter name of the subdirectory under objects-dir is included in the hash 3. Make some changes. Change one or more files. Add and commit. Make some changes. Add and commit. Look at what happens in the .git tree 4. Go to earlier commits and make a new branch Try go back to an earlier commit with \u201cgit checkout \u201d Make come changes to a file there, or try adding a new file (and add+commit) Create a new branch from that commit: \u201cgit checkout -b second_branch\u201d Find the hash of the commit the HEAD points to now cat .git/HEAD cat <path you got above> git cat-file -p < hash you just got from above command> 5. Go back on primary branch and merge the branches Go back to the primary branch (main or master) with \u201cgit checkout main\u201d or \u201cgit checkout master\u201d Merge the new branch you created to master with \u201cgit merge \u2013no-ff second_branch\u201d (or whatever you called the new branch) Fix any conflict by going into the conflicting file(s) and removing the stuff you don\u2019t want and also the git markers set there Add the fixed file and do \u201cgit merge \u2013continue\u201d Now look at what the HEAD is pointing to 6. Check out the commit tree You can also just try jump around in the commit tree with \u201cgit checkout \u201d and see how your working tree looks in various places (see that files are there or not, and with different content). You get the list of hash\u2019s and commit messages with \u201cgit log\u201d","title":"Exercises - Basic Concepts"},{"location":"basic-concepts/","text":"Lecture 3: Basic concepts \u00b6 Remark \u00b6 You are not intended to memorize any commands or low-level details. The goal is to learn the basic concepts : hash sums, blobs, trees, commits, references, branches, \u2026 Understanding these concepts helps to understand what the commands actually do! What is Git? \u00b6 Git is a distributed VCS: Does not rely on a server-client model. Instead, everyone has a full copy of the entire project (repository). Complete history, metadata, etc. People can work completely independently. An (optional) server is used only to distribute changes. Why use Git? \u00b6 It is popular. Many project already use it, people know how to use it, people can tell you how to use it, \u2026 Relies on hash sums: Built-in data corruption detection. Built-in security. Distributed. Fast, simple and flexible. Free and open-source. How does Git store the history? \u00b6 What is inside a repository? \u00b6 $ mkdir repository && cd repository $ git init Initialized empty Git repository in .../repository/.git/ $ find graph TD A([\"repository/\"]) B([\".git/\"]) A --> B B --> C([\"branches/\"]) B --> D([\"hooks/\"]) B --> E([\"info/ \"]) B --> F([\"objects/\"]) B --> G([\"refs/\"]) B --> H([\"config\"]) B --> I([\"description\"]) B --> J([\"HEAD\"]) F --> K([\"info/\"]) F --> L([\"pack/\"]) G --> M([\"heads/\"]) G --> N([\"tags/\"]) Most directories are empty and the files are not that interesting: $ cat .git/config [ core ] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true $ cat .git/HEAD ref: refs/heads/master $ cat .git/description Unnamed repository ; edit this file 'description' to name the repository. Let\u2019s add some content: $ echo \"This file is very interesting\" > file.txt $ git add file.txt $ git commit -m \"This is the first commit\" [ master ( root-commit ) 23b3ed5 ] This is the first commit 1 file changed, 1 insertion ( + ) create mode 100644 file.txt $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) style B color:#FF0000 C([\".git/\"]) D([\"logs/\"]) style D color:#FF0000 E([\"COMMIT_EDITMSG\"]) style E color:#FF0000 F([\"index\"]) style F color:#FF0000 G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) style O color:#FF0000 P([\"1a\"]) style P color:#FF0000 Q([\"09\"]) style Q color:#FF0000 R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) style V color:#FF0000 W([\"098a06bf...\"]) style W color:#FF0000 X([\"c78e6e97...\"]) style X color:#FF0000 Y([\"master\"]) style Y color:#FF0000 A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y Working tree \u00b6 Everything inside repository/ is a part of the working tree (or the workspace ). .git/ is not included. At the moment, the working tree contains just one file, file.txt . Working tree is just a regular directory. The git add and git commit commands tell Git to care about file.txt . More on that later\u2026 Objects \u00b6 Git stores files etc as objects : Objects are stored under .git/objects/ . Git uses content-based addressing . A hash sum is computed from the content of the object. The hash \u201cuniquely\u201d identifies the object. Two objects with identical contents have the same hash and are stored only once. We can compute the hash manually: $ git hash-object file.txt 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a We can find the corresponding object: $ find ... ./.git/objects/09/c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a ... We can confirm that two files with identical contents have the same hash: $ cp file.txt file2.txt $ git hash-object file.txt file2.txt 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a Note that we do not have to use the entire hash: git cat-file -p 09c78e6e This file is very interesting We only need to use as many characters as is required to uniquely identify the object. 7-8 is enough in most cases. 12 in larger projects. If more characters is required, an error message is printed. Objects cannot (and should not) be accessed directly: $ hexdump -C ./.git/objects/09/c78e6e97* 00000000 78 01 4b ca c9 4f 52 30 .... | x.K..OR06 ` ...,VH | 00000010 cb cc 49 55 00 d2 65 a9 .... | ..IU..e.E...y%.E | 00000020 a9 c5 25 99 79 e9 5c 00 .... | ..%.y. \\. .I.3 | 0000002c However, we can observe the type and the content of an object: $ git cat-file -t 09c78e6e blob $ git cat-file -p 09c78e6e This file is very interesting It is also important to realize that the object stays even when the file is removed: $ rm file.txt $ find .... ./.git/objects/09/c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a .... $ git cat-file -p 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a This file is very interesting We can restore the file from the object: $ git restore file.txt $ cat file.txt This file is very interesting Let\u2019s take a second look at the repository: graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) style V color:#FF0000 W([\"098a06bf...\"]) style W color:#FF0000 X([\"c78e6e97...\"]) Y([\"master\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y What are these two other objects? Trees \u00b6 Let\u2019s investigate one of the remaining objects: $ git cat-file -t 1a098a06 tree $ git cat-file -p 1a098a06 100644 blob 09c78e6e971ce9e3d69e75b.... file.txt We can see that the type of the object is tree : A tree stores pointers to files (blobs) and other trees, Trees are used to represent directory structures. In this case, the tree has one level and one blob: graph TD first_blob[\"blob 09c78e6e... This file is very interesting\"] tree([\"tree 1a098a06b... blob 09c78e6e.... file.txt\"]) --> first_blob Let\u2019s take a third look at the repository: graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) style V color:#FF0000 W([\"098a06bf...\"]) X([\"c78e6e97...\"]) Y([\"master\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y Just one object remains\u2026 Commits \u00b6 Let\u2019s investigate the last object: $ git cat-file -t 23b3ed5b commit $ git cat-file -p 23b3ed5b tree 1a098a06bf0bcae9695238d9d5cb96345c00cacf author Mirko Myllykoski <....@gmail.com> 1600867851 +0200 committer Mirko Myllykoski <....@gmail.com> 1600867851 +0200 This is the first commit The type of the object is commit . It contains a pointer to a tree, an author and a committer (+time), and a commit message A commit stores the state of the project in a given point of time. In this case, the commit points to a tree that has one level and one blob: graph TD first_blob[\"blob 09c78e6e... This file is very interesting\"] file[\"file.txt This file is very interesting\"] commit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) --> tree([\"tree 1a098a06b... blob 09c78e6e.... file.txt\"]) --> first_blob metadata([\"metadata\"]) --> repo([\"repository/\"]) --> file In a more general case, the associated tree can contain several levels and multiple blobs: graph TD file1[\"file1.txt\"] file2[\"file2.txt\"] file3[\"file3.txt\"] file4[\"file4.txt\"] blob1[\"blob 1\"] blob2[\"blob 2\"] blob3[\"blob 3\"] blob4[\"blob 4\"] commit1([\"commit 1\"]) --> tree1([\"tree 1\"]) tree1 --> blob1 tree1 --> blob2 tree1 --> tree2([\"tree 2\"]) tree2 --> blob3 tree2 --> blob4 metadata([\"metadata\"]) --> repo([\"repository/\"]) repo --> file1 repo --> file2 repo --> dir([\"directory/\"]) dir --> file3 dir --> file4 Working with Git \u00b6 Let\u2019s see what else we can find\u2026 graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) style J color:#FF0000 K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) style M color:#FF0000 N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) style T color:#FF0000 U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) Y([\"master\"]) style Y color:#FF0000 A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y HEAD and other references \u00b6 HEAD points (indirectly) to 23b3ed5b1 : $ cat ./.git/HEAD ref: refs/heads/master $ cat .git/refs/heads/master 23b3ed5b16095bb84b18d06734fdd614c8982841 graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff, stroke:#ffffff first_blob[\"blob 09c78e6e... This file is very interesting\"] head --> master --> commit([\"commit 23b3ed5b1...\"]) --> tree([\"tree 1a098a06b...\"]) --> first_blob HEAD and master are references . A reference points to commits and another reference. HEAD determines \u201cmost recent\u201d commit. Many commands act on the current HEAD . More on this later master is the current branch (more later). You can create a reference yourself: $ git tag first $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) style J color:#FF0000 K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) style U color:#FF0000 V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) Y([\"master\"]) Z([\"first\"]) style Z color:#FF0000 A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y U --> Z $ git rev-parse first 23b3ed5b16095bb84b18d06734fdd614c8982841 graph LR first[\"first\"] style first fill:#ffffff,stroke:#ffffff first_blob[\"blob 09c78e6e... This file is very interesting\"] first --> commit([\"commit 23b3ed5b1...\"]) --> tree([\"tree 1a098a06b...\"]) --> first_blob Index (staging area) \u00b6 Let\u2019s repeat some of the earlier steps: $ echo \"More content\" >> file.txt $ git add file.txt $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) style B color:#FF0000 C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) QR([\"3b\"]) style QR color:#FF0000 R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) XY([\"23ff0c41...\"]) style XY color:#FF0000 Y([\"master\"]) Z([\"first\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> QR I --> R I --> S J --> T J --> U O --> V P --> W Q --> X QR --> XY T --> Y U --> Z $ git cat-file -p 3b23ff0c This file is very interesting More content The git add command creates a blob that correspond to the update file.txt file. No other object are created yet. The command also adds the file to the index . The index will become the next commit . Contains a representation of the tree object. The index is a binary file: graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) style F color:#FF0000 G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) QR([\"3b\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) XY([\"23ff0c41...\"]) Y([\"master\"]) Z([\"first\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> QR I --> R I --> S J --> T J --> U O --> V P --> W Q --> X QR --> XY T --> Y U --> Z We can now turn the index to the next commit: $ git commit -m \"This is the second commit\" [ master d3c6c63 ] This is the second commit 1 file changed, 1 insertion ( + ) $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) QR([\"3b\"]) QRR([\"22/\"]) style QRR color:#FF0000 QRRR([\"d3/\"]) style QRRR color:#FF0000 R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) XY([\"23ff0c41...\"]) XYY([\"b5208beb...\"]) style XYY color:#FF0000 XYYY([\"c6c635fb...\"]) style XYYY color:#FF0000 Y([\"master\"]) Z([\"first\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> QR I --> QRR I --> QRRR I --> R I --> S J --> T J --> U O --> V P --> W Q --> X QR --> XY QRR --> XYY QRRR --> XYYY T --> Y U --> Z Just as before, we have a tree object that describes the directory structure: $ git cat-file -p 22b5208b 100644 blob 3b23ff0c411faf22c9253ed0.... file.txt And a commit, that describes the state of the repository: $ git cat-file -p d3c6c635 tree 22b5208bebacfcf745691f799b08df492b2a7da9 parent 23b3ed5b16095bb84b18d06734fdd614c8982841 author Mirko Myllykoski <mirko...> 1601228824 +0200 committer Mirko Myllykoski <mirko....> 1601228824 +0200 This is the second commit Parent \u00b6 The major difference is that the commit contains a pointer to a parent : parent 23b3ed5b16095bb84b18d06734fdd614c8982841 The parent pointer points to the previous commit: graph LR secondcommit([\"commit d3c6c635... tree 22b5208b parent 23b3ed5b1 Mirko Myll.. This is the second commit\"]) --> firstcommit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) --> tree2([\"tree 1a098a06b... blob 09c78e6e.... file.txt\"]) secondcommit --> tree1([\"tree 22b5208b... blob 3b23ff0c file.txt\"]) secondblob[\"blob 3b23ff0c This file is very interesting More content\"] firstblob[\"blob 09c78e6e... This file is very interesting\"] tree2 --> firstblob tree1 --> secondblob Commit tree \u00b6 Usually, we have a complete tree of commits ( commit tree ): graph LR commit1([\"commit 1\"]) --> tree1([\"tree 1\"]) commit2([\"commit 2\"]) --> tree2([\"tree 2\"]) commit2 --> commit1 commit3([\"commit 3\"]) --> tree3([\"tree 3\"]) commit3 --> commit2 commit4([\"commit 4\"]) --> tree4([\"tree 4\"]) commit4 --> commit3 Each commit represents the state of the repository at a given point of time. Each commit is allowed to have multiple parents: graph LR commit2([\"commit 2\"]) --> commit1([\"commit 1\"]) commit4([\"commit 4\"]) --> commit3([\"commit 3\"]) commit4 --> commit2 These parents appear when two (or more) branches are merged . More on this later\u2026 HEAD and other references (again) \u00b6 Let\u2019s investigate HEAD and master : $ cat .git/HEAD ref: refs/heads/master $ cat .git/refs/heads/master d3c6c635fb44c7084797d47050bff7961853c19b graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff head --> master --> secondcommit([\"commit d3c6c635... tree 22b5208b parent 23b3ed5b1 Mirko Myll.. This is the second commit\"]) --> firstcommit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) subgraph clusterworkingtree[\"Working tree\"] clusterfile[\"file.txt This file is very interesting More content\"] end Remember, many Git commands act on the current HEAD . We can change the HEAD to something else: $ git checkout 23b3ed5b .... HEAD is now at 23b3ed5 This is the first commit $ cat .git/HEAD 23b3ed5b16095bb84b18d06734fdd614c8982841 $ cat file.txt This file is very interesting graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff master --> second_commit([\"commit d3c6c635... tree 22b5208b parent 23b3ed5b1 Mirko Myll.. This is the second commit\"]) --> first_commit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) head --> first_commit subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting\"] end Branches \u00b6 We can modify the working tree and create a new commit: $ echo \"Different content\" >> file.txt $ git commit -a -m \"This is the third commit\" [ detached HEAD a118ae8 ] This is the third commit 1 file changed, 1 insertion ( + ) Let\u2019s investigate the newly created commit: $ git cat-file -p a118ae8c tree 5fcc4f83fedf5a94cd773704bdb1ab2cdcadc6fd parent 23b3ed5b16095bb84b18d06734fdd614c8982841 author Mirko Myllykoski <mirko....> 1601286412 +0200 committer Mirko Myllykoski <mirko....> 1601286412 +0200 This is the third commit First, the parent points to the first commit : graph LR third_commit([\"commit a118ae8c... parent 23b3ed5b1... This is the third commit\"]) --> first_commit([\"commit 23b3ed5b1... This is the first commit\"]) Second, the commit tree now has two branches: graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] head --> third_commit([\"commit a118ae8c... This is the third commit\"]) -.-> third_blob master --> second_commit([\"commit d3c6c635... This is the second commit\"]) --> first_commit([\"commit 23b3ed5b1... This is the first commit\"]) third_commit --> first_commit second_commit -.-> second_blob first_commit -.-> first_blob subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting Different content\"] end We can give the second branch a name : $ git checkout -b second_branch Switched to a new branch 'second_branch' $ cat .git/HEAD ref: refs/heads/second_branch $ cat .git/refs/heads/second_branch a118ae8cda10a8f0a966ab7b9158b4a6d3b48cfc graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff second_branch[\"second_branch\"] style second_branch fill:#ffffff,stroke:#ffffff second_branch --> third_commit([\"commit a118ae8c... This is the third commit\"]) -.-> third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_commit([\"commit d3c6c635... This is the second commit\"]) first_commit([\"commit 23b3ed5b1... This is the first commit\"]) second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] second_commit -.-> second_blob first_commit -.-> first_blob third_commit --> first_commit second_commit --> first_commit head --> third_commit master --> second_commit subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting Different content\"] end Merging \u00b6 We can merge the two branches together: $ git checkout master $ git merge --no-ff second_branch Auto-merging file.txt CONFLICT ( content ) : Merge conflict in file.txt Automatic merge failed ; fix conflicts and then commit the result. $ vim file.txt We fix some conflicts at this point\u2026 $ git add file.txt $ git merge --continue [ master f0d7298 ] Merge branch 'second_branch' The created commit has two parents: $ git cat-file -p f0d72989 tree f63f3a4c548f5065cee598bed4ae189bd2c099d8 parent d3c6c635fb44c7084797d47050bff7961853c19b parent a118ae8cda10a8f0a966ab7b9158b4a6d3b48cfc author Mirko Myllykoski <mirko....> 1601288485 +0200 committer Mirko Myllykoski <mirko....> 1601288485 +0200 Merge branch 'second_branch' Finally, the tree looks like follows: graph LR subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting More content Different content\"] end graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff second_branch[\"second_branch\"] style second_branch fill:#ffffff,stroke:#ffffff fourth_commit([\"commit f0d72989... Merge branch 'second_branch'\"]) third_commit([\"commit a118ae8c... This is the third commit\"]) second_commit([\"commit d3c6c635... This is the second commit\"]) first_commit([\"commit 23b3ed5b1... This is the first commit\"]) fourth_blob[\"blob e51364b9 This file is very interesting More content Different content\"] third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] fourth_commit -.-> fourth_blob third_commit -.-> third_blob second_commit -.-> second_blob first_commit -.-> first_blob fourth_commit --> second_commit fourth_commit --> third_commit third_commit --> first_commit second_commit --> first_commit head --> fourth_commit master --> fourth_commit second_branch --> third_commit Switching to a specific commit \u00b6 We can always move back to any of the previous commits: $ git checkout 23b3ed5b1 .... HEAD is now at 23b3ed5 This is the first commit $ cat file.txt This file is very interesting graph LR subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting More content Different content\"] end graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff second_branch[\"second_branch\"] style second_branch fill:#ffffff,stroke:#ffffff fourth_commit([\"commit f0d72989... Merge branch 'second_branch'\"]) third_commit([\"commit a118ae8c... This is the third commit\"]) --> first_commit([\"commit 23b3ed5b1... This is the first commit\"]) second_commit([\"commit d3c6c635... This is the second commit\"]) head --> first_commit fourth_blob[\"blob e51364b9 This file is very interesting More content Different content\"] third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] fourth_commit -.-> fourth_blob third_commit -.-> third_blob second_commit -.-> second_blob first_commit -.-> first_blob fourth_commit --> second_commit fourth_commit --> third_commit second_commit --> first_commit master --> fourth_commit second_branch --> third_commit The end. An idea: Try to play with the different commands. See what happens to the .git/ directory.","title":"Basic Concepts"},{"location":"basic-concepts/#lecture__3__basic__concepts","text":"","title":"Lecture 3: Basic concepts"},{"location":"basic-concepts/#remark","text":"You are not intended to memorize any commands or low-level details. The goal is to learn the basic concepts : hash sums, blobs, trees, commits, references, branches, \u2026 Understanding these concepts helps to understand what the commands actually do!","title":"Remark"},{"location":"basic-concepts/#what__is__git","text":"Git is a distributed VCS: Does not rely on a server-client model. Instead, everyone has a full copy of the entire project (repository). Complete history, metadata, etc. People can work completely independently. An (optional) server is used only to distribute changes.","title":"What is Git?"},{"location":"basic-concepts/#why__use__git","text":"It is popular. Many project already use it, people know how to use it, people can tell you how to use it, \u2026 Relies on hash sums: Built-in data corruption detection. Built-in security. Distributed. Fast, simple and flexible. Free and open-source.","title":"Why use Git?"},{"location":"basic-concepts/#how__does__git__store__the__history","text":"","title":"How does Git store the history?"},{"location":"basic-concepts/#what__is__inside__a__repository","text":"$ mkdir repository && cd repository $ git init Initialized empty Git repository in .../repository/.git/ $ find graph TD A([\"repository/\"]) B([\".git/\"]) A --> B B --> C([\"branches/\"]) B --> D([\"hooks/\"]) B --> E([\"info/ \"]) B --> F([\"objects/\"]) B --> G([\"refs/\"]) B --> H([\"config\"]) B --> I([\"description\"]) B --> J([\"HEAD\"]) F --> K([\"info/\"]) F --> L([\"pack/\"]) G --> M([\"heads/\"]) G --> N([\"tags/\"]) Most directories are empty and the files are not that interesting: $ cat .git/config [ core ] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true $ cat .git/HEAD ref: refs/heads/master $ cat .git/description Unnamed repository ; edit this file 'description' to name the repository. Let\u2019s add some content: $ echo \"This file is very interesting\" > file.txt $ git add file.txt $ git commit -m \"This is the first commit\" [ master ( root-commit ) 23b3ed5 ] This is the first commit 1 file changed, 1 insertion ( + ) create mode 100644 file.txt $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) style B color:#FF0000 C([\".git/\"]) D([\"logs/\"]) style D color:#FF0000 E([\"COMMIT_EDITMSG\"]) style E color:#FF0000 F([\"index\"]) style F color:#FF0000 G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) style O color:#FF0000 P([\"1a\"]) style P color:#FF0000 Q([\"09\"]) style Q color:#FF0000 R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) style V color:#FF0000 W([\"098a06bf...\"]) style W color:#FF0000 X([\"c78e6e97...\"]) style X color:#FF0000 Y([\"master\"]) style Y color:#FF0000 A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y","title":"What is inside a repository?"},{"location":"basic-concepts/#working__tree","text":"Everything inside repository/ is a part of the working tree (or the workspace ). .git/ is not included. At the moment, the working tree contains just one file, file.txt . Working tree is just a regular directory. The git add and git commit commands tell Git to care about file.txt . More on that later\u2026","title":"Working tree"},{"location":"basic-concepts/#objects","text":"Git stores files etc as objects : Objects are stored under .git/objects/ . Git uses content-based addressing . A hash sum is computed from the content of the object. The hash \u201cuniquely\u201d identifies the object. Two objects with identical contents have the same hash and are stored only once. We can compute the hash manually: $ git hash-object file.txt 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a We can find the corresponding object: $ find ... ./.git/objects/09/c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a ... We can confirm that two files with identical contents have the same hash: $ cp file.txt file2.txt $ git hash-object file.txt file2.txt 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a Note that we do not have to use the entire hash: git cat-file -p 09c78e6e This file is very interesting We only need to use as many characters as is required to uniquely identify the object. 7-8 is enough in most cases. 12 in larger projects. If more characters is required, an error message is printed. Objects cannot (and should not) be accessed directly: $ hexdump -C ./.git/objects/09/c78e6e97* 00000000 78 01 4b ca c9 4f 52 30 .... | x.K..OR06 ` ...,VH | 00000010 cb cc 49 55 00 d2 65 a9 .... | ..IU..e.E...y%.E | 00000020 a9 c5 25 99 79 e9 5c 00 .... | ..%.y. \\. .I.3 | 0000002c However, we can observe the type and the content of an object: $ git cat-file -t 09c78e6e blob $ git cat-file -p 09c78e6e This file is very interesting It is also important to realize that the object stays even when the file is removed: $ rm file.txt $ find .... ./.git/objects/09/c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a .... $ git cat-file -p 09c78e6e971ce9e3d69e75bcb3ffd5de05b0d59a This file is very interesting We can restore the file from the object: $ git restore file.txt $ cat file.txt This file is very interesting Let\u2019s take a second look at the repository: graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) style V color:#FF0000 W([\"098a06bf...\"]) style W color:#FF0000 X([\"c78e6e97...\"]) Y([\"master\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y What are these two other objects?","title":"Objects"},{"location":"basic-concepts/#trees","text":"Let\u2019s investigate one of the remaining objects: $ git cat-file -t 1a098a06 tree $ git cat-file -p 1a098a06 100644 blob 09c78e6e971ce9e3d69e75b.... file.txt We can see that the type of the object is tree : A tree stores pointers to files (blobs) and other trees, Trees are used to represent directory structures. In this case, the tree has one level and one blob: graph TD first_blob[\"blob 09c78e6e... This file is very interesting\"] tree([\"tree 1a098a06b... blob 09c78e6e.... file.txt\"]) --> first_blob Let\u2019s take a third look at the repository: graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) style V color:#FF0000 W([\"098a06bf...\"]) X([\"c78e6e97...\"]) Y([\"master\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y Just one object remains\u2026","title":"Trees"},{"location":"basic-concepts/#commits","text":"Let\u2019s investigate the last object: $ git cat-file -t 23b3ed5b commit $ git cat-file -p 23b3ed5b tree 1a098a06bf0bcae9695238d9d5cb96345c00cacf author Mirko Myllykoski <....@gmail.com> 1600867851 +0200 committer Mirko Myllykoski <....@gmail.com> 1600867851 +0200 This is the first commit The type of the object is commit . It contains a pointer to a tree, an author and a committer (+time), and a commit message A commit stores the state of the project in a given point of time. In this case, the commit points to a tree that has one level and one blob: graph TD first_blob[\"blob 09c78e6e... This file is very interesting\"] file[\"file.txt This file is very interesting\"] commit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) --> tree([\"tree 1a098a06b... blob 09c78e6e.... file.txt\"]) --> first_blob metadata([\"metadata\"]) --> repo([\"repository/\"]) --> file In a more general case, the associated tree can contain several levels and multiple blobs: graph TD file1[\"file1.txt\"] file2[\"file2.txt\"] file3[\"file3.txt\"] file4[\"file4.txt\"] blob1[\"blob 1\"] blob2[\"blob 2\"] blob3[\"blob 3\"] blob4[\"blob 4\"] commit1([\"commit 1\"]) --> tree1([\"tree 1\"]) tree1 --> blob1 tree1 --> blob2 tree1 --> tree2([\"tree 2\"]) tree2 --> blob3 tree2 --> blob4 metadata([\"metadata\"]) --> repo([\"repository/\"]) repo --> file1 repo --> file2 repo --> dir([\"directory/\"]) dir --> file3 dir --> file4","title":"Commits"},{"location":"basic-concepts/#working__with__git","text":"Let\u2019s see what else we can find\u2026 graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) style J color:#FF0000 K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) style M color:#FF0000 N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) style T color:#FF0000 U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) Y([\"master\"]) style Y color:#FF0000 A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y","title":"Working with Git"},{"location":"basic-concepts/#head__and__other__references","text":"HEAD points (indirectly) to 23b3ed5b1 : $ cat ./.git/HEAD ref: refs/heads/master $ cat .git/refs/heads/master 23b3ed5b16095bb84b18d06734fdd614c8982841 graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff, stroke:#ffffff first_blob[\"blob 09c78e6e... This file is very interesting\"] head --> master --> commit([\"commit 23b3ed5b1...\"]) --> tree([\"tree 1a098a06b...\"]) --> first_blob HEAD and master are references . A reference points to commits and another reference. HEAD determines \u201cmost recent\u201d commit. Many commands act on the current HEAD . More on this later master is the current branch (more later). You can create a reference yourself: $ git tag first $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) style J color:#FF0000 K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) style U color:#FF0000 V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) Y([\"master\"]) Z([\"first\"]) style Z color:#FF0000 A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> R I --> S J --> T J --> U O --> V P --> W Q --> X T --> Y U --> Z $ git rev-parse first 23b3ed5b16095bb84b18d06734fdd614c8982841 graph LR first[\"first\"] style first fill:#ffffff,stroke:#ffffff first_blob[\"blob 09c78e6e... This file is very interesting\"] first --> commit([\"commit 23b3ed5b1...\"]) --> tree([\"tree 1a098a06b...\"]) --> first_blob","title":"HEAD and other references"},{"location":"basic-concepts/#index__staging__area","text":"Let\u2019s repeat some of the earlier steps: $ echo \"More content\" >> file.txt $ git add file.txt $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) style B color:#FF0000 C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) QR([\"3b\"]) style QR color:#FF0000 R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) XY([\"23ff0c41...\"]) style XY color:#FF0000 Y([\"master\"]) Z([\"first\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> QR I --> R I --> S J --> T J --> U O --> V P --> W Q --> X QR --> XY T --> Y U --> Z $ git cat-file -p 3b23ff0c This file is very interesting More content The git add command creates a blob that correspond to the update file.txt file. No other object are created yet. The command also adds the file to the index . The index will become the next commit . Contains a representation of the tree object. The index is a binary file: graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) style F color:#FF0000 G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) QR([\"3b\"]) R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) XY([\"23ff0c41...\"]) Y([\"master\"]) Z([\"first\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> QR I --> R I --> S J --> T J --> U O --> V P --> W Q --> X QR --> XY T --> Y U --> Z We can now turn the index to the next commit: $ git commit -m \"This is the second commit\" [ master d3c6c63 ] This is the second commit 1 file changed, 1 insertion ( + ) $ find graph TD A([\"repository/\"]) B([\"file.txt\"]) C([\".git/\"]) D([\"logs/\"]) E([\"COMMIT_EDITMSG\"]) F([\"index\"]) G([\"branches/\"]) H([\"hooks/\"]) I([\"objects/\"]) J([\"refs/\"]) K([\"config\"]) L([\"description\"]) M([\"HEAD\"]) N([\"info/ \"]) O([\"23\"]) P([\"1a\"]) Q([\"09\"]) QR([\"3b\"]) QRR([\"22/\"]) style QRR color:#FF0000 QRRR([\"d3/\"]) style QRRR color:#FF0000 R([\"info/ \"]) S([\"pack/\"]) T([\"heads/\"]) U([\"tags/\"]) V([\"b3ed5b16...\"]) W([\"098a06bf...\"]) X([\"c78e6e97...\"]) XY([\"23ff0c41...\"]) XYY([\"b5208beb...\"]) style XYY color:#FF0000 XYYY([\"c6c635fb...\"]) style XYYY color:#FF0000 Y([\"master\"]) Z([\"first\"]) A --> B A --> C C --> D C --> E C --> F C --> G C --> H C --> I C --> J C --> K C --> L C --> M C --> N I --> O I --> P I --> Q I --> QR I --> QRR I --> QRRR I --> R I --> S J --> T J --> U O --> V P --> W Q --> X QR --> XY QRR --> XYY QRRR --> XYYY T --> Y U --> Z Just as before, we have a tree object that describes the directory structure: $ git cat-file -p 22b5208b 100644 blob 3b23ff0c411faf22c9253ed0.... file.txt And a commit, that describes the state of the repository: $ git cat-file -p d3c6c635 tree 22b5208bebacfcf745691f799b08df492b2a7da9 parent 23b3ed5b16095bb84b18d06734fdd614c8982841 author Mirko Myllykoski <mirko...> 1601228824 +0200 committer Mirko Myllykoski <mirko....> 1601228824 +0200 This is the second commit","title":"Index (staging area)"},{"location":"basic-concepts/#parent","text":"The major difference is that the commit contains a pointer to a parent : parent 23b3ed5b16095bb84b18d06734fdd614c8982841 The parent pointer points to the previous commit: graph LR secondcommit([\"commit d3c6c635... tree 22b5208b parent 23b3ed5b1 Mirko Myll.. This is the second commit\"]) --> firstcommit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) --> tree2([\"tree 1a098a06b... blob 09c78e6e.... file.txt\"]) secondcommit --> tree1([\"tree 22b5208b... blob 3b23ff0c file.txt\"]) secondblob[\"blob 3b23ff0c This file is very interesting More content\"] firstblob[\"blob 09c78e6e... This file is very interesting\"] tree2 --> firstblob tree1 --> secondblob","title":"Parent"},{"location":"basic-concepts/#commit__tree","text":"Usually, we have a complete tree of commits ( commit tree ): graph LR commit1([\"commit 1\"]) --> tree1([\"tree 1\"]) commit2([\"commit 2\"]) --> tree2([\"tree 2\"]) commit2 --> commit1 commit3([\"commit 3\"]) --> tree3([\"tree 3\"]) commit3 --> commit2 commit4([\"commit 4\"]) --> tree4([\"tree 4\"]) commit4 --> commit3 Each commit represents the state of the repository at a given point of time. Each commit is allowed to have multiple parents: graph LR commit2([\"commit 2\"]) --> commit1([\"commit 1\"]) commit4([\"commit 4\"]) --> commit3([\"commit 3\"]) commit4 --> commit2 These parents appear when two (or more) branches are merged . More on this later\u2026","title":"Commit tree"},{"location":"basic-concepts/#head__and__other__references__again","text":"Let\u2019s investigate HEAD and master : $ cat .git/HEAD ref: refs/heads/master $ cat .git/refs/heads/master d3c6c635fb44c7084797d47050bff7961853c19b graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff head --> master --> secondcommit([\"commit d3c6c635... tree 22b5208b parent 23b3ed5b1 Mirko Myll.. This is the second commit\"]) --> firstcommit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) subgraph clusterworkingtree[\"Working tree\"] clusterfile[\"file.txt This file is very interesting More content\"] end Remember, many Git commands act on the current HEAD . We can change the HEAD to something else: $ git checkout 23b3ed5b .... HEAD is now at 23b3ed5 This is the first commit $ cat .git/HEAD 23b3ed5b16095bb84b18d06734fdd614c8982841 $ cat file.txt This file is very interesting graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff master --> second_commit([\"commit d3c6c635... tree 22b5208b parent 23b3ed5b1 Mirko Myll.. This is the second commit\"]) --> first_commit([\"commit 23b3ed5b1... tree 1a098a06b Mirko Myll... This is the first commit\"]) head --> first_commit subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting\"] end","title":"HEAD and other references (again)"},{"location":"basic-concepts/#branches","text":"We can modify the working tree and create a new commit: $ echo \"Different content\" >> file.txt $ git commit -a -m \"This is the third commit\" [ detached HEAD a118ae8 ] This is the third commit 1 file changed, 1 insertion ( + ) Let\u2019s investigate the newly created commit: $ git cat-file -p a118ae8c tree 5fcc4f83fedf5a94cd773704bdb1ab2cdcadc6fd parent 23b3ed5b16095bb84b18d06734fdd614c8982841 author Mirko Myllykoski <mirko....> 1601286412 +0200 committer Mirko Myllykoski <mirko....> 1601286412 +0200 This is the third commit First, the parent points to the first commit : graph LR third_commit([\"commit a118ae8c... parent 23b3ed5b1... This is the third commit\"]) --> first_commit([\"commit 23b3ed5b1... This is the first commit\"]) Second, the commit tree now has two branches: graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] head --> third_commit([\"commit a118ae8c... This is the third commit\"]) -.-> third_blob master --> second_commit([\"commit d3c6c635... This is the second commit\"]) --> first_commit([\"commit 23b3ed5b1... This is the first commit\"]) third_commit --> first_commit second_commit -.-> second_blob first_commit -.-> first_blob subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting Different content\"] end We can give the second branch a name : $ git checkout -b second_branch Switched to a new branch 'second_branch' $ cat .git/HEAD ref: refs/heads/second_branch $ cat .git/refs/heads/second_branch a118ae8cda10a8f0a966ab7b9158b4a6d3b48cfc graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff second_branch[\"second_branch\"] style second_branch fill:#ffffff,stroke:#ffffff second_branch --> third_commit([\"commit a118ae8c... This is the third commit\"]) -.-> third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_commit([\"commit d3c6c635... This is the second commit\"]) first_commit([\"commit 23b3ed5b1... This is the first commit\"]) second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] second_commit -.-> second_blob first_commit -.-> first_blob third_commit --> first_commit second_commit --> first_commit head --> third_commit master --> second_commit subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting Different content\"] end","title":"Branches"},{"location":"basic-concepts/#merging","text":"We can merge the two branches together: $ git checkout master $ git merge --no-ff second_branch Auto-merging file.txt CONFLICT ( content ) : Merge conflict in file.txt Automatic merge failed ; fix conflicts and then commit the result. $ vim file.txt We fix some conflicts at this point\u2026 $ git add file.txt $ git merge --continue [ master f0d7298 ] Merge branch 'second_branch' The created commit has two parents: $ git cat-file -p f0d72989 tree f63f3a4c548f5065cee598bed4ae189bd2c099d8 parent d3c6c635fb44c7084797d47050bff7961853c19b parent a118ae8cda10a8f0a966ab7b9158b4a6d3b48cfc author Mirko Myllykoski <mirko....> 1601288485 +0200 committer Mirko Myllykoski <mirko....> 1601288485 +0200 Merge branch 'second_branch' Finally, the tree looks like follows: graph LR subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting More content Different content\"] end graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff second_branch[\"second_branch\"] style second_branch fill:#ffffff,stroke:#ffffff fourth_commit([\"commit f0d72989... Merge branch 'second_branch'\"]) third_commit([\"commit a118ae8c... This is the third commit\"]) second_commit([\"commit d3c6c635... This is the second commit\"]) first_commit([\"commit 23b3ed5b1... This is the first commit\"]) fourth_blob[\"blob e51364b9 This file is very interesting More content Different content\"] third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] fourth_commit -.-> fourth_blob third_commit -.-> third_blob second_commit -.-> second_blob first_commit -.-> first_blob fourth_commit --> second_commit fourth_commit --> third_commit third_commit --> first_commit second_commit --> first_commit head --> fourth_commit master --> fourth_commit second_branch --> third_commit","title":"Merging"},{"location":"basic-concepts/#switching__to__a__specific__commit","text":"We can always move back to any of the previous commits: $ git checkout 23b3ed5b1 .... HEAD is now at 23b3ed5 This is the first commit $ cat file.txt This file is very interesting graph LR subgraph cluster_working_tree[\"Working tree\"] cluster_file[\"file.txt This file is very interesting More content Different content\"] end graph LR head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff master[\"master\"] style master fill:#ffffff,stroke:#ffffff second_branch[\"second_branch\"] style second_branch fill:#ffffff,stroke:#ffffff fourth_commit([\"commit f0d72989... Merge branch 'second_branch'\"]) third_commit([\"commit a118ae8c... This is the third commit\"]) --> first_commit([\"commit 23b3ed5b1... This is the first commit\"]) second_commit([\"commit d3c6c635... This is the second commit\"]) head --> first_commit fourth_blob[\"blob e51364b9 This file is very interesting More content Different content\"] third_blob[\"blob ea5f4b8e This file is very interesting Different content\"] second_blob[\"blob 3b23ff0c This file is very interesting More content\"] first_blob[\"blob 09c78e6e... This file is very interesting\"] fourth_commit -.-> fourth_blob third_commit -.-> third_blob second_commit -.-> second_blob first_commit -.-> first_blob fourth_commit --> second_commit fourth_commit --> third_commit second_commit --> first_commit master --> fourth_commit second_branch --> third_commit The end. An idea: Try to play with the different commands. See what happens to the .git/ directory.","title":"Switching to a specific commit"},{"location":"branches-exercises/","text":"Exercises - Branches, merges, and conflicts \u00b6 In order to do these exercises, you need to download the exercises zip file (if you already did so for the previous exercise, you do not need to do so again, of course). You can do that either by cloning the repository or by just getting the zip file with wget . Do ONE of the following: git clone git clone https://github.com/hpc2n/course-intro-git.git cd course-intro-git unzip git_materials.zip cd git_materials cd 5.branches Fetch with wget wget https://github.com/hpc2n/course-intro-git/raw/refs/heads/main/git_materials.zip unzip git_materials.zip cd git_materials cd 5.branches You are now in a directory with 5 subdirectories, one for each exercise. 1. Merging two local branches \u00b6 Note The purpose of this exercise is to test the command git merge and see that the merge goes well in this case. Situation: The ingredient list in branch \u201cmaster\u201d has an error in the ingredients which is fixed in the branch \u201cfixed-recipe\u201d. Start by making sure you are in the directory git_materials/5.branches/1.merge-ok/recipes . First do git status to look at the status. You can also run git log so you can compare before and after merging. Now try to merge the two branches. You will see that it merges with a \u201cfast-forward\u201d merge. NOTE: Remember to check that you are on the right branch! Use git branch to check. Merging the branch \u201cfixed-recipe\u201d to the \u201cmaster\u201d branch: git merge fixed-recipe See that the merge goes well, and that git reports using \u201cfast-forward\u201d merge. Do git log and git status after the merge and compare what you got before. Think about why git could merge the two braches automatically and why it used \u201cfast-forward\u201d merge. 2. Merging two local branches, recursive \u00b6 Note In this exercise you will again try the command git merge and it should again go well. However, this time git will do a recursive merge, or in newer version an \u201cort\u201d merge. Situation: The ingredient list in branch \u201cmaster\u201d has an error in the ingredients which is fixed in the branch \u201cfixed-recipes\u201d. After that fix, a small change was made to the recipe in the \u201cmaster\u201d branch. Start by making sure you are in the directory git_materials/5.branches/2.merge-ok-recursive/recipes . First do git status to look at the status. Also run git log and see the commits that have been made and to which branches. Now try to merge the two branches. You will see that the merge happens with \u201crecursive\u201d merge. NOTE: Remember to check you are on the right branch before you try to merge! Merge the branch \u201cfixed-recipe\u201d to the \u201cmaster\u201d branch using the git merge command. Notice that the merge goes well and that git reports using \u201crecursive\u201d merge. Do git log and git status after the merge and compare with what you got before. Why did git use \u201crecursive\u201d merge? 3. Merging two local branches resulting in a merge conflict \u00b6 Note This exercise will again feature the command git merge , but this time the merge will fail and git will give a merge conflict. Situation: In the branch \u201cmetric\u201d we change the recipe to use the metric system for measurements. Then we change back to the \u201cmaster\u201d branch and add some coffee to that version of the recipe. Start by making sure you are in the directory git_materials/5.branches/3.merge-bad/recipes . Do a git status first and note the result. Run git log . You could also look at the output from the longer command: $ git log --oneline --abbrev-commit --all --graph or with the alias command git graph NOTE: Remember to change to the subdirectory \u201crecipes\u201d first! Now try to merge the two branches with the git merge command and see that a conflict happens. NOTE: Check with git branch to find out if you are on the right branch before trying to merge. You will get an error similar to this: $ git merge metric Auto-merging cakerecipe.txt CONFLICT (content): Merge conflict in cakerecipe.txt Automatic merge failed; fix conflicts and then commit the result. Use git log (including with the above mentioned flags) and git status to see where the problems are and see if you can fix the conflict and then reattempt the merge. 4. Rebase two local branches \u00b6 Note In this exercise you will try to use the command git rebase . You will see that it succeeds. Situation: The ingredient list in branch \u201cmaster\u201d has an error in the ingredients which is fixed in the branch \u201cfixed-recipe\u201d. Then we decide to make a small change to the recipe, and we do it in the \u201cmaster\u201d branch. Start by making sure you are in the directory git_materials/5.branches/4.rebase-ok/recipes . First do a git status and a git log and look at the results. Also look at the output at the longer command (git graph): $ git log --oneline --abbrev-commit --all --graph And save the result somewhere for later comparison. Now try to rebase the \u201cmaster\u201d with the new branch, \u201cfixed-recipe\u201d. You will see that the rebase succeeds. NOTE: Remember to check with git branch that you are on the right branch before you try to rebase! You should now validate the operation with git log and git status . Also run git graph or git log with the following flags: $ git log --oneline --abbrev-commit --all --graph 5. Rebase two local branches resulting in a conflict \u00b6 Note This exercise will again let you rebase two branches, using the command git rebase . In this case the rebase will fail. Situation: In the branch \u201cmetric\u201d we change the recipe to use the metric system for measurements. Then we switch back to the \u201cmaster\u201d branch and add some coffee to that version of the recipe. Start by making sure you are in the directory git_materials/5.branches/5.rebase-bad/recipes . Check status and history with git status and git graph or git log first, including with the following flags to git log : $ git log --oneline --abbrev-commit --all --graph 2. Try to rebase the \u201cmaster\u201d branch to the \u201cmetric\u201d branch using the git rebase command and see that a conflict happens. NOTE: Remember to check with git branch to find out if you are on the right branch before trying to rebase. You will get an error more or less similar to this: $ git rebase master First, rewinding head to replay your work on top of it... Applying: Change from imperial units to metric units. Using index info to reconstruct a base tree... M cakerecipe.txt Falling back to patching base and 3-way merge... Auto-merging cakerecipe.txt CONFLICT (content): Merge conflict in cakerecipe.txt error: Failed to merge in the changes. Patch failed at 0001 Change from imperial units to metric units. Use 'git am --show-current-patch' to see the failed patch Resolve all conflicts manually, mark them as resolved with \"git add/rm <conflicted_files>\", then run \"git rebase --continue\". You can instead skip this commit: run \"git rebase --skip\". To abort and get back to the state before \"git rebase\", run \"git rebase --abort\". 3. Use git log (with the above flags) or git graph and git status to see where the problems are. See if you can fix the conflict and then reattempt the rebase.","title":"Branches, merges, and conflicts"},{"location":"branches-exercises/#exercises__-__branches__merges__and__conflicts","text":"In order to do these exercises, you need to download the exercises zip file (if you already did so for the previous exercise, you do not need to do so again, of course). You can do that either by cloning the repository or by just getting the zip file with wget . Do ONE of the following: git clone git clone https://github.com/hpc2n/course-intro-git.git cd course-intro-git unzip git_materials.zip cd git_materials cd 5.branches Fetch with wget wget https://github.com/hpc2n/course-intro-git/raw/refs/heads/main/git_materials.zip unzip git_materials.zip cd git_materials cd 5.branches You are now in a directory with 5 subdirectories, one for each exercise.","title":"Exercises - Branches, merges, and conflicts"},{"location":"branches-exercises/#1__merging__two__local__branches","text":"Note The purpose of this exercise is to test the command git merge and see that the merge goes well in this case. Situation: The ingredient list in branch \u201cmaster\u201d has an error in the ingredients which is fixed in the branch \u201cfixed-recipe\u201d. Start by making sure you are in the directory git_materials/5.branches/1.merge-ok/recipes . First do git status to look at the status. You can also run git log so you can compare before and after merging. Now try to merge the two branches. You will see that it merges with a \u201cfast-forward\u201d merge. NOTE: Remember to check that you are on the right branch! Use git branch to check. Merging the branch \u201cfixed-recipe\u201d to the \u201cmaster\u201d branch: git merge fixed-recipe See that the merge goes well, and that git reports using \u201cfast-forward\u201d merge. Do git log and git status after the merge and compare what you got before. Think about why git could merge the two braches automatically and why it used \u201cfast-forward\u201d merge.","title":"1. Merging two local branches"},{"location":"branches-exercises/#2__merging__two__local__branches__recursive","text":"Note In this exercise you will again try the command git merge and it should again go well. However, this time git will do a recursive merge, or in newer version an \u201cort\u201d merge. Situation: The ingredient list in branch \u201cmaster\u201d has an error in the ingredients which is fixed in the branch \u201cfixed-recipes\u201d. After that fix, a small change was made to the recipe in the \u201cmaster\u201d branch. Start by making sure you are in the directory git_materials/5.branches/2.merge-ok-recursive/recipes . First do git status to look at the status. Also run git log and see the commits that have been made and to which branches. Now try to merge the two branches. You will see that the merge happens with \u201crecursive\u201d merge. NOTE: Remember to check you are on the right branch before you try to merge! Merge the branch \u201cfixed-recipe\u201d to the \u201cmaster\u201d branch using the git merge command. Notice that the merge goes well and that git reports using \u201crecursive\u201d merge. Do git log and git status after the merge and compare with what you got before. Why did git use \u201crecursive\u201d merge?","title":"2. Merging two local branches, recursive"},{"location":"branches-exercises/#3__merging__two__local__branches__resulting__in__a__merge__conflict","text":"Note This exercise will again feature the command git merge , but this time the merge will fail and git will give a merge conflict. Situation: In the branch \u201cmetric\u201d we change the recipe to use the metric system for measurements. Then we change back to the \u201cmaster\u201d branch and add some coffee to that version of the recipe. Start by making sure you are in the directory git_materials/5.branches/3.merge-bad/recipes . Do a git status first and note the result. Run git log . You could also look at the output from the longer command: $ git log --oneline --abbrev-commit --all --graph or with the alias command git graph NOTE: Remember to change to the subdirectory \u201crecipes\u201d first! Now try to merge the two branches with the git merge command and see that a conflict happens. NOTE: Check with git branch to find out if you are on the right branch before trying to merge. You will get an error similar to this: $ git merge metric Auto-merging cakerecipe.txt CONFLICT (content): Merge conflict in cakerecipe.txt Automatic merge failed; fix conflicts and then commit the result. Use git log (including with the above mentioned flags) and git status to see where the problems are and see if you can fix the conflict and then reattempt the merge.","title":"3. Merging two local branches resulting in a merge conflict"},{"location":"branches-exercises/#4__rebase__two__local__branches","text":"Note In this exercise you will try to use the command git rebase . You will see that it succeeds. Situation: The ingredient list in branch \u201cmaster\u201d has an error in the ingredients which is fixed in the branch \u201cfixed-recipe\u201d. Then we decide to make a small change to the recipe, and we do it in the \u201cmaster\u201d branch. Start by making sure you are in the directory git_materials/5.branches/4.rebase-ok/recipes . First do a git status and a git log and look at the results. Also look at the output at the longer command (git graph): $ git log --oneline --abbrev-commit --all --graph And save the result somewhere for later comparison. Now try to rebase the \u201cmaster\u201d with the new branch, \u201cfixed-recipe\u201d. You will see that the rebase succeeds. NOTE: Remember to check with git branch that you are on the right branch before you try to rebase! You should now validate the operation with git log and git status . Also run git graph or git log with the following flags: $ git log --oneline --abbrev-commit --all --graph","title":"4. Rebase two local branches"},{"location":"branches-exercises/#5__rebase__two__local__branches__resulting__in__a__conflict","text":"Note This exercise will again let you rebase two branches, using the command git rebase . In this case the rebase will fail. Situation: In the branch \u201cmetric\u201d we change the recipe to use the metric system for measurements. Then we switch back to the \u201cmaster\u201d branch and add some coffee to that version of the recipe. Start by making sure you are in the directory git_materials/5.branches/5.rebase-bad/recipes . Check status and history with git status and git graph or git log first, including with the following flags to git log : $ git log --oneline --abbrev-commit --all --graph 2. Try to rebase the \u201cmaster\u201d branch to the \u201cmetric\u201d branch using the git rebase command and see that a conflict happens. NOTE: Remember to check with git branch to find out if you are on the right branch before trying to rebase. You will get an error more or less similar to this: $ git rebase master First, rewinding head to replay your work on top of it... Applying: Change from imperial units to metric units. Using index info to reconstruct a base tree... M cakerecipe.txt Falling back to patching base and 3-way merge... Auto-merging cakerecipe.txt CONFLICT (content): Merge conflict in cakerecipe.txt error: Failed to merge in the changes. Patch failed at 0001 Change from imperial units to metric units. Use 'git am --show-current-patch' to see the failed patch Resolve all conflicts manually, mark them as resolved with \"git add/rm <conflicted_files>\", then run \"git rebase --continue\". You can instead skip this commit: run \"git rebase --skip\". To abort and get back to the state before \"git rebase\", run \"git rebase --abort\". 3. Use git log (with the above flags) or git graph and git status to see where the problems are. See if you can fix the conflict and then reattempt the rebase.","title":"5. Rebase two local branches resulting in a conflict"},{"location":"branches/","text":"Lecture 5: Branches \u00b6 Objectives \u00b6 Get some more hands-on working with branches creation switching merging deletion handling uncommitted changes stashing discarding checkout with merge merging and merge conflicts rebasing: combining a sequence of commits to a new base commit. cherry-picking What is a Git branch? \u00b6 A pointer to a commit (ref: named pointer) Defined as all points reachable in the commit graph from the named commit (the \u201ctip\u201d of the branch) The ref HEAD determines what branch you are on. If HEAD is a symbolic ref for an existing branch, then you are \u201con\u201d that branch. If HEAD is a simple ref directly naming a commit by its SHA-1 ID, you are not \u201con\u201d any branch - you are in \u201cdetached HEAD\u201d mode, which happens when you check out some earlier commit to examine. Why use branches? \u00b6 There are many uses for branches: Test different directions for a project Several projects members would like to work on their own copy of the code Bug fixes that are not yet tested, but will later be merged into the main version What is a Git branch? \u00b6 Until now, we have worked with a repository that only have one branch, with the commits done one at a time: In the above picture, the master branch points to a commit. The current position is HEAD. (Time goes rightwards) What is a Git branch - basic concepts \u00b6 Now we want to look at repositories with several branches: Branches are used to create another line of development. They are \u201cindividual projects\u201d within a git repository. The branch is the commit and all its parent commits, not just the one we are currently pointing at. The main line of development is usually called the \u201cmaster\u201d branch. Different branches within a repository can have completely different files and folders almost everything the same except for a few lines of code in a file Usually, a branch is created to work on a new feature. Once the feature is completed, it is merged back with the master branch. Branches: Creation \u00b6 Creating a new branch does not change the repository, it just adds a new reference to the commit. Note that the branch is created from the current HEAD. To create a new branch (called cool-feature in the following): $ git branch cool-feature To move to another branch (switch): $ git checkout cool-feature or\u2026 $ git switch cool-feature If you wish to switch to a new branch that is not yet created, you can do so by adding the flag -b to git checkout . To see which branch you are on: $ git branch Branches: merging, deletion \u00b6 When you have decided you are happy with the changes you made to the new branch, merge it back to the master branch (or another branch) Note: The branch is always merged to the current HEAD. First switch to the branch you are merging it to: $ git checkout master Then merge them: $ git merge cool-feature You can now delete the extra branch: $ git branch -d cool-feature Example - Type along if you wish \u00b6 Create a directory. Initialize a repository Create a file, stage it, and commit it $ mkdir my-project ; cd my-project/ $ git init Initialized empty Git repository in /home/bbrydsoe/my-project/.git/ $ touch file.txt $ git add file.txt $ git commit -m \"Committing the first file\" [ master ( root-commit ) 1006b51 ] Committing the first file 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file.txt Create a new branch, then switch to that branch Make some changes - add files and text ( > overwrites or are suitable for new file) Stage the file and commit it $ git branch cool-feature $ git checkout cool-feature Switched to branch 'cool-feature' $ echo \"This is a text\" > file.txt $ git add file.txt $ git commit -m \"Added text to the first file\" [ cool-feature 5bad966 ] Added text to the first file 1 file changed, 1 insertion ( + ) Switch back to the master branch, make some changes $ git checkout master Switched to branch 'master' $ echo \"Text to the second file\" > second-file.txt $ git add second-file.txt $ git commit -m \"Added a second file\" [ master bdec2cf ] Added a second file 1 file changed, 1 insertion ( + ) create mode 100644 second-file.txt We should check the effect of the changes. I will use this command: $ git log --graph --oneline --decorate --all or, if you made an alias before. $ git graph Otherwise make the alias: $ git config --global alias.graph \"log --all --graph --decorate --oneline\" This is on the master branch $ git graph * bdec2cf ( HEAD -> master ) Added a second file | * 5bad966 ( cool-feature ) Added text to the first file | / * 1006b51 Committing the first file We now merge the branches and check again $ git merge cool-feature Merge made by the 'recursive' strategy. file.txt | 1 + 1 file changed, 1 insertion ( + ) Note that in recent git versions (>=2.33) the default \u201crecursive\u201d strategy is replaced by the \u201cort\u201d strategy. $ git graph * cf3e6b7 ( HEAD -> master ) Merge branch 'cool-feature' | \\ | * 5bad966 ( cool-feature ) Added text to the first file * | bdec2cf Added a second file | / * 1006b51 Committing the first file Now we can delete the new branch we had created, since all the content is now in the master branch. $ git branch -d cool-feature Deleted branch cool-feature ( was 5bad966 ) . Comment: It is good practice to keep old branches for understanding of the development. Deletion could however be done for very evident mistakes or insignificant issues. In a somewhat nicer format, it looks like this: We commit stuff to both branches graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff cool-feature[\"cool-feature\"] style cool-feature fill:#ffffff,stroke:#ffffff commitX([\"commitX\"]) commit1([\"commit1\"]) commit2([\"commit2\"]) commitY([\"commitY\"]) commit3([\"commit3\"]) master -.-> commit3 commit3 --> commit2 commit2 --> commit1 cool-feature -.-> commitY commitY --> commitX commitX --> commit1 (Time goes leftwards) Merge \u2018cool-feature\u2019 to \u2018master\u2019 (3-way merge) 3-way merges use a dedicated commit for connecting the two merge histories. The name comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor. graph LR commit4Y([\"New merge commit\"]) master[\"master\"] style master fill:#ffffff,stroke:#ffffff cool-feature[\"cool-feature\"] style cool-feature fill:#ffffff,stroke:#ffffff commitX([\"commitX\"]) commit1([\"commit1\"]) commit2([\"commit2\"]) commitY([\"commitY\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) master -.-> commit4Y commit4 --> commit3 commit4Y --> commit4 cool-feature -.-> commitY commit3 --> commit2 commit2 --> commit1 commitY --> commitX commit4Y --> commitY commitX --> commit1 Delete \u2018cool-feature\u2019 graph LR commit4Y([\"New merge commit\"]) master[\"master\"] style master fill:#ffffff,stroke:#ffffff commitX([\"commitX\"]) commit1([\"commit1\"]) commit2([\"commit2\"]) commitY([\"commitY\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) master -.-> commit4Y commit4 --> commit3 commit4Y --> commit4 commit3 --> commit2 commit2 --> commit1 commitY --> commitX commit4Y --> commitY commitX --> commit1 (Time goes leftwards) Example, fast-forward merging \u00b6 If there is a linear path from the current branch tip and to the target branch, then it is possible to do a fast-forward merge. Git is not really merging the branches, just integrating the histories, i.e. it moves \u201cfast forward\u201d the current branch tip up to the target branch tip. When doing so the commit histories are combined and all commit histories can be reached from the current tip. An example would be to do a fast-forward merge of a feature into master/main. A fast-forward merge is not possible if the branches have diverged, like in the previous example. This means that there is no linear path to the target branch and Git has to combine them via a 3-way merge. This shows an example where a fast-forward merge would work. Before FF merge: graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff nice-feature[\"nice-feature\"] style nice-feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) master -.-> commit3 nice-feature -.-> commitY commit1 --> commit2 commit2 --> commit3 commit3 --> commitX commitX --> commitY After FF merge: graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff nice-feature[\"nice-feature\"] style nice-feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) master -.-> commitY nice-feature -.-> commitY commit1 --> commit2 commit2 --> commit3 commit3 --> commitX commitX --> commitY Switching with uncommitted changes \u00b6 As mentioned above, you switch between branches with: $ git checkout <branch> What happens if you have uncommitted changes (and/or new files added) when you try to switch? The uncommitted changes will be carried to the new branch that you switch to, if possible. Changes that you commit will be committed to the newly switched branch. What if there is a conflict? - You will not be allowed to switch to the other branch. - You must commit or stash any conflicting changes before switching branches. Example - new file \u00b6 Here we create a new branch, switch to it, then add a new file. Then we switch back to the master branch without committing the changes: $ git checkout -b cool-feature Switched to a new branch 'cool-feature' $ touch newfile.txt $ git add newfile.txt $ git checkout master A newfile.txt Switched to branch 'master' Git warns that there is a file added ( A ) in one branch but not the other, but the switch is allowed. Example - modified file \u00b6 We continue in the same repository! First commit the newfile.txt in the cool-feature branch to clean the environment. If we make changes to the file in one of the branches (go back to cool-feature ) but not on the other and do not commit it, then git will again warn: $ git switch cool-feature $ git commit -m \"newfile.txt\" $ echo \"Adding some text\" >> second-file.txt $ git add second-file.txt $ git checkout master M second-file.txt Switched to branch 'master' Git warns that there is a file that is modified ( M ) in one branch but not the other, but the switch is allowed. Example - uncommitted, conflicting changes \u00b6 We continue in the same repository! Assume two branches, \u201ccool-feature\u201d and \u201cmorefeatures\u201d Create the branch \u201cmorefeatures\u201d without switching to it Switch to branch \u201ccool-feature\u201d, add some text to a file, stage the file and commit it: $ git branch morefeatures $ git checkout cool-feature Switched to branch 'cool-feature' $ git commit -m \"second-file.txt\" $ echo \"add text\" >> morefiles.txt $ git add morefiles.txt $ git commit -m \"Some text\" [ cool-feature 469542b ] Some text 1 file changed, 1 insertion ( + ) create mode 100644 morefiles.txt Switch to branch \u201cmorefeatures\u201d. Modify the same file, stage the file and commit it. Then try and switch back to the \u201ccool-features\u201d branch: $ git checkout morefeatures Switched to branch 'morefeatures' $ echo \"Adding yet some more text\" >> morefiles.txt $ git add morefiles.txt $ git checkout cool-feature error: Your local changes to the following files would be overwritten by checkout: morefiles.txt Please commit your changes or stash them before you switch branches. Aborting Now Git complains and do not allow the switch. Handling uncommitted changes \u00b6 So, what can we do if there is a conflict? Commit the changes before switching branch Stash the uncommitted changes Discard the uncommitted changes Checkout with Merge Stashing \u00b6 The command \u201cstash\u201d can be described as a drawer where you store uncommitted changes temporarily. After stashing your uncommitted changes you can continue working on other things in a different branch. The uncommitted changes that are stored in the stash can be taken out and applied to any branch, including the original branch. Stashing, example (no type-along this time) \u00b6 First do a git status in the branch where you may have uncommitted changes: $ git status On branch morefeatures Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file.txt new file: morefiles.txt You can see the dirty status. To fix it, let us use git stash : $ git stash Saved working directory and index state WIP on morefeatures: 4922606 Some text Checking again with git status : $ git status On branch morefeatures nothing to commit, working tree clean You can now switch branches and work on something else. Working with stashes (repetition) \u00b6 You can have several stashes stored. To see them, use $ git stash list Example: $ git stash list stash@{0}: WIP on morefeatures: 4922606 Some text stash@{1}: WIP on morefeatures: 4922606 Some text stash@{2}: WIP on morefeatures: 4922606 Some text Working with stashes - continued (repetition) \u00b6 When you have done what you needed before committing the stashed changes you can reapply a stash (select branch first), using $ git stash apply which will apply the most recent stash. If you want to apply a different stash, you can name it. Example: $ git stash apply stash@{0} Discarding uncommitted changes \u00b6 If you do not want to stash your changes, but just get rid of them, you can use git clean . WARNING: This command will remove all non-tracked files in your current directory! You can safely test which files will be removed by running: $ git clean --dry-run Handling uncommitted changes - merging \u00b6 There is a checkout with merge option. Add the flag --merge (or -m ): $ git checkout --merge <branch> This will perform a three-way merge between your working tree and the new branch, with the current branch as the base. After the merge, you will be on the new branch and the merged result will be in your working tree. NOTE: As with any merge, conflicts may result and you will then have to resolve those. Merging and merge conflicts \u00b6 Merge conflicts will happen now and then when you are working with more than one branch and try to merge them. In many cases, Git is actually able to do a merge without problems. However, merge conflicts can happen. If Git cannot safely merge something automatically, you will get a message like this: error: Entry '<fileName>' would be overwritten by merge. Cannot merge. ( Changes in staging area ) NOTE: Always check that you are on the right branch before merging! You check the branch with git branch . Git can automatically try to merge when you give the command: $ git merge <branch-to-merge-into-present-branch> while standing on the branch you want to merge to. Merge strategies \u00b6 The most commonly used Fast Forward Merge the commit history is one straight line. You create a branch, you make some commits there, but no changes to the \u2018master\u2019. You then just merge onto the \u2018master\u2019. This just moves the pointer for the \u2018master\u2019 branch forward in a straight line. Recursive Merge (until 2.32) make a branch and make some commits there, but also make new commits that are made on another branch, like the \u2018master\u2018. Then, when you want to merge, git will recurse over the branch and create a new merge commit. The merge commit will continue to have two parents. ORT (from git-2.33) acronym for \u201cOstensibly Recursive\u2019s Twin\u201d replacement for the previous default algorithm, recursive. This is the default merge strategy when pulling or merging one branch. Results in fewer merge conflicts without causing mismerges Merge conflicts, example \u00b6 Let\u2019s create a merge conflict: $ mkdir merge-test $ cd merge-test/ $ git init $ echo \"Initial content\" > myfile.txt $ git add myfile.txt $ git commit -m \"first commit\" $ git checkout -b feature_1 $ echo \"Feature 1 is a good implementation\" >> myfile.txt $ git commit -a -m \"start work on feature 1\" $ git checkout master $ echo \"Working on a really cool feature\" >> myfile.txt $ git commit -a -m \"start work on a cool feature\" We now have two branches, master and feature_1 : $ git log --all --graph --decorate --oneline * d8e6809 ( HEAD -> master ) start work on a cool feature | * 87934eb ( feature_1 ) start work on feature 1 | / * ce7e46c first commit What are the contents of myfile.txt in the two branches? $ git diff master feature_1 -- myfile.txt diff --git a/myfile.txt b/myfile.txt index b14ae98..5390ea7 100644 --- a/myfile.txt +++ b/myfile.txt @@ -1,2 +1,2 @@ Initial content -Working on a really cool feature +Feature 1 is a good implementation Or use the git show : command: $ git show master:myfile.txt Initial content Working on a really cool feature $ git show feature_1:myfile.txt Initial content Feature 1 is a good implementation Let\u2019s try to merge the feature_1 branch on to the master branch: $ $ git merge feature_1 Auto-merging myfile.txt CONFLICT ( content ) : Merge conflict in myfile.txt Automatic merge failed ; fix conflicts and then commit the result. The merge failed due to a conflict. In this case, the conflict arises because there are changes in the same line on both branches. We can get some more information with the git status command: $ git status On branch master You have unmerged paths. ( fix conflicts and run \"git commit\" ) ( use \"git merge --abort\" to abort the merge ) Unmerged paths: ( use \"git add <file>...\" to mark resolution ) both modified: myfile.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Let\u2019s check the file that lead to the conflict, note the \u201cconflict dividers\u201d: $ cat myfile.txt Initial content <<<<<< < HEAD Working on a really cool feature ======= Feature 1 is a good implementation >>>>>>> feature_1 One can abort the merge with git merge \u2013abort . Or one may try to solve the conflict.. Resolving merge conflicts \u00b6 The most direct way to resolve the conflict is to edit the file yourself and stage it. When this has been done, you can attempt the merge again with: $ git merge --continue Helpful commands: - identify conflicting files: git status list the conflicting commits among the branches: git log --merge find differences between the commits involved in the merge: git diff reset conflicted files to a known good state: git reset If you made a mistake when you resolved a conflict and have completed the merge before realizing, you can roll back to the commit before the merge was done with the command git reset --hard . Workflow - merge goes well \u00b6 Work on files Stage files Commit files Then do $ git merge <branch> Success! Workflow - merge goes badly \u00b6 Work on files Stage files Commit files Then do $ git merge <branch> CONFLICT! Fix problems Stage files Attempt the merge again: $ git merge --continue Success! Rebasing \u00b6 Rebasing is the process of moving or combining a sequence of commits to a new base commit. It solves the same problem as git merge. The commands are both used to integrate changes from one branch into another branch, however the way they do it is very different. When you do a rebase, all the changes will be compressed together in a single \u201cpatch\u201d which is then \u201capplied\u201d - rebasing creates new commits on the other branch for each commit in the original branch. Rebasing - illustration \u00b6 Branch \u2018bugfix\u2019 was branched from \u2018master\u2019 graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff bugfix[\"bugfix\"] style bugfix fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) master -.-> commit4 commit4 --> commit3 commit3 --> commit2 head -.-> bugfix bugfix -.-> commitY commitY --> commitX commitX --> commit2 commit2 --> commit1 Rebasing \u2018bugfix\u2019 onto the \u2018master\u2019 branch graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) commitXp([\"commitX'\"]) commitYp([\"commitY'\"]) head -.-> master master -.-> commitYp commitYp --> commitXp commitXp --> commit4 commit4 --> commit3 commit3 --> commit2 commit2 --> commit1 Rebasing - continued \u00b6 Assume a master branch and the branch \u201ccool-features\u201d and that you want to rebase the branch \u201ccool-features\u201d onto the master branch: $ git checkout cool-features $ git rebase master This works by going to the common ancestor of the two branches getting the diff introduced by each commit of the branch you are on saving those diffs to temporary files resetting the current branch to the same commit as the branch you are rebasing onto apply each change in turn Cherry-picking \u00b6 Basically, cherry-picking in Git means that you choose a commit from one branch that you apply to another. Find the hash for the commit you want to apply, using git log . Then make sure you are on the right branch that you want to apply the commit to: $ git checkout <branch> Now you execute the cherry-picking: $ git cherry-pick <hash> Cherry-picking \u2014 illustration \u00b6 Let\u2019s assume we have: graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff feature[\"feature\"] style feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) commitZ([\"commitZ\"]) head -.-> master master -.-> commit3 commit3 --> commit2 feature -.-> commitZ commitZ --> commitY commitY --> commitX commitX --> commit2 commit2 --> commit1 Applying the commit Y to master with git cherry-pick <hash> will result in a new commit Y\u00b4. graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff feature[\"feature\"] style feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) commitYp([\"commitY'\"]) commitZ([\"commitZ\"]) head -.-> master master -.-> commitYp commitYp --> commit3 commit3 --> commit2 feature -.-> commitZ commitZ --> commitY commitY --> commitX commitX --> commit2 commit2 --> commit1 Take aways \u00b6 create or parse branch - git branch switch branch - git checkout or git switch merge branches - git merge rebase branch - rebase - like merge but end result is just one branch Conflict? - commit or stash or discard ( clean ) the changes before switching branch or do a checkout --merge . Workflow merge - Work on files - Stage and commit files - Then do: git merge <branch> Conflict? - Fix problems - Stage modifications - Then do: git merge --continue Exercises \u00b6 Each of the exercises has a README.md file with explanations and descriptions of what to do. You can find all of them in the subdirectory 5.branches. You should do them in the below order: Fast-forward Merge (OK): This exercise will show an example where git can do a fast-forward merge. The exercise is in the subdirectory \u201c1.merge-ok\u201d Recursive/ORT Merge (OK): In this exercise you will see an example where git can automatically merge two branches. This time git will use the recursive merge. The exercise can be found in the subdirectory \u201c2.merge-ok-recursive\u201d Exercises \u00b6 Merge (BAD): This exercise gives an example of a merge that cannot be done automatically with the merge command. The exercise can be found in the subdirectory \u201c3.merge-bad\u201d Rebasing (OK): In this exercise you will try the command rebase and see that it succeeds. The exercise can be found in the subdirectory \u201c4.rebase-ok\u201d Rebasing (BAD): This exercise again gives an example of rebasing two branches, but in this case the rebase fails. The exercise can be found in the subdirectory \u201c5.rebase-bad\u201d","title":"Branches, merges, and conflicts"},{"location":"branches/#lecture__5__branches","text":"","title":"Lecture 5: Branches"},{"location":"branches/#objectives","text":"Get some more hands-on working with branches creation switching merging deletion handling uncommitted changes stashing discarding checkout with merge merging and merge conflicts rebasing: combining a sequence of commits to a new base commit. cherry-picking","title":"Objectives"},{"location":"branches/#what__is__a__git__branch","text":"A pointer to a commit (ref: named pointer) Defined as all points reachable in the commit graph from the named commit (the \u201ctip\u201d of the branch) The ref HEAD determines what branch you are on. If HEAD is a symbolic ref for an existing branch, then you are \u201con\u201d that branch. If HEAD is a simple ref directly naming a commit by its SHA-1 ID, you are not \u201con\u201d any branch - you are in \u201cdetached HEAD\u201d mode, which happens when you check out some earlier commit to examine.","title":"What is a Git branch?"},{"location":"branches/#why__use__branches","text":"There are many uses for branches: Test different directions for a project Several projects members would like to work on their own copy of the code Bug fixes that are not yet tested, but will later be merged into the main version","title":"Why use branches?"},{"location":"branches/#what__is__a__git__branch_1","text":"Until now, we have worked with a repository that only have one branch, with the commits done one at a time: In the above picture, the master branch points to a commit. The current position is HEAD. (Time goes rightwards)","title":"What is a Git branch?"},{"location":"branches/#what__is__a__git__branch__-__basic__concepts","text":"Now we want to look at repositories with several branches: Branches are used to create another line of development. They are \u201cindividual projects\u201d within a git repository. The branch is the commit and all its parent commits, not just the one we are currently pointing at. The main line of development is usually called the \u201cmaster\u201d branch. Different branches within a repository can have completely different files and folders almost everything the same except for a few lines of code in a file Usually, a branch is created to work on a new feature. Once the feature is completed, it is merged back with the master branch.","title":"What is a Git branch - basic concepts"},{"location":"branches/#branches__creation","text":"Creating a new branch does not change the repository, it just adds a new reference to the commit. Note that the branch is created from the current HEAD. To create a new branch (called cool-feature in the following): $ git branch cool-feature To move to another branch (switch): $ git checkout cool-feature or\u2026 $ git switch cool-feature If you wish to switch to a new branch that is not yet created, you can do so by adding the flag -b to git checkout . To see which branch you are on: $ git branch","title":"Branches: Creation"},{"location":"branches/#branches__merging__deletion","text":"When you have decided you are happy with the changes you made to the new branch, merge it back to the master branch (or another branch) Note: The branch is always merged to the current HEAD. First switch to the branch you are merging it to: $ git checkout master Then merge them: $ git merge cool-feature You can now delete the extra branch: $ git branch -d cool-feature","title":"Branches: merging, deletion"},{"location":"branches/#example__-__type__along__if__you__wish","text":"Create a directory. Initialize a repository Create a file, stage it, and commit it $ mkdir my-project ; cd my-project/ $ git init Initialized empty Git repository in /home/bbrydsoe/my-project/.git/ $ touch file.txt $ git add file.txt $ git commit -m \"Committing the first file\" [ master ( root-commit ) 1006b51 ] Committing the first file 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 file.txt Create a new branch, then switch to that branch Make some changes - add files and text ( > overwrites or are suitable for new file) Stage the file and commit it $ git branch cool-feature $ git checkout cool-feature Switched to branch 'cool-feature' $ echo \"This is a text\" > file.txt $ git add file.txt $ git commit -m \"Added text to the first file\" [ cool-feature 5bad966 ] Added text to the first file 1 file changed, 1 insertion ( + ) Switch back to the master branch, make some changes $ git checkout master Switched to branch 'master' $ echo \"Text to the second file\" > second-file.txt $ git add second-file.txt $ git commit -m \"Added a second file\" [ master bdec2cf ] Added a second file 1 file changed, 1 insertion ( + ) create mode 100644 second-file.txt We should check the effect of the changes. I will use this command: $ git log --graph --oneline --decorate --all or, if you made an alias before. $ git graph Otherwise make the alias: $ git config --global alias.graph \"log --all --graph --decorate --oneline\" This is on the master branch $ git graph * bdec2cf ( HEAD -> master ) Added a second file | * 5bad966 ( cool-feature ) Added text to the first file | / * 1006b51 Committing the first file We now merge the branches and check again $ git merge cool-feature Merge made by the 'recursive' strategy. file.txt | 1 + 1 file changed, 1 insertion ( + ) Note that in recent git versions (>=2.33) the default \u201crecursive\u201d strategy is replaced by the \u201cort\u201d strategy. $ git graph * cf3e6b7 ( HEAD -> master ) Merge branch 'cool-feature' | \\ | * 5bad966 ( cool-feature ) Added text to the first file * | bdec2cf Added a second file | / * 1006b51 Committing the first file Now we can delete the new branch we had created, since all the content is now in the master branch. $ git branch -d cool-feature Deleted branch cool-feature ( was 5bad966 ) . Comment: It is good practice to keep old branches for understanding of the development. Deletion could however be done for very evident mistakes or insignificant issues. In a somewhat nicer format, it looks like this: We commit stuff to both branches graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff cool-feature[\"cool-feature\"] style cool-feature fill:#ffffff,stroke:#ffffff commitX([\"commitX\"]) commit1([\"commit1\"]) commit2([\"commit2\"]) commitY([\"commitY\"]) commit3([\"commit3\"]) master -.-> commit3 commit3 --> commit2 commit2 --> commit1 cool-feature -.-> commitY commitY --> commitX commitX --> commit1 (Time goes leftwards) Merge \u2018cool-feature\u2019 to \u2018master\u2019 (3-way merge) 3-way merges use a dedicated commit for connecting the two merge histories. The name comes from the fact that Git uses three commits to generate the merge commit: the two branch tips and their common ancestor. graph LR commit4Y([\"New merge commit\"]) master[\"master\"] style master fill:#ffffff,stroke:#ffffff cool-feature[\"cool-feature\"] style cool-feature fill:#ffffff,stroke:#ffffff commitX([\"commitX\"]) commit1([\"commit1\"]) commit2([\"commit2\"]) commitY([\"commitY\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) master -.-> commit4Y commit4 --> commit3 commit4Y --> commit4 cool-feature -.-> commitY commit3 --> commit2 commit2 --> commit1 commitY --> commitX commit4Y --> commitY commitX --> commit1 Delete \u2018cool-feature\u2019 graph LR commit4Y([\"New merge commit\"]) master[\"master\"] style master fill:#ffffff,stroke:#ffffff commitX([\"commitX\"]) commit1([\"commit1\"]) commit2([\"commit2\"]) commitY([\"commitY\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) master -.-> commit4Y commit4 --> commit3 commit4Y --> commit4 commit3 --> commit2 commit2 --> commit1 commitY --> commitX commit4Y --> commitY commitX --> commit1 (Time goes leftwards)","title":"Example - Type along if you wish"},{"location":"branches/#example__fast-forward__merging","text":"If there is a linear path from the current branch tip and to the target branch, then it is possible to do a fast-forward merge. Git is not really merging the branches, just integrating the histories, i.e. it moves \u201cfast forward\u201d the current branch tip up to the target branch tip. When doing so the commit histories are combined and all commit histories can be reached from the current tip. An example would be to do a fast-forward merge of a feature into master/main. A fast-forward merge is not possible if the branches have diverged, like in the previous example. This means that there is no linear path to the target branch and Git has to combine them via a 3-way merge. This shows an example where a fast-forward merge would work. Before FF merge: graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff nice-feature[\"nice-feature\"] style nice-feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) master -.-> commit3 nice-feature -.-> commitY commit1 --> commit2 commit2 --> commit3 commit3 --> commitX commitX --> commitY After FF merge: graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff nice-feature[\"nice-feature\"] style nice-feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) master -.-> commitY nice-feature -.-> commitY commit1 --> commit2 commit2 --> commit3 commit3 --> commitX commitX --> commitY","title":"Example, fast-forward merging"},{"location":"branches/#switching__with__uncommitted__changes","text":"As mentioned above, you switch between branches with: $ git checkout <branch> What happens if you have uncommitted changes (and/or new files added) when you try to switch? The uncommitted changes will be carried to the new branch that you switch to, if possible. Changes that you commit will be committed to the newly switched branch. What if there is a conflict? - You will not be allowed to switch to the other branch. - You must commit or stash any conflicting changes before switching branches.","title":"Switching with uncommitted changes"},{"location":"branches/#example__-__new__file","text":"Here we create a new branch, switch to it, then add a new file. Then we switch back to the master branch without committing the changes: $ git checkout -b cool-feature Switched to a new branch 'cool-feature' $ touch newfile.txt $ git add newfile.txt $ git checkout master A newfile.txt Switched to branch 'master' Git warns that there is a file added ( A ) in one branch but not the other, but the switch is allowed.","title":"Example - new file"},{"location":"branches/#example__-__modified__file","text":"We continue in the same repository! First commit the newfile.txt in the cool-feature branch to clean the environment. If we make changes to the file in one of the branches (go back to cool-feature ) but not on the other and do not commit it, then git will again warn: $ git switch cool-feature $ git commit -m \"newfile.txt\" $ echo \"Adding some text\" >> second-file.txt $ git add second-file.txt $ git checkout master M second-file.txt Switched to branch 'master' Git warns that there is a file that is modified ( M ) in one branch but not the other, but the switch is allowed.","title":"Example - modified file"},{"location":"branches/#example__-__uncommitted__conflicting__changes","text":"We continue in the same repository! Assume two branches, \u201ccool-feature\u201d and \u201cmorefeatures\u201d Create the branch \u201cmorefeatures\u201d without switching to it Switch to branch \u201ccool-feature\u201d, add some text to a file, stage the file and commit it: $ git branch morefeatures $ git checkout cool-feature Switched to branch 'cool-feature' $ git commit -m \"second-file.txt\" $ echo \"add text\" >> morefiles.txt $ git add morefiles.txt $ git commit -m \"Some text\" [ cool-feature 469542b ] Some text 1 file changed, 1 insertion ( + ) create mode 100644 morefiles.txt Switch to branch \u201cmorefeatures\u201d. Modify the same file, stage the file and commit it. Then try and switch back to the \u201ccool-features\u201d branch: $ git checkout morefeatures Switched to branch 'morefeatures' $ echo \"Adding yet some more text\" >> morefiles.txt $ git add morefiles.txt $ git checkout cool-feature error: Your local changes to the following files would be overwritten by checkout: morefiles.txt Please commit your changes or stash them before you switch branches. Aborting Now Git complains and do not allow the switch.","title":"Example - uncommitted, conflicting changes"},{"location":"branches/#handling__uncommitted__changes","text":"So, what can we do if there is a conflict? Commit the changes before switching branch Stash the uncommitted changes Discard the uncommitted changes Checkout with Merge","title":"Handling uncommitted changes"},{"location":"branches/#stashing","text":"The command \u201cstash\u201d can be described as a drawer where you store uncommitted changes temporarily. After stashing your uncommitted changes you can continue working on other things in a different branch. The uncommitted changes that are stored in the stash can be taken out and applied to any branch, including the original branch.","title":"Stashing"},{"location":"branches/#stashing__example__no__type-along__this__time","text":"First do a git status in the branch where you may have uncommitted changes: $ git status On branch morefeatures Changes to be committed: ( use \"git reset HEAD <file>...\" to unstage ) modified: file.txt new file: morefiles.txt You can see the dirty status. To fix it, let us use git stash : $ git stash Saved working directory and index state WIP on morefeatures: 4922606 Some text Checking again with git status : $ git status On branch morefeatures nothing to commit, working tree clean You can now switch branches and work on something else.","title":"Stashing, example (no type-along this time)"},{"location":"branches/#working__with__stashes__repetition","text":"You can have several stashes stored. To see them, use $ git stash list Example: $ git stash list stash@{0}: WIP on morefeatures: 4922606 Some text stash@{1}: WIP on morefeatures: 4922606 Some text stash@{2}: WIP on morefeatures: 4922606 Some text","title":"Working with stashes (repetition)"},{"location":"branches/#working__with__stashes__-__continued__repetition","text":"When you have done what you needed before committing the stashed changes you can reapply a stash (select branch first), using $ git stash apply which will apply the most recent stash. If you want to apply a different stash, you can name it. Example: $ git stash apply stash@{0}","title":"Working with stashes - continued (repetition)"},{"location":"branches/#discarding__uncommitted__changes","text":"If you do not want to stash your changes, but just get rid of them, you can use git clean . WARNING: This command will remove all non-tracked files in your current directory! You can safely test which files will be removed by running: $ git clean --dry-run","title":"Discarding uncommitted changes"},{"location":"branches/#handling__uncommitted__changes__-__merging","text":"There is a checkout with merge option. Add the flag --merge (or -m ): $ git checkout --merge <branch> This will perform a three-way merge between your working tree and the new branch, with the current branch as the base. After the merge, you will be on the new branch and the merged result will be in your working tree. NOTE: As with any merge, conflicts may result and you will then have to resolve those.","title":"Handling uncommitted changes - merging"},{"location":"branches/#merging__and__merge__conflicts","text":"Merge conflicts will happen now and then when you are working with more than one branch and try to merge them. In many cases, Git is actually able to do a merge without problems. However, merge conflicts can happen. If Git cannot safely merge something automatically, you will get a message like this: error: Entry '<fileName>' would be overwritten by merge. Cannot merge. ( Changes in staging area ) NOTE: Always check that you are on the right branch before merging! You check the branch with git branch . Git can automatically try to merge when you give the command: $ git merge <branch-to-merge-into-present-branch> while standing on the branch you want to merge to.","title":"Merging and merge conflicts"},{"location":"branches/#merge__strategies","text":"The most commonly used Fast Forward Merge the commit history is one straight line. You create a branch, you make some commits there, but no changes to the \u2018master\u2019. You then just merge onto the \u2018master\u2019. This just moves the pointer for the \u2018master\u2019 branch forward in a straight line. Recursive Merge (until 2.32) make a branch and make some commits there, but also make new commits that are made on another branch, like the \u2018master\u2018. Then, when you want to merge, git will recurse over the branch and create a new merge commit. The merge commit will continue to have two parents. ORT (from git-2.33) acronym for \u201cOstensibly Recursive\u2019s Twin\u201d replacement for the previous default algorithm, recursive. This is the default merge strategy when pulling or merging one branch. Results in fewer merge conflicts without causing mismerges","title":"Merge strategies"},{"location":"branches/#merge__conflicts__example","text":"Let\u2019s create a merge conflict: $ mkdir merge-test $ cd merge-test/ $ git init $ echo \"Initial content\" > myfile.txt $ git add myfile.txt $ git commit -m \"first commit\" $ git checkout -b feature_1 $ echo \"Feature 1 is a good implementation\" >> myfile.txt $ git commit -a -m \"start work on feature 1\" $ git checkout master $ echo \"Working on a really cool feature\" >> myfile.txt $ git commit -a -m \"start work on a cool feature\" We now have two branches, master and feature_1 : $ git log --all --graph --decorate --oneline * d8e6809 ( HEAD -> master ) start work on a cool feature | * 87934eb ( feature_1 ) start work on feature 1 | / * ce7e46c first commit What are the contents of myfile.txt in the two branches? $ git diff master feature_1 -- myfile.txt diff --git a/myfile.txt b/myfile.txt index b14ae98..5390ea7 100644 --- a/myfile.txt +++ b/myfile.txt @@ -1,2 +1,2 @@ Initial content -Working on a really cool feature +Feature 1 is a good implementation Or use the git show : command: $ git show master:myfile.txt Initial content Working on a really cool feature $ git show feature_1:myfile.txt Initial content Feature 1 is a good implementation Let\u2019s try to merge the feature_1 branch on to the master branch: $ $ git merge feature_1 Auto-merging myfile.txt CONFLICT ( content ) : Merge conflict in myfile.txt Automatic merge failed ; fix conflicts and then commit the result. The merge failed due to a conflict. In this case, the conflict arises because there are changes in the same line on both branches. We can get some more information with the git status command: $ git status On branch master You have unmerged paths. ( fix conflicts and run \"git commit\" ) ( use \"git merge --abort\" to abort the merge ) Unmerged paths: ( use \"git add <file>...\" to mark resolution ) both modified: myfile.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Let\u2019s check the file that lead to the conflict, note the \u201cconflict dividers\u201d: $ cat myfile.txt Initial content <<<<<< < HEAD Working on a really cool feature ======= Feature 1 is a good implementation >>>>>>> feature_1 One can abort the merge with git merge \u2013abort . Or one may try to solve the conflict..","title":"Merge conflicts, example"},{"location":"branches/#resolving__merge__conflicts","text":"The most direct way to resolve the conflict is to edit the file yourself and stage it. When this has been done, you can attempt the merge again with: $ git merge --continue Helpful commands: - identify conflicting files: git status list the conflicting commits among the branches: git log --merge find differences between the commits involved in the merge: git diff reset conflicted files to a known good state: git reset If you made a mistake when you resolved a conflict and have completed the merge before realizing, you can roll back to the commit before the merge was done with the command git reset --hard .","title":"Resolving merge conflicts"},{"location":"branches/#workflow__-__merge__goes__well","text":"Work on files Stage files Commit files Then do $ git merge <branch> Success!","title":"Workflow - merge goes well"},{"location":"branches/#workflow__-__merge__goes__badly","text":"Work on files Stage files Commit files Then do $ git merge <branch> CONFLICT! Fix problems Stage files Attempt the merge again: $ git merge --continue Success!","title":"Workflow - merge goes badly"},{"location":"branches/#rebasing","text":"Rebasing is the process of moving or combining a sequence of commits to a new base commit. It solves the same problem as git merge. The commands are both used to integrate changes from one branch into another branch, however the way they do it is very different. When you do a rebase, all the changes will be compressed together in a single \u201cpatch\u201d which is then \u201capplied\u201d - rebasing creates new commits on the other branch for each commit in the original branch.","title":"Rebasing"},{"location":"branches/#rebasing__-__illustration","text":"Branch \u2018bugfix\u2019 was branched from \u2018master\u2019 graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff bugfix[\"bugfix\"] style bugfix fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) master -.-> commit4 commit4 --> commit3 commit3 --> commit2 head -.-> bugfix bugfix -.-> commitY commitY --> commitX commitX --> commit2 commit2 --> commit1 Rebasing \u2018bugfix\u2019 onto the \u2018master\u2019 branch graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commit4([\"commit4\"]) commitXp([\"commitX'\"]) commitYp([\"commitY'\"]) head -.-> master master -.-> commitYp commitYp --> commitXp commitXp --> commit4 commit4 --> commit3 commit3 --> commit2 commit2 --> commit1","title":"Rebasing - illustration"},{"location":"branches/#rebasing__-__continued","text":"Assume a master branch and the branch \u201ccool-features\u201d and that you want to rebase the branch \u201ccool-features\u201d onto the master branch: $ git checkout cool-features $ git rebase master This works by going to the common ancestor of the two branches getting the diff introduced by each commit of the branch you are on saving those diffs to temporary files resetting the current branch to the same commit as the branch you are rebasing onto apply each change in turn","title":"Rebasing - continued"},{"location":"branches/#cherry-picking","text":"Basically, cherry-picking in Git means that you choose a commit from one branch that you apply to another. Find the hash for the commit you want to apply, using git log . Then make sure you are on the right branch that you want to apply the commit to: $ git checkout <branch> Now you execute the cherry-picking: $ git cherry-pick <hash>","title":"Cherry-picking"},{"location":"branches/#cherry-picking__illustration","text":"Let\u2019s assume we have: graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff feature[\"feature\"] style feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) commitZ([\"commitZ\"]) head -.-> master master -.-> commit3 commit3 --> commit2 feature -.-> commitZ commitZ --> commitY commitY --> commitX commitX --> commit2 commit2 --> commit1 Applying the commit Y to master with git cherry-pick <hash> will result in a new commit Y\u00b4. graph LR master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff feature[\"feature\"] style feature fill:#ffffff,stroke:#ffffff commit1([\"commit1\"]) commit2([\"commit2\"]) commit3([\"commit3\"]) commitX([\"commitX\"]) commitY([\"commitY\"]) commitYp([\"commitY'\"]) commitZ([\"commitZ\"]) head -.-> master master -.-> commitYp commitYp --> commit3 commit3 --> commit2 feature -.-> commitZ commitZ --> commitY commitY --> commitX commitX --> commit2 commit2 --> commit1","title":"Cherry-picking \u2014 illustration"},{"location":"branches/#take__aways","text":"create or parse branch - git branch switch branch - git checkout or git switch merge branches - git merge rebase branch - rebase - like merge but end result is just one branch Conflict? - commit or stash or discard ( clean ) the changes before switching branch or do a checkout --merge . Workflow merge - Work on files - Stage and commit files - Then do: git merge <branch> Conflict? - Fix problems - Stage modifications - Then do: git merge --continue","title":"Take aways"},{"location":"branches/#exercises","text":"Each of the exercises has a README.md file with explanations and descriptions of what to do. You can find all of them in the subdirectory 5.branches. You should do them in the below order: Fast-forward Merge (OK): This exercise will show an example where git can do a fast-forward merge. The exercise is in the subdirectory \u201c1.merge-ok\u201d Recursive/ORT Merge (OK): In this exercise you will see an example where git can automatically merge two branches. This time git will use the recursive merge. The exercise can be found in the subdirectory \u201c2.merge-ok-recursive\u201d","title":"Exercises"},{"location":"branches/#exercises_1","text":"Merge (BAD): This exercise gives an example of a merge that cannot be done automatically with the merge command. The exercise can be found in the subdirectory \u201c3.merge-bad\u201d Rebasing (OK): In this exercise you will try the command rebase and see that it succeeds. The exercise can be found in the subdirectory \u201c4.rebase-ok\u201d Rebasing (BAD): This exercise again gives an example of rebasing two branches, but in this case the rebase fails. The exercise can be found in the subdirectory \u201c5.rebase-bad\u201d","title":"Exercises"},{"location":"commits-exercises/","text":"Exercises - Traversing the commit tree \u00b6 In order to do these exercises, you need to download the exercises zip file. You can do that either by cloning the repository or by just getting the zip file with wget . Do ONE of the following: git clone git clone https://github.com/hpc2n/course-intro-git.git cd course-intro-git unzip git_materials.zip cd git_materials cd 4.commits Fetch with wget wget https://github.com/hpc2n/course-intro-git/raw/refs/heads/main/git_materials.zip unzip git_materials.zip cd git_materials cd 4.commits You are now in a directory with 7 subdirectories, one for each exercise. 1. Investigating the commit history \u00b6 Note The goal of this exercise is to learn to use the git log command. Found under git_materials/4.commits/1.log there is a directory named repository . Enter it and perform the following steps: Investigate the history. How many commit does the main branch contain? Can you make the output of the command cleaner? Are there any other branches? How many? What are they called? Try to filter the output so that only commits that contain the word \u201cabandon\u201d in the commit message are shown. Does the reference log contain anything interesting? Can you see where the HEAD was 6 steps ago? Hints for this exercise oneline graph reflog 2. Recovering the HEAD \u00b6 Note The goal of this exercise is to learn to identify a \u201cdetached HEAD\u201d situation and recover from it. Enter the repository/ directory under git_materials/4.commits/2.recover_head and perform the following steps: Enter the repository/ directory and check whether the HEAD is detached. If the HEAD is detached, return the HEAD back to the tip of the branch. Confirm that that the HEAD indeed points to the tip of the branch` Hints for this exercise git checkout rev-parse cat .git/something 3. Stashing uncommitted changes \u00b6 Note The goal of this exercise is to learn to checkout a different commit and stash uncommited changes, if necessary. Enter the repository/ directory under git_materials/4.commits/3.stash and perform the following steps: Identify the first commit ( This is going to be a cake recipe ). Try to checkout the commit in order to identify the initial title of the recipe. If necessary, stash the changes. What was the initial title of the recipe? Restore the HEAD and pop the changes from the stash. Confirm that the changes were applied correctly and that the stash is empty. 4. Discarding the latest commit \u00b6 Note The goal of this exercise is to learn to discard the latest commit. Enter the repository/ directory under git_materials/4.commits/4.discard and perform the following steps: Discard the latest commit. Also discard the changes in the working tree. Confirm that the commit is no longer reachable from master . Confirm that the recipe.txt no longer contains the section \u201cOther ideas and hints\u201d. Try to restore the discarded commit. (optional) 5. Amending previous commit \u00b6 Note The goal of this exercise is to learn to amend the latest commit. Enter the repository/ directory under git_materials/4.commits/5.amend` and perform the following steps: The ingredient list in the repository/recipe.txt file is missing an ingredient. Add two eggs to the ingredient list. Stage the changes and amend the previous commit ( Add remaining ingredients and directions ). Validate the operation. The log ( git log ) should contain three commits and the most recent commit ( Add remaining ingredients and directions ) should contain the new added ingredient ( git show <commit> ). 6. Revert the latest commit \u00b6 Note The goal of this exercise is to learn to revert the latest commit. Enter the repository/ directory under git_materials/4.commits/6.revert and perform the following steps: Revert the latest commit. Confirm that the commit tree indeed contains the revert commit. Confirm that the recipe.txt file no longer contains the section \u201cOther ideas and hints\u201d. 7. Proper commit workflow \u00b6 Note This exercise is meant to demonstrate the proper workflow for making multiple commits from a single set of edits . The overall goal is to make sure that each commit produces a valid revision. This type of workflow is beneficial when working with source code since each revision should both compile and function correctly. The workflow is not that beneficial with the the example below but it is used as an example only. Enter the repository/ directory git_materials/4.commits/7.workflow and perform the following steps: You can confirm ( git diff HEAD ) that the repository/recipe.txt file contains uncommitted changes. That is, the recipe have been converted to metric system. You can also confirm ( git diff --cached ) that some of these changes have been already staged. As you can probably guess, the first commit we are creating is going to convert the measurements to metric. The changes that are related to the pan size and the oven temperature (8th step the the directions) are going to be committed separately . Store the the unstaged changes to the stash: $ git stash --keep-index The --keep-index options tells Git to keep the staged changes. Otherwise Git would stash them. 4. Now, investigate the content of the repository/recipe.txt file. You can see that the 7th step in the directions contains an unconverted measurement. This means that whoever created this exercise forgot to stage this line. This would correspond to a situation where the source code does not compile or does not function correctly. 5. Pop the unstaged changes from the stash: $ git stash pop 6. Stage the 7th step in the directions and stash the unstaged changes while keeping the index. Remember to do partial staging (Lecture 2: Basic commands). Verify the repository/recipe.txt file. 7. Commit changes. 8. Pop the unstaged changes, and stage and commit changes that are related to the pan size and the oven temperature. This is going to be the second commit . Confirm that the two commits you created indeed contain the desired changes.","title":"Traversing the commit tree"},{"location":"commits-exercises/#exercises__-__traversing__the__commit__tree","text":"In order to do these exercises, you need to download the exercises zip file. You can do that either by cloning the repository or by just getting the zip file with wget . Do ONE of the following: git clone git clone https://github.com/hpc2n/course-intro-git.git cd course-intro-git unzip git_materials.zip cd git_materials cd 4.commits Fetch with wget wget https://github.com/hpc2n/course-intro-git/raw/refs/heads/main/git_materials.zip unzip git_materials.zip cd git_materials cd 4.commits You are now in a directory with 7 subdirectories, one for each exercise.","title":"Exercises - Traversing the commit tree"},{"location":"commits-exercises/#1__investigating__the__commit__history","text":"Note The goal of this exercise is to learn to use the git log command. Found under git_materials/4.commits/1.log there is a directory named repository . Enter it and perform the following steps: Investigate the history. How many commit does the main branch contain? Can you make the output of the command cleaner? Are there any other branches? How many? What are they called? Try to filter the output so that only commits that contain the word \u201cabandon\u201d in the commit message are shown. Does the reference log contain anything interesting? Can you see where the HEAD was 6 steps ago? Hints for this exercise oneline graph reflog","title":"1. Investigating the commit history"},{"location":"commits-exercises/#2__recovering__the__head","text":"Note The goal of this exercise is to learn to identify a \u201cdetached HEAD\u201d situation and recover from it. Enter the repository/ directory under git_materials/4.commits/2.recover_head and perform the following steps: Enter the repository/ directory and check whether the HEAD is detached. If the HEAD is detached, return the HEAD back to the tip of the branch. Confirm that that the HEAD indeed points to the tip of the branch` Hints for this exercise git checkout rev-parse cat .git/something","title":"2. Recovering the HEAD"},{"location":"commits-exercises/#3__stashing__uncommitted__changes","text":"Note The goal of this exercise is to learn to checkout a different commit and stash uncommited changes, if necessary. Enter the repository/ directory under git_materials/4.commits/3.stash and perform the following steps: Identify the first commit ( This is going to be a cake recipe ). Try to checkout the commit in order to identify the initial title of the recipe. If necessary, stash the changes. What was the initial title of the recipe? Restore the HEAD and pop the changes from the stash. Confirm that the changes were applied correctly and that the stash is empty.","title":"3. Stashing uncommitted changes"},{"location":"commits-exercises/#4__discarding__the__latest__commit","text":"Note The goal of this exercise is to learn to discard the latest commit. Enter the repository/ directory under git_materials/4.commits/4.discard and perform the following steps: Discard the latest commit. Also discard the changes in the working tree. Confirm that the commit is no longer reachable from master . Confirm that the recipe.txt no longer contains the section \u201cOther ideas and hints\u201d. Try to restore the discarded commit. (optional)","title":"4. Discarding the latest commit"},{"location":"commits-exercises/#5__amending__previous__commit","text":"Note The goal of this exercise is to learn to amend the latest commit. Enter the repository/ directory under git_materials/4.commits/5.amend` and perform the following steps: The ingredient list in the repository/recipe.txt file is missing an ingredient. Add two eggs to the ingredient list. Stage the changes and amend the previous commit ( Add remaining ingredients and directions ). Validate the operation. The log ( git log ) should contain three commits and the most recent commit ( Add remaining ingredients and directions ) should contain the new added ingredient ( git show <commit> ).","title":"5. Amending previous commit"},{"location":"commits-exercises/#6__revert__the__latest__commit","text":"Note The goal of this exercise is to learn to revert the latest commit. Enter the repository/ directory under git_materials/4.commits/6.revert and perform the following steps: Revert the latest commit. Confirm that the commit tree indeed contains the revert commit. Confirm that the recipe.txt file no longer contains the section \u201cOther ideas and hints\u201d.","title":"6. Revert the latest commit"},{"location":"commits-exercises/#7__proper__commit__workflow","text":"Note This exercise is meant to demonstrate the proper workflow for making multiple commits from a single set of edits . The overall goal is to make sure that each commit produces a valid revision. This type of workflow is beneficial when working with source code since each revision should both compile and function correctly. The workflow is not that beneficial with the the example below but it is used as an example only. Enter the repository/ directory git_materials/4.commits/7.workflow and perform the following steps: You can confirm ( git diff HEAD ) that the repository/recipe.txt file contains uncommitted changes. That is, the recipe have been converted to metric system. You can also confirm ( git diff --cached ) that some of these changes have been already staged. As you can probably guess, the first commit we are creating is going to convert the measurements to metric. The changes that are related to the pan size and the oven temperature (8th step the the directions) are going to be committed separately . Store the the unstaged changes to the stash: $ git stash --keep-index The --keep-index options tells Git to keep the staged changes. Otherwise Git would stash them. 4. Now, investigate the content of the repository/recipe.txt file. You can see that the 7th step in the directions contains an unconverted measurement. This means that whoever created this exercise forgot to stage this line. This would correspond to a situation where the source code does not compile or does not function correctly. 5. Pop the unstaged changes from the stash: $ git stash pop 6. Stage the 7th step in the directions and stash the unstaged changes while keeping the index. Remember to do partial staging (Lecture 2: Basic commands). Verify the repository/recipe.txt file. 7. Commit changes. 8. Pop the unstaged changes, and stage and commit changes that are related to the pan size and the oven temperature. This is going to be the second commit . Confirm that the two commits you created indeed contain the desired changes.","title":"7. Proper commit workflow"},{"location":"commits/","text":"Lecture 4: Commits \u00b6 Investigating history \u00b6 The history can be investigated with the git log command: $ git log commit 845aa0185080a80fa7ef3c.... ( HEAD -> master ) Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 14 :32:28 2020 +0200 This is the most recent commit commit d9290ba6afc2f7d62b981c.... Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 12 :06:07 2020 +0200 This is the second most recent commit commit .... Actually, git log <ref> lists commits that are reachable from <ref> <ref> defaults to HEAD For example: $ git log d9290ba6af commit d9290ba6afc2f7d62b981c3befaaeeedae4da720 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 12 :06:07 2020 +0200 This is the second most recent commit commit 17567d3b8023912978b8e39754ba612546312f90 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Tue Aug 25 09 :55:17 2020 +0200 This is the third most recent commit More about listing commits git log -n <n> <ref> lists only <n> most recent commits git log --oneline <ref> lists only the shortened hash and the commit message: $ git log --oneline 845aa01 ( HEAD -> master ) This is the most recent d9290ba This is the second most recent commit 17567d3 is the third most recent commit .... git log --format=oneline <ref> The formats include, but are not limited to, oneline , short , medium , full , fuller , email , and raw Matching regular expressions \u00b6 git log --grep=<regexp> <ref> displays commits that match a regular expression <regexp> : $ git log --grep = \"bug\" commit be88ff1bb6396bdca28e84dcba6bb639d0c9f82a Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Fri Jul 17 14 :17:14 2020 +0200 Fix a bug that caused my Saturday headaches Changes before/after date \u00b6 git log --{after,before} <date> <ref> displays changes committed after/before <date> : $ git log --after = \"The end of May\" --before = \"June 15th\" commit 50ea2854c6bf6aeb2e6683c8d505ad731f2960e2 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Thu Jun 11 13 :09:28 2020 +0200 ... commit add51b56dd0a985b8625e77e8b2b4dbfab2133b8 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Jun 3 12 :08:56 2020 +0200 List changed files \u00b6 git log --name-status <ref> display files that were changed: $ git log --name-status commit 845aa0185080a80fa7ef3c.... ( HEAD -> master ) Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 14 :32:28 2020 +0200 This is the most recent commit M file.txt D mistake.txt git log --stat <ref> displays more information git log -p <ref> displays even more information (diffs) Visualizing the tree \u00b6 When working with multible branches, --graph visualizes the commit tree and --all displays all branches: $ git log --graph --all --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit Reflog \u00b6 The git log command displays only changes that affect the commit tree Git stores extra logging information to a reference log (reflog) Gets updated when the tips of branches and other references are modified Accessed with the git reflog command Some of the information can be merged with a regular log ( git log -g <ref> ) Discarding a commit \u00b6 Let\u2019s create and discard a commit (more on this later): $ echo \"More content to this file\" >> file.txt $ git commit -a -m \"I am going to delete this\" [ master 2f529ae ] I am going to delete this 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) $ git log --oneline 2f529ae ( HEAD -> master ) I am going to delete this 23b3ed5 This is the first commit $ git reset --hard HEAD~ HEAD is now at 23b3ed5 This is the first commit Note how the commit disappears from the log: $ git log --oneline 23b3ed5 ( HEAD -> master ) This is the first commit However, the commit ( 2f529ae ) still exists in the reference log: $ git reflog 23b3ed5 ( HEAD -> master ) HEAD@ { 0 } : reset: moving to HEAD~ 2f529ae HEAD@ { 1 } : commit: I am going to delete this 23b3ed5 ( HEAD -> master ) HEAD@ { 2 } : commit ( initial ) : This is the first commit At this point, we could attempt to recover the commit. Note that Git is allowed to delete any orphan commits. Comparing commits \u00b6 We can compare commits with git diff : $ git log --oneline --graph --all * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit $ git diff 23b3ed5 d3c6c63 diff --git a/file.txt b/file.txt index 09c78e6..3b23ff0 100644 --- a/file.txt +++ b/file.txt @@ -1 +1,2 @@ This file is very interesting +More content Investigate a file \u00b6 We can also investigate an individual file: $ git diff 23b3ed5 d3c6c63 -- file.txt diff --git a/file.txt b/file.txt index 09c78e6..3b23ff0 100644 --- a/file.txt +++ b/file.txt @@ -1 +1,2 @@ This file is very interesting +More content List uncommitted changed \u00b6 We can list all uncommited changes by comparing against HEAD : $ git diff HEAD We can list all unstaged changes with command: $ git diff We can list all staged changes with command: $ git diff --cached Navigating the commit tree \u00b6 In order to use the commits stored by Git, we must be able to navigate the commit tree This happens with the git checkout and git reset commands The commands behave slightly differently! Let\u2019s investigate the commit tree. We are currently at master : $ git log --graph --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit We use git checkout to move to d3c6c63 : $ git checkout d3c6c63 .... HEAD is now at d3c6c63 This is the second commit $ git log --graph --oneline * d3c6c63 ( HEAD ) This is the second commit * 23b3ed5 ( tag: first ) This is the first commit git checkout moves only the HEAD , the tip of the branch is not modified: $ git log --graph --oneline master * f0d7298 ( master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 ( HEAD ) This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit git checkout attempts to keep local modifications to the files in the working tree Detached HEAD \u00b6 If we git checkout away from the tip of a branch\u2026 graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff B --> A C --> B master -.-> C head -.-> C Then we will get the following warning: $ git checkout d3c6c63 Note: switching to 'd3c6c63' . You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. .... This simply means that the HEAD no longer points to the tip of the branch: graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff B --> A C --> B master -.-> C head -.-> B We can disable the warning: $ git config --global advice.detachedHead false If we are currently on the tip of a branch, then: $ git log -n 1 --oneline f0d7298 ( HEAD -> master ) Merge branch 'second_branch' $ git rev-parse --abbrev-ref HEAD master $ cat .git/HEAD ref: refs/heads/master If we are in the detached HEAD mode, then: $ git log -n 1 --oneline d3c6c63 ( HEAD ) This is the second commit $ git rev-parse --abbrev-ref HEAD HEAD $ cat .git/HEAD d3c6c635fb44c7084797d47050bff7961853c19b The tip of the branch can be recovered with git checkout <tip_ref> : $ git checkout master Previous HEAD position was 23b3ed5 This is the first commit Switched to branch 'master' Git reset \u00b6 We could have also used git reset to move the HEAD : $ git reset <option> <ref> The option defines what gets updated / cleared: <option> Tree Index HEAD Comment --soft X --mixed X X Default --hard X X X The command can be dangerous ! If you are in the detached HEAD mode, then only the HEAD gets moved: graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> C head -.-> A old_head -.-> B linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Otherwise, also the branch tip gets moved : graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae old_master[\"master\"] style old_master fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> A head -.-> master old_head -.-> old_master linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; old_master -.-> C linkStyle 5 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Applying git checkout to a file discards all unstaged changes made to the file: $ git checkout <filename> - Applying git reset to a file unstages the file : $ git reset <filename> An example: $ echo \"Even more content\" >> file.txt $ git add file.txt $ git diff --cached .... +Even more content $ git reset file.txt $ git diff --cached $ git diff .... +Even more content $ git checkout file.txt Updated 1 path from the index $ git diff $ git restore \u00b6 from git version 2.23, under development discard all unstaged changes made to files: $ git restore <filename> unstage files: $ git restore --staged <filename> advantage: does not change the HEAD Tagging \u00b6 We can give a commit a special name (tag). All existing tags can be listed with: $ git tag v0.1.0 v0.1.1 .... We can also search for a tag that matches a given string: $ git tag -l \"*beta*\" v0.1-beta.1 v0.1-beta.2 .... In the simplest case, we can create a lightweight tag: $ git tag <tag_name> The created tag always points to the current HEAD . You an also create an annotated tag: $ git tag -a <tag_name> -m <comment> An annotated tag stores extra information such as the tag\u2019s creator, the creation time and a comment. Referring to commits \u00b6 We can refer to commits in many different ways: Hash (commit id): d3c6c635fb44c7.... References, branches, tags: HEAD , master , first , etc Long names: refs/heads/master , refs/tags/first We can also refer to the ancestors of a commit: $ git log --graph --all --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit $ git rev-parse --short HEAD f0d7298 $ git rev-parse --short HEAD~ d3c6c63 $ git rev-parse --short HEAD~~ 23b3ed5 ref~n returns the n \u2018th ancestor of ref . ref = ref~0 ref~ = ref~1 ref~~ = ref~2 \u2026 Always follows the first parent We can also refer to the parents of a commit: $ git log --graph --all --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit $ git rev-parse --short HEAD^1 d3c6c63 $ git rev-parse --short HEAD^2 a118ae8 ref^n returns the n \u2018th parent of ref . ref = ref^0 ref^ = ref^1 ref^ = ref~ Note that ref^^ != ref^2 : graph LR ref([\"ref\"]) --> refhat([\"ref^\"]) ref([\"ref\"]) --> refhat2([\"ref^2\"]) refhat([\"ref^\"]) --> refhathat([\"ref^^\"]) Cleaning the working tree \u00b6 Cleaning tracked files (recap) \u00b6 discard all unstaged changes made to files: $ git checkout <filename> $ git restore <filename> unstage files: $ git reset <filename> $ git restore --staged <filename> git reset <option> <ref> <option> Tree Index HEAD Comment --soft X Cleans nothing --mixed X X Default --hard X X X Untracked files, clearing \u00b6 Untracked files are cleared with $ git clean <options> <path> Option Description --dry-run nothing is cleaned -d clean more files recursively -i clean interactively -f needed if -i is not given -x clean also ignored files -X clean only ignored files Usually we first check what is going to be cleaned: $ git clean --dry-run -dfx If everything looks good, we will clean the files: $ git clean -dfx Stashing changes \u00b6 We sometimes find ourselves in a situation where we want to temporarily store the changes of the working tree. This might happen, for example, when we are attempting to move the HEAD . Git cannot always restore the working tree. We can store these changes to the stash . Let\u2019s try to move the HEAD to 1cb12030 : $ git checkout 1cb12030 error: Your local changes to the following files would be overwritten by checkout: README.md Please commit your changes or stash them before you switch branches. Aborting We can simply stash the changes after which the checkout is successful: $ git stash Saved working directory and index state WIP on master: 845aa01 Test: Use STARNEIG_USE_ALL $ git checkout 1cb12030 .... HEAD is now at 1cb1203 Use LANGUAGES argument in project We can display the content of the entire stash: $ git stash list stash@ { 0 } : WIP on master: 845aa01 Test: Use STARNEIG_USE_ALL stash@ { 1 } : WIP on devel: 1a34e4a Fix pkg-config file stash@ { 2 } : WIP on gh-pages: 1d8aab9 Add figures stash@ { 3 } : WIP on v0.1-devel: 70d21d8 Add shift_origin parameter The entries are numbered. Each row contains: the stash id, the name of the corresponding branch, the commit hash, and the matching commit message. We can also display the content of an individual stash entry: $ git stash show 0 README.md | 2 +- 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) $ git stash show -p 0 diff --git a/README.md b/README.md index 942e9f4..8dbf1f6 100644 --- a/README.md +++ b/README.md @@ -1,4 +1,4 @@ -# Introduction +# Introduction to the software .... Apply previous entry from stack \u00b6 We can pop the previous entry from the stash and apply it to the working tree: $ git stash pop On branch master Your branch is up to date with 'origin/master' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: README.md no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Dropped refs/stash@ { 0 } ( a3dd9b60b18c2.... ) The stashed changes are applied to the working tree and the entry is dropped Apply any entry from the stack \u00b6 We can also apply any entry from the stash (does not drop the entry): $ git stash apply <stash_id> git stash stashes files that are already added to the index . This behaviour can be overwritten with the --keep-index option. Multiple commits from a single set of edits \u00b6 Imagine the following situation: You have spent 3 days coding and are finally ready to commit your changes. You wish to divide the changes into several self-contained commits. Each commit should both compile and function correctly How would you do this? Do the following for each commit you want to create: Stage changes that should go to the commit. Stash unstaged changes but keep the index ( --keep-index ). Compile and test your code. 4a. If your code functions as intended, commit, pop stash and move to the next commit. 4b. Otherwise, pop the stash and continue from step #1. Making changes to the commit tree \u00b6 Remark \u00b6 The following techniques should be used with caution! It is generally a bad idea to modify the commit tree if the changes have been pushed to a remote. We will return to this during Lecture 6. Reminder \u00b6 If you are in the detached HEAD mode, then git reset moves only the HEAD : graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> C head -.-> A old_head -.-> B linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Otherwise, also the branch tip gets moved : graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae old_master[\"master\"] style old_master fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> A head -.-> master old_head -.-> old_master linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; old_master -.-> C linkStyle 5 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Discarding the last commit \u00b6 If we are not in the detached HEAD mode, then we can discard the latest commit with the git reset command: $ git reset HEAD~ Unstaged changes after reset: M file.txt git reset defaults to git reset --mixed => the state of the working tree is kept . If we are lucky, we can still recover the commit: $ git reset f0d7298983 We can try again and also discard the working tree : $ git reset --hard HEAD~ HEAD is now at d3c6c63 This is the second commit Changing the last commit \u00b6 Imagine a situation where you have just committed your changes and then realized that you have made a mistake . graph LR index([\"index\"]) A([\"A\"]) C([\"C\"]) B([\"B\"]) C --> B B --> A head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff head --> C amistake[\"mistake\"] style amistake fill:#ffffff,stroke:#ffffff amistake -.-> C file2[\"modified: program.py\"] style file2 fill:#ffffff,stroke:#ffffff,color:#ff0000 C -.-> file2 Forgotten file, incorrect commit message, etc The problem can be fixed easily in two steps: Step #1 is to stage the forgotten changes: $ git add file.txt $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) modified: file.txt graph LR index([\"index\"]) file3[\"modified: file.txt\"] style file3 fill:#ffffff,stroke:#ffffff,color:#ff0000 index -.-> file3 A([\"A\"]) C([\"C\"]) B([\"B\"]) C --> B B --> A head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff head --> C amistake[\"mistake\"] style amistake fill:#ffffff,stroke:#ffffff amistake -.-> C file2[\"modified: program.py\"] style file2 fill:#ffffff,stroke:#ffffff,color:#ff0000 C -.-> file2 Step #2 is to replace the current HEAD with a corrected commit: $ git commit --amend The amend command first removes the HEAD commit from the commit tree and combines it with the current index: graph LR index([\"index\"]) file3[\"modified: file.txt program.py\"] style file3 fill:#ffffff,stroke:#ffffff,color:#ff0000 index -.-> file3 A([\"A\"]) B([\"B\"]) B --> A head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff head --> B It then creates a new commit from the combined index: graph LR index([\"index\"]) A([\"A\"]) C([\"C*\"]) B([\"B\"]) C --> B B --> A corr[\"corrected\"] style corr fill:#ffffff,stroke:#ffffff corr --> C file2[\"modified: file.txt program.py\"] style file2 fill:#ffffff,stroke:#ffffff,color:#ff0000 C -.-> file2 git commit --amend is equivalent to: $ git reset --soft HEAD^ $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) modified: file.txt modified: program.py $ git commit -c ORIG_HEAD git revert \u00b6 We are first going to create a commit that replaces the content of a file: $ echo \"This file is not that interesting\" > file.txt $ git commit -a -m \"Bad commit\" [ master 465a5a4 ] Bad commit 1 file changed, 1 insertion ( + ) , 3 deletions ( - ) $ git log --oneline --graph --all * 465a5a4 ( HEAD -> master ) Bad commit * f0d7298 Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit We later discover that the commit was a mistake and revert it: $ git revert 465a5a4 [ master 173e959 ] Revert \"Bad commit\" 1 file changed, 3 insertions ( + ) , 1 deletion ( - ) $ git log --oneline --graph --all * 173e959 ( HEAD -> master ) Revert \"Bad commit\" * 465a5a4 Bad commit * f0d7298 Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit We can see that the revert commit simply removes the changes made in the first commit and restores changes make in the preceding commit: $ git show 173e959 commit 173e959ed5b0ccd9.... ( HEAD -> master ) Author: Mirko Myllykoski <mirko.myllykoski@gmail.com> Date: Tue Sep 29 19 :56:19 2020 +0200 Revert \"Bad commit\" This reverts commit 173e959ed5b0ccd9..... .... -This file is not that interesting +This file is very interesting +More content +Different content Exercises \u00b6 Exercise Description 1.log Learn how to use git log 2.recover_head Learn how to recover a detached HEAD 3.stash Learn how to use git stash 4.discard Learn how to discard commits 5.amend Learn how to amend commits 6.revert Learn how to revert commits 7.workflow Learn proper workflow","title":"Traversing the commit tree"},{"location":"commits/#lecture__4__commits","text":"","title":"Lecture 4: Commits"},{"location":"commits/#investigating__history","text":"The history can be investigated with the git log command: $ git log commit 845aa0185080a80fa7ef3c.... ( HEAD -> master ) Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 14 :32:28 2020 +0200 This is the most recent commit commit d9290ba6afc2f7d62b981c.... Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 12 :06:07 2020 +0200 This is the second most recent commit commit .... Actually, git log <ref> lists commits that are reachable from <ref> <ref> defaults to HEAD For example: $ git log d9290ba6af commit d9290ba6afc2f7d62b981c3befaaeeedae4da720 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 12 :06:07 2020 +0200 This is the second most recent commit commit 17567d3b8023912978b8e39754ba612546312f90 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Tue Aug 25 09 :55:17 2020 +0200 This is the third most recent commit More about listing commits git log -n <n> <ref> lists only <n> most recent commits git log --oneline <ref> lists only the shortened hash and the commit message: $ git log --oneline 845aa01 ( HEAD -> master ) This is the most recent d9290ba This is the second most recent commit 17567d3 is the third most recent commit .... git log --format=oneline <ref> The formats include, but are not limited to, oneline , short , medium , full , fuller , email , and raw","title":"Investigating history"},{"location":"commits/#matching__regular__expressions","text":"git log --grep=<regexp> <ref> displays commits that match a regular expression <regexp> : $ git log --grep = \"bug\" commit be88ff1bb6396bdca28e84dcba6bb639d0c9f82a Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Fri Jul 17 14 :17:14 2020 +0200 Fix a bug that caused my Saturday headaches","title":"Matching regular expressions"},{"location":"commits/#changes__beforeafter__date","text":"git log --{after,before} <date> <ref> displays changes committed after/before <date> : $ git log --after = \"The end of May\" --before = \"June 15th\" commit 50ea2854c6bf6aeb2e6683c8d505ad731f2960e2 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Thu Jun 11 13 :09:28 2020 +0200 ... commit add51b56dd0a985b8625e77e8b2b4dbfab2133b8 Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Jun 3 12 :08:56 2020 +0200","title":"Changes before/after date"},{"location":"commits/#list__changed__files","text":"git log --name-status <ref> display files that were changed: $ git log --name-status commit 845aa0185080a80fa7ef3c.... ( HEAD -> master ) Author: Mirko Myllykoski <mirkom@cs.umu.se> Date: Wed Sep 2 14 :32:28 2020 +0200 This is the most recent commit M file.txt D mistake.txt git log --stat <ref> displays more information git log -p <ref> displays even more information (diffs)","title":"List changed files"},{"location":"commits/#visualizing__the__tree","text":"When working with multible branches, --graph visualizes the commit tree and --all displays all branches: $ git log --graph --all --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit","title":"Visualizing the tree"},{"location":"commits/#reflog","text":"The git log command displays only changes that affect the commit tree Git stores extra logging information to a reference log (reflog) Gets updated when the tips of branches and other references are modified Accessed with the git reflog command Some of the information can be merged with a regular log ( git log -g <ref> )","title":"Reflog"},{"location":"commits/#comparing__commits","text":"We can compare commits with git diff : $ git log --oneline --graph --all * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit $ git diff 23b3ed5 d3c6c63 diff --git a/file.txt b/file.txt index 09c78e6..3b23ff0 100644 --- a/file.txt +++ b/file.txt @@ -1 +1,2 @@ This file is very interesting +More content","title":"Comparing commits"},{"location":"commits/#investigate__a__file","text":"We can also investigate an individual file: $ git diff 23b3ed5 d3c6c63 -- file.txt diff --git a/file.txt b/file.txt index 09c78e6..3b23ff0 100644 --- a/file.txt +++ b/file.txt @@ -1 +1,2 @@ This file is very interesting +More content","title":"Investigate a file"},{"location":"commits/#list__uncommitted__changed","text":"We can list all uncommited changes by comparing against HEAD : $ git diff HEAD We can list all unstaged changes with command: $ git diff We can list all staged changes with command: $ git diff --cached","title":"List uncommitted changed"},{"location":"commits/#navigating__the__commit__tree","text":"In order to use the commits stored by Git, we must be able to navigate the commit tree This happens with the git checkout and git reset commands The commands behave slightly differently! Let\u2019s investigate the commit tree. We are currently at master : $ git log --graph --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit We use git checkout to move to d3c6c63 : $ git checkout d3c6c63 .... HEAD is now at d3c6c63 This is the second commit $ git log --graph --oneline * d3c6c63 ( HEAD ) This is the second commit * 23b3ed5 ( tag: first ) This is the first commit git checkout moves only the HEAD , the tip of the branch is not modified: $ git log --graph --oneline master * f0d7298 ( master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 ( HEAD ) This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit git checkout attempts to keep local modifications to the files in the working tree","title":"Navigating the commit tree"},{"location":"commits/#detached__head","text":"If we git checkout away from the tip of a branch\u2026 graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff B --> A C --> B master -.-> C head -.-> C Then we will get the following warning: $ git checkout d3c6c63 Note: switching to 'd3c6c63' . You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by switching back to a branch. .... This simply means that the HEAD no longer points to the tip of the branch: graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff B --> A C --> B master -.-> C head -.-> B We can disable the warning: $ git config --global advice.detachedHead false If we are currently on the tip of a branch, then: $ git log -n 1 --oneline f0d7298 ( HEAD -> master ) Merge branch 'second_branch' $ git rev-parse --abbrev-ref HEAD master $ cat .git/HEAD ref: refs/heads/master If we are in the detached HEAD mode, then: $ git log -n 1 --oneline d3c6c63 ( HEAD ) This is the second commit $ git rev-parse --abbrev-ref HEAD HEAD $ cat .git/HEAD d3c6c635fb44c7084797d47050bff7961853c19b The tip of the branch can be recovered with git checkout <tip_ref> : $ git checkout master Previous HEAD position was 23b3ed5 This is the first commit Switched to branch 'master'","title":"Detached HEAD"},{"location":"commits/#git__reset","text":"We could have also used git reset to move the HEAD : $ git reset <option> <ref> The option defines what gets updated / cleared: <option> Tree Index HEAD Comment --soft X --mixed X X Default --hard X X X The command can be dangerous ! If you are in the detached HEAD mode, then only the HEAD gets moved: graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> C head -.-> A old_head -.-> B linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Otherwise, also the branch tip gets moved : graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae old_master[\"master\"] style old_master fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> A head -.-> master old_head -.-> old_master linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; old_master -.-> C linkStyle 5 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Applying git checkout to a file discards all unstaged changes made to the file: $ git checkout <filename> - Applying git reset to a file unstages the file : $ git reset <filename> An example: $ echo \"Even more content\" >> file.txt $ git add file.txt $ git diff --cached .... +Even more content $ git reset file.txt $ git diff --cached $ git diff .... +Even more content $ git checkout file.txt Updated 1 path from the index $ git diff $","title":"Git reset"},{"location":"commits/#git__restore","text":"from git version 2.23, under development discard all unstaged changes made to files: $ git restore <filename> unstage files: $ git restore --staged <filename> advantage: does not change the HEAD","title":"git restore"},{"location":"commits/#tagging","text":"We can give a commit a special name (tag). All existing tags can be listed with: $ git tag v0.1.0 v0.1.1 .... We can also search for a tag that matches a given string: $ git tag -l \"*beta*\" v0.1-beta.1 v0.1-beta.2 .... In the simplest case, we can create a lightweight tag: $ git tag <tag_name> The created tag always points to the current HEAD . You an also create an annotated tag: $ git tag -a <tag_name> -m <comment> An annotated tag stores extra information such as the tag\u2019s creator, the creation time and a comment.","title":"Tagging"},{"location":"commits/#referring__to__commits","text":"We can refer to commits in many different ways: Hash (commit id): d3c6c635fb44c7.... References, branches, tags: HEAD , master , first , etc Long names: refs/heads/master , refs/tags/first We can also refer to the ancestors of a commit: $ git log --graph --all --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit $ git rev-parse --short HEAD f0d7298 $ git rev-parse --short HEAD~ d3c6c63 $ git rev-parse --short HEAD~~ 23b3ed5 ref~n returns the n \u2018th ancestor of ref . ref = ref~0 ref~ = ref~1 ref~~ = ref~2 \u2026 Always follows the first parent We can also refer to the parents of a commit: $ git log --graph --all --oneline * f0d7298 ( HEAD -> master ) Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit $ git rev-parse --short HEAD^1 d3c6c63 $ git rev-parse --short HEAD^2 a118ae8 ref^n returns the n \u2018th parent of ref . ref = ref^0 ref^ = ref^1 ref^ = ref~ Note that ref^^ != ref^2 : graph LR ref([\"ref\"]) --> refhat([\"ref^\"]) ref([\"ref\"]) --> refhat2([\"ref^2\"]) refhat([\"ref^\"]) --> refhathat([\"ref^^\"])","title":"Referring to commits"},{"location":"commits/#cleaning__the__working__tree","text":"","title":"Cleaning the working tree"},{"location":"commits/#cleaning__tracked__files__recap","text":"discard all unstaged changes made to files: $ git checkout <filename> $ git restore <filename> unstage files: $ git reset <filename> $ git restore --staged <filename> git reset <option> <ref> <option> Tree Index HEAD Comment --soft X Cleans nothing --mixed X X Default --hard X X X","title":"Cleaning tracked files (recap)"},{"location":"commits/#stashing__changes","text":"We sometimes find ourselves in a situation where we want to temporarily store the changes of the working tree. This might happen, for example, when we are attempting to move the HEAD . Git cannot always restore the working tree. We can store these changes to the stash . Let\u2019s try to move the HEAD to 1cb12030 : $ git checkout 1cb12030 error: Your local changes to the following files would be overwritten by checkout: README.md Please commit your changes or stash them before you switch branches. Aborting We can simply stash the changes after which the checkout is successful: $ git stash Saved working directory and index state WIP on master: 845aa01 Test: Use STARNEIG_USE_ALL $ git checkout 1cb12030 .... HEAD is now at 1cb1203 Use LANGUAGES argument in project We can display the content of the entire stash: $ git stash list stash@ { 0 } : WIP on master: 845aa01 Test: Use STARNEIG_USE_ALL stash@ { 1 } : WIP on devel: 1a34e4a Fix pkg-config file stash@ { 2 } : WIP on gh-pages: 1d8aab9 Add figures stash@ { 3 } : WIP on v0.1-devel: 70d21d8 Add shift_origin parameter The entries are numbered. Each row contains: the stash id, the name of the corresponding branch, the commit hash, and the matching commit message. We can also display the content of an individual stash entry: $ git stash show 0 README.md | 2 +- 1 file changed, 1 insertion ( + ) , 1 deletion ( - ) $ git stash show -p 0 diff --git a/README.md b/README.md index 942e9f4..8dbf1f6 100644 --- a/README.md +++ b/README.md @@ -1,4 +1,4 @@ -# Introduction +# Introduction to the software ....","title":"Stashing changes"},{"location":"commits/#apply__previous__entry__from__stack","text":"We can pop the previous entry from the stash and apply it to the working tree: $ git stash pop On branch master Your branch is up to date with 'origin/master' . Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: README.md no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) Dropped refs/stash@ { 0 } ( a3dd9b60b18c2.... ) The stashed changes are applied to the working tree and the entry is dropped","title":"Apply previous entry from stack"},{"location":"commits/#apply__any__entry__from__the__stack","text":"We can also apply any entry from the stash (does not drop the entry): $ git stash apply <stash_id> git stash stashes files that are already added to the index . This behaviour can be overwritten with the --keep-index option.","title":"Apply any entry from the stack"},{"location":"commits/#multiple__commits__from__a__single__set__of__edits","text":"Imagine the following situation: You have spent 3 days coding and are finally ready to commit your changes. You wish to divide the changes into several self-contained commits. Each commit should both compile and function correctly How would you do this? Do the following for each commit you want to create: Stage changes that should go to the commit. Stash unstaged changes but keep the index ( --keep-index ). Compile and test your code. 4a. If your code functions as intended, commit, pop stash and move to the next commit. 4b. Otherwise, pop the stash and continue from step #1.","title":"Multiple commits from a single set of edits"},{"location":"commits/#making__changes__to__the__commit__tree","text":"","title":"Making changes to the commit tree"},{"location":"commits/#remark","text":"The following techniques should be used with caution! It is generally a bad idea to modify the commit tree if the changes have been pushed to a remote. We will return to this during Lecture 6.","title":"Remark"},{"location":"commits/#reminder","text":"If you are in the detached HEAD mode, then git reset moves only the HEAD : graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> C head -.-> A old_head -.-> B linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; Otherwise, also the branch tip gets moved : graph LR A[\"A\"] B[\"B\"] C[\"C\"] master[\"master\"] style master fill:#ffffff,stroke:#ffffff head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff old_head[\"HEAD\"] style old_head fill:#ffffff,stroke:#ffffff,color:#aeaeae old_master[\"master\"] style old_master fill:#ffffff,stroke:#ffffff,color:#aeaeae B --> A C --> B master -.-> A head -.-> master old_head -.-> old_master linkStyle 4 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3; old_master -.-> C linkStyle 5 stroke:#aeaeae,stroke-width:1px,stroke-dasharray:3;","title":"Reminder"},{"location":"commits/#discarding__the__last__commit","text":"If we are not in the detached HEAD mode, then we can discard the latest commit with the git reset command: $ git reset HEAD~ Unstaged changes after reset: M file.txt git reset defaults to git reset --mixed => the state of the working tree is kept . If we are lucky, we can still recover the commit: $ git reset f0d7298983 We can try again and also discard the working tree : $ git reset --hard HEAD~ HEAD is now at d3c6c63 This is the second commit","title":"Discarding the last commit"},{"location":"commits/#changing__the__last__commit","text":"Imagine a situation where you have just committed your changes and then realized that you have made a mistake . graph LR index([\"index\"]) A([\"A\"]) C([\"C\"]) B([\"B\"]) C --> B B --> A head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff head --> C amistake[\"mistake\"] style amistake fill:#ffffff,stroke:#ffffff amistake -.-> C file2[\"modified: program.py\"] style file2 fill:#ffffff,stroke:#ffffff,color:#ff0000 C -.-> file2 Forgotten file, incorrect commit message, etc The problem can be fixed easily in two steps: Step #1 is to stage the forgotten changes: $ git add file.txt $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) modified: file.txt graph LR index([\"index\"]) file3[\"modified: file.txt\"] style file3 fill:#ffffff,stroke:#ffffff,color:#ff0000 index -.-> file3 A([\"A\"]) C([\"C\"]) B([\"B\"]) C --> B B --> A head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff head --> C amistake[\"mistake\"] style amistake fill:#ffffff,stroke:#ffffff amistake -.-> C file2[\"modified: program.py\"] style file2 fill:#ffffff,stroke:#ffffff,color:#ff0000 C -.-> file2 Step #2 is to replace the current HEAD with a corrected commit: $ git commit --amend The amend command first removes the HEAD commit from the commit tree and combines it with the current index: graph LR index([\"index\"]) file3[\"modified: file.txt program.py\"] style file3 fill:#ffffff,stroke:#ffffff,color:#ff0000 index -.-> file3 A([\"A\"]) B([\"B\"]) B --> A head[\"HEAD\"] style head fill:#ffffff,stroke:#ffffff head --> B It then creates a new commit from the combined index: graph LR index([\"index\"]) A([\"A\"]) C([\"C*\"]) B([\"B\"]) C --> B B --> A corr[\"corrected\"] style corr fill:#ffffff,stroke:#ffffff corr --> C file2[\"modified: file.txt program.py\"] style file2 fill:#ffffff,stroke:#ffffff,color:#ff0000 C -.-> file2 git commit --amend is equivalent to: $ git reset --soft HEAD^ $ git status On branch master Changes to be committed: ( use \"git restore --staged <file>...\" to unstage ) modified: file.txt modified: program.py $ git commit -c ORIG_HEAD","title":"Changing the last commit"},{"location":"commits/#git__revert","text":"We are first going to create a commit that replaces the content of a file: $ echo \"This file is not that interesting\" > file.txt $ git commit -a -m \"Bad commit\" [ master 465a5a4 ] Bad commit 1 file changed, 1 insertion ( + ) , 3 deletions ( - ) $ git log --oneline --graph --all * 465a5a4 ( HEAD -> master ) Bad commit * f0d7298 Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit We later discover that the commit was a mistake and revert it: $ git revert 465a5a4 [ master 173e959 ] Revert \"Bad commit\" 1 file changed, 3 insertions ( + ) , 1 deletion ( - ) $ git log --oneline --graph --all * 173e959 ( HEAD -> master ) Revert \"Bad commit\" * 465a5a4 Bad commit * f0d7298 Merge branch 'second_branch' | \\ | * a118ae8 ( second_branch ) This is the third commit * | d3c6c63 This is the second commit | / * 23b3ed5 ( tag: first ) This is the first commit We can see that the revert commit simply removes the changes made in the first commit and restores changes make in the preceding commit: $ git show 173e959 commit 173e959ed5b0ccd9.... ( HEAD -> master ) Author: Mirko Myllykoski <mirko.myllykoski@gmail.com> Date: Tue Sep 29 19 :56:19 2020 +0200 Revert \"Bad commit\" This reverts commit 173e959ed5b0ccd9..... .... -This file is not that interesting +This file is very interesting +More content +Different content","title":"git revert"},{"location":"commits/#exercises","text":"Exercise Description 1.log Learn how to use git log 2.recover_head Learn how to recover a detached HEAD 3.stash Learn how to use git stash 4.discard Learn how to discard commits 5.amend Learn how to amend commits 6.revert Learn how to revert commits 7.workflow Learn proper workflow","title":"Exercises"},{"location":"intro/","text":"Introduction to Git \u00b6 This course will be an introduction to version control, with a strong focus on Git. Instructors: Pedro Ojeda-May (HPC2N) Birgitte Bryds\u00f6 (HPC2N) Diana Iusan (UPPMAX) The course will have a mixture of lectures and hands-ons, and will be split into modules. It will consist of five half-days. The lectures will be done in the main Zoom room. Most modules will have hands-ons. These are done in the main Zoom room, but with the possibility to go to break-out rooms for help. There will also be a silent room for those who prefer to work undisturbed. Some hands-ons will be done locally on your own computer and some will be done using GitHub. If there is a problem using your own computer, the backup solution is logging in to Tetralith and using that (if you have an account). The hands-ons for the module named \u201cTeamwork\u201d will be done in small groups, using GitHub. During the hands-ons you can just ask the instructors if there is anything you need help with. You can ask in the chat, but the recommended option is using the Questions and Answers page (Q&A page). The link can be found on the \u201cImportant information\u201d page. Please write any questions you have during the lectures etc. to the Q&A page. The instructors will try to answer as quickly as possible. Scroll down on a slide page to get to access the slides in a text form (small pen icon) Overview \u00b6 1. day Optional installation help (Git) Course info Introduction and setup Motivation - Why use version management? Basics commands, part 1 Creating & cloning repositories, Adding files, Committing, etc. Hands-on Basics commands, part 2 Creating & cloning repositories, Adding files, Committing, etc. Hands-on 2. day Basic concepts, part 1 Blobs, Trees, Commits, References, etc. Basic concepts, part 2 Blobs, Trees, Commits, References, etc. Traversing the commit tree, part 1 History, Tags, HEAD, Diffs, etc. Hands-on 3. day Traversing the commit tree, part 2 History, Tags, HEAD, Diffs, etc. Hands-on Traversing the commit tree, part 3 History, Tags, HEAD, Diffs, etc. Hands-on Branches, merges, and conflicts, part 1 Basics concepts, Creation, deletion, Conflicts, etc. Hands-on 4. day Branches, merges, and conflicts, part 2 Basics concepts, Creation, deletion, Conflicts, etc. Hands-on C. Brief intro to SSH-keys and using GitHub Working with remotes, part 1 Basics concepts, Pull, push, fetch, GitHub, etc. Hands-on Working with remotes, part 2 Basics concepts, Pull, push, fetch, GitHub, etc. Hands-on 5. day Teamwork, part 1 Hands-on Teamwork, part 2 Hands-on Teamwork, part 3 Hands-on Catch-up from previous days","title":"Introduction to Git"},{"location":"intro/#introduction__to__git","text":"This course will be an introduction to version control, with a strong focus on Git. Instructors: Pedro Ojeda-May (HPC2N) Birgitte Bryds\u00f6 (HPC2N) Diana Iusan (UPPMAX) The course will have a mixture of lectures and hands-ons, and will be split into modules. It will consist of five half-days. The lectures will be done in the main Zoom room. Most modules will have hands-ons. These are done in the main Zoom room, but with the possibility to go to break-out rooms for help. There will also be a silent room for those who prefer to work undisturbed. Some hands-ons will be done locally on your own computer and some will be done using GitHub. If there is a problem using your own computer, the backup solution is logging in to Tetralith and using that (if you have an account). The hands-ons for the module named \u201cTeamwork\u201d will be done in small groups, using GitHub. During the hands-ons you can just ask the instructors if there is anything you need help with. You can ask in the chat, but the recommended option is using the Questions and Answers page (Q&A page). The link can be found on the \u201cImportant information\u201d page. Please write any questions you have during the lectures etc. to the Q&A page. The instructors will try to answer as quickly as possible. Scroll down on a slide page to get to access the slides in a text form (small pen icon)","title":"Introduction to Git"},{"location":"intro/#overview","text":"1. day Optional installation help (Git) Course info Introduction and setup Motivation - Why use version management? Basics commands, part 1 Creating & cloning repositories, Adding files, Committing, etc. Hands-on Basics commands, part 2 Creating & cloning repositories, Adding files, Committing, etc. Hands-on 2. day Basic concepts, part 1 Blobs, Trees, Commits, References, etc. Basic concepts, part 2 Blobs, Trees, Commits, References, etc. Traversing the commit tree, part 1 History, Tags, HEAD, Diffs, etc. Hands-on 3. day Traversing the commit tree, part 2 History, Tags, HEAD, Diffs, etc. Hands-on Traversing the commit tree, part 3 History, Tags, HEAD, Diffs, etc. Hands-on Branches, merges, and conflicts, part 1 Basics concepts, Creation, deletion, Conflicts, etc. Hands-on 4. day Branches, merges, and conflicts, part 2 Basics concepts, Creation, deletion, Conflicts, etc. Hands-on C. Brief intro to SSH-keys and using GitHub Working with remotes, part 1 Basics concepts, Pull, push, fetch, GitHub, etc. Hands-on Working with remotes, part 2 Basics concepts, Pull, push, fetch, GitHub, etc. Hands-on 5. day Teamwork, part 1 Hands-on Teamwork, part 2 Hands-on Teamwork, part 3 Hands-on Catch-up from previous days","title":"Overview"},{"location":"kebnekaise/","text":"Connecting to Kebnekaise \u00b6 ThinLinc \u00b6 For this course we recommend using ThinLinc, but if you have your own installation of another SSH client that you prefer, you are welcome to use that. We will be using the command line only. Download the client from https://www.cendio.com/thinlinc/download and install it. Start the client. Enter the name of the server: kebnekaise-tl.hpc2n.umu.se and then enter your own username. Go to \u201cOptions\u201d -> \u201cSecurity\u201d. Check that authentication method is set to password. Go to \u201cOptions\u201d -> \u201cScreen\u201d and uncheck \u201cFull screen mode\u201d. Enter your HPC2N password. Click \u201cConnect\u201d. More information here: https://docs.hpc2n.umu.se/tutorials/connections/#thinlinc . SSH \u00b6 If you prefer to login with a regular SSH client (i.e. PuTTY, Terminal, Linux terminal, etc.) then use the following as server: kebnekaise.hpc2n.umu.se Example: logging in from a terminal: ssh <HPC2N username>@kebnekaise.hpc2n.umu.se More information here: https://docs.hpc2n.umu.se/tutorials/connections/#login__nodes Connecting from Windows Connecting from macOS Open OnDemand \u00b6 If you prefer to use HPC2N\u2019s OpenOnDemand web service, then: Go to https://portal.hpc2n.umu.se Login with your HPC2N username and password Pick \u201cInteractive Apps\u201d -> \u201cKebnekaise desktop\u201d Fill in the information. Pick 1 regular core and however many hours you expect to use on the course. Launch After you have logged in, start a terminal: \u201cApplications\u201d -> \u201cSystem Tools\u201d -> \u201cMATE Terminal\u201d More information here: https://docs.hpc2n.umu.se/tutorials/connections/#open__ondemand Setting up Git \u00b6 Git is already installed on Kebnekaise, but you need to set your name and email globals unless you have already done this at some earlier time . Open a terminal. In ThinLinc: Go to the menu at the top. Click \u201cApplications\u201d \u2192 \u201cSystem Tools\u201d \u2192 \u201cMATE Terminal\u201d. Set your global name: $ git config --global user.name \"Your Name\" Set your global email: $ git config --global user.email \"yourname@example.com\" You may also want to set your editor. We recommend vim, but other options are nano and emacs. $ git config --global core.editor vim Testing your configuration \u00b6 Create an example folder and cd into that, then create a file test.txt: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and add the new file: $ git init $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message: $ git commit test.txt Testing your configuration - continued \u00b6 Now let us look at the log: $ git log When you do git log , you should see something like: commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git but with name, email and commit message different. If that is the case, your Git should be configured correctly. Download the course materials \u00b6 For the individual hands-on part of the course, we have created some course materials which you will download from either the course website, the course GitHub, or the \u201cimportant information\u201d page. Course website: https://www.hpc2n.umu.se/events/courses/2022/introduction-to-git Course GitHub: https://github.com/hpc2n/course-intro-git Click the green button labeled \u201cCode\u201d to get links to clone or download the materials. Download the material, then please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Copy/transfer the tarball there (or download there directly with wget <url-to-tarball> ) Unpack with tar zxvf <tarball>","title":"Using Kebnekaise for the Git course"},{"location":"kebnekaise/#connecting__to__kebnekaise","text":"","title":"Connecting to Kebnekaise"},{"location":"kebnekaise/#thinlinc","text":"For this course we recommend using ThinLinc, but if you have your own installation of another SSH client that you prefer, you are welcome to use that. We will be using the command line only. Download the client from https://www.cendio.com/thinlinc/download and install it. Start the client. Enter the name of the server: kebnekaise-tl.hpc2n.umu.se and then enter your own username. Go to \u201cOptions\u201d -> \u201cSecurity\u201d. Check that authentication method is set to password. Go to \u201cOptions\u201d -> \u201cScreen\u201d and uncheck \u201cFull screen mode\u201d. Enter your HPC2N password. Click \u201cConnect\u201d. More information here: https://docs.hpc2n.umu.se/tutorials/connections/#thinlinc .","title":"ThinLinc"},{"location":"kebnekaise/#ssh","text":"If you prefer to login with a regular SSH client (i.e. PuTTY, Terminal, Linux terminal, etc.) then use the following as server: kebnekaise.hpc2n.umu.se Example: logging in from a terminal: ssh <HPC2N username>@kebnekaise.hpc2n.umu.se More information here: https://docs.hpc2n.umu.se/tutorials/connections/#login__nodes Connecting from Windows Connecting from macOS","title":"SSH"},{"location":"kebnekaise/#open__ondemand","text":"If you prefer to use HPC2N\u2019s OpenOnDemand web service, then: Go to https://portal.hpc2n.umu.se Login with your HPC2N username and password Pick \u201cInteractive Apps\u201d -> \u201cKebnekaise desktop\u201d Fill in the information. Pick 1 regular core and however many hours you expect to use on the course. Launch After you have logged in, start a terminal: \u201cApplications\u201d -> \u201cSystem Tools\u201d -> \u201cMATE Terminal\u201d More information here: https://docs.hpc2n.umu.se/tutorials/connections/#open__ondemand","title":"Open OnDemand"},{"location":"kebnekaise/#setting__up__git","text":"Git is already installed on Kebnekaise, but you need to set your name and email globals unless you have already done this at some earlier time . Open a terminal. In ThinLinc: Go to the menu at the top. Click \u201cApplications\u201d \u2192 \u201cSystem Tools\u201d \u2192 \u201cMATE Terminal\u201d. Set your global name: $ git config --global user.name \"Your Name\" Set your global email: $ git config --global user.email \"yourname@example.com\" You may also want to set your editor. We recommend vim, but other options are nano and emacs. $ git config --global core.editor vim","title":"Setting up Git"},{"location":"kebnekaise/#testing__your__configuration","text":"Create an example folder and cd into that, then create a file test.txt: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and add the new file: $ git init $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message: $ git commit test.txt","title":"Testing your configuration"},{"location":"kebnekaise/#testing__your__configuration__-__continued","text":"Now let us look at the log: $ git log When you do git log , you should see something like: commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git but with name, email and commit message different. If that is the case, your Git should be configured correctly.","title":"Testing your configuration - continued"},{"location":"kebnekaise/#download__the__course__materials","text":"For the individual hands-on part of the course, we have created some course materials which you will download from either the course website, the course GitHub, or the \u201cimportant information\u201d page. Course website: https://www.hpc2n.umu.se/events/courses/2022/introduction-to-git Course GitHub: https://github.com/hpc2n/course-intro-git Click the green button labeled \u201cCode\u201d to get links to clone or download the materials. Download the material, then please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Copy/transfer the tarball there (or download there directly with wget <url-to-tarball> ) Unpack with tar zxvf <tarball>","title":"Download the course materials"},{"location":"motivation/","text":"Lecture 1: Motivation \u00b6 What is version control? \u00b6 In software engineering, version control (also known as revision control, source control, or source code management) is a class of systems responsible for managing changes to computer programs, documents, large web sites, or other collections of information. \u2014 Wikipedia Version control systems (VCS) \u00b6 \u2026 systems responsible for managing changes \u2026 Why use version control? \u00b6 In an ideal world, things develop linearly: Every new version is an improvement upon the previous version. No need to backtrack. Everyone knows what everyone else is doing In the end, things are simply finished. graph LR A@{ shape: stadium, label: \"Monday's improvements\"} --> B@{ shape: stadium, label: \"Tuesday's improvements\"} B --> C@{ shape: stadium, label: \"Wednesday's improvements\"} In the real world, things develop non-linearly: A new version can be anything between a complete catastrophe and a major breakthrough. People do not know what others are doing Sometimes we are simply fixing earlier mistakes\u2026 graph LR Mon@{ shape: stadium, label: \"Monday's improvements\"} Tue@{ shape: stadium, label: \"Tuesday's mistakes\"} Wed@{ shape: stadium, label: \"Wednesday's corrections\"} Mon --> Tue Tue --> Wed Going back to an earlier version \u00b6 Sometimes, it is easier to simply backtrack to an earlier version \u2026 graph LR Mon@{ shape: stadium, label: \"Monday's improvements\"} Tue@{ shape: stadium, label: \"Tuesday's mistakes\"} Wed@{ shape: stadium, label: \"Wednesday's improvements\"} Mon --> Tue Mon --> Wed Where is this earlier version ? \u00b6 CTRL + Z my_file.txt, my_file.txt.old, \u2026 My project/ 2020-08-12/ 2020-08-13/ \u2026 Daily home directory backup Challenges and obstacles \u00b6 Prone to mistakes CTRL + Z has limits, overwritten/deleted files, human/hardware error How much to save? Individual files? Everything? How much space is required? How to organize versions? What is the difference between different versions? Overall, difficult to manage! What about the granularity? \u00b6 graph LR subgraph cluster1 [Monday's changes] t1a@{ shape: stadium, label: \"Component A improvement\"} t1b@{ shape: stadium, label: \"Component B mistake\"} t1c@{ shape: stadium, label: \"Component C improvement\"} end subgraph cluster2 [Tuesday's changes] t2a@{ shape: stadium, label: \"Component A improvement\"} t2b@{ shape: stadium, label: \"Component B correction\"} t2c@{ shape: stadium, label: \"Component C mistake\"} end subgraph cluster3 [Wednesday's changes] t3a@{ shape: stadium, label: \"Component A mistake\"} t3b@{ shape: stadium, label: \"Component B improvement\"} t3c@{ shape: stadium, label: \"Component C correction\"} end t1a --> t2a t1b --> t2b t1c --> t2c t2a --> t3a t2b --> t3b t2c --> t3c This compounds the problems! How does VCS solve this? \u00b6 Stores the history using snapshots (commits) Each snapshot represents the project at a given point in time Manages snapshots and associated metadata Naming (tags), comments, dates, authors, etc Easy to move between different snapshots Can handle different degrees of granularity Can handle multiple development paths (branches) Comparing and joining \u00b6 VCS makes it easy to compare different snapshots Named revisions, comments, time information, author information Diff tools Search tools Bisection search VCS also allows the joining (merging) of different snapshots Easy to experiment with ideas Collaboration \u00b6 One of the primary functions of VCS is to allow collaboration Usual setup: server (remote) + multiple clients People work locally and send (push) the changes to the server VCS keeps track of what has been done and by whom Safer since mistakes can be easily remedied The contributions of several people can be merged Backup \u00b6 VCS functions as a backup Locally, the system maintains a copy of each file Usually only the changes or the files that have changed are stored Globally, lost files can be recovered from the server Integration \u00b6 VCSs such as Git have been integrated with several services HackMD, Overleaf, \u2026 Services such as GitHub can do almost everything for you Store history, distribute, testing / continuous integration, bug reports, milestones, website, \u2026 Summing up \u00b6 Version control systems keeps track of your files and other output tracks what is created and modified tracks who made the modifications tracks why the modifications were made (if you make good commit comments) Practical use cases \u00b6 What are the practical use cases for VCS? Source code \u00b6 Many VCSs are designed for managing source code Manage deployment (production, development, testing, etc) Manage published versions (v0.1 etc) Manage (experimental) features Bug hunting But also for: writers, artists, composers\u2026 Latex files \u00b6 Track which version of a manuscript has been submitted, revised and/or accepted Collaboration between several authors HPC: batch files and data \u00b6 Track different versions of your batch scripts Easy to check the used configuration afterwards Track input and output files Limited to smallish files Examples of VCS \u00b6 SCCS: The first VCS. Created in 1972 at Bell Labs. Was available only for UNIX and worked with Source Code files only. RCS (Revision Control System): First release July 1985. Usually superseded by other systems such as CVS, which began as a wrapper on top of RCS. CVS (centralized version control system): First release July 1986; based on RCS. Expands on RCS by adding support for repository-level change tracking, and a client-server model. Apache Subversion (SVN): First release in 2004 by CVS developers with the goal of replacing CVS. BitKeeper: Initial release May 2000. Distributed version control. Was shortly used for developing the Linux kernel. Proprietary. No longer maintained. Git : Started by Linus Torvalds in April 2005, originally for developing the Linux kernel. Distributed version control. Open source. \u2026","title":"Why use version management?"},{"location":"motivation/#lecture__1__motivation","text":"","title":"Lecture 1: Motivation"},{"location":"motivation/#what__is__version__control","text":"In software engineering, version control (also known as revision control, source control, or source code management) is a class of systems responsible for managing changes to computer programs, documents, large web sites, or other collections of information. \u2014 Wikipedia","title":"What is version control?"},{"location":"motivation/#version__control__systems__vcs","text":"\u2026 systems responsible for managing changes \u2026","title":"Version control systems (VCS)"},{"location":"motivation/#why__use__version__control","text":"In an ideal world, things develop linearly: Every new version is an improvement upon the previous version. No need to backtrack. Everyone knows what everyone else is doing In the end, things are simply finished. graph LR A@{ shape: stadium, label: \"Monday's improvements\"} --> B@{ shape: stadium, label: \"Tuesday's improvements\"} B --> C@{ shape: stadium, label: \"Wednesday's improvements\"} In the real world, things develop non-linearly: A new version can be anything between a complete catastrophe and a major breakthrough. People do not know what others are doing Sometimes we are simply fixing earlier mistakes\u2026 graph LR Mon@{ shape: stadium, label: \"Monday's improvements\"} Tue@{ shape: stadium, label: \"Tuesday's mistakes\"} Wed@{ shape: stadium, label: \"Wednesday's corrections\"} Mon --> Tue Tue --> Wed","title":"Why use version control?"},{"location":"motivation/#going__back__to__an__earlier__version","text":"Sometimes, it is easier to simply backtrack to an earlier version \u2026 graph LR Mon@{ shape: stadium, label: \"Monday's improvements\"} Tue@{ shape: stadium, label: \"Tuesday's mistakes\"} Wed@{ shape: stadium, label: \"Wednesday's improvements\"} Mon --> Tue Mon --> Wed","title":"Going back to an earlier version"},{"location":"motivation/#comparing__and__joining","text":"VCS makes it easy to compare different snapshots Named revisions, comments, time information, author information Diff tools Search tools Bisection search VCS also allows the joining (merging) of different snapshots Easy to experiment with ideas","title":"Comparing and joining"},{"location":"motivation/#collaboration","text":"One of the primary functions of VCS is to allow collaboration Usual setup: server (remote) + multiple clients People work locally and send (push) the changes to the server VCS keeps track of what has been done and by whom Safer since mistakes can be easily remedied The contributions of several people can be merged","title":"Collaboration"},{"location":"motivation/#backup","text":"VCS functions as a backup Locally, the system maintains a copy of each file Usually only the changes or the files that have changed are stored Globally, lost files can be recovered from the server","title":"Backup"},{"location":"motivation/#integration","text":"VCSs such as Git have been integrated with several services HackMD, Overleaf, \u2026 Services such as GitHub can do almost everything for you Store history, distribute, testing / continuous integration, bug reports, milestones, website, \u2026","title":"Integration"},{"location":"motivation/#summing__up","text":"Version control systems keeps track of your files and other output tracks what is created and modified tracks who made the modifications tracks why the modifications were made (if you make good commit comments)","title":"Summing up"},{"location":"motivation/#practical__use__cases","text":"What are the practical use cases for VCS?","title":"Practical use cases"},{"location":"motivation/#source__code","text":"Many VCSs are designed for managing source code Manage deployment (production, development, testing, etc) Manage published versions (v0.1 etc) Manage (experimental) features Bug hunting But also for: writers, artists, composers\u2026","title":"Source code"},{"location":"motivation/#latex__files","text":"Track which version of a manuscript has been submitted, revised and/or accepted Collaboration between several authors","title":"Latex files"},{"location":"motivation/#hpc__batch__files__and__data","text":"Track different versions of your batch scripts Easy to check the used configuration afterwards Track input and output files Limited to smallish files","title":"HPC: batch files and data"},{"location":"motivation/#examples__of__vcs","text":"SCCS: The first VCS. Created in 1972 at Bell Labs. Was available only for UNIX and worked with Source Code files only. RCS (Revision Control System): First release July 1985. Usually superseded by other systems such as CVS, which began as a wrapper on top of RCS. CVS (centralized version control system): First release July 1986; based on RCS. Expands on RCS by adding support for repository-level change tracking, and a client-server model. Apache Subversion (SVN): First release in 2004 by CVS developers with the goal of replacing CVS. BitKeeper: Initial release May 2000. Distributed version control. Was shortly used for developing the Linux kernel. Proprietary. No longer maintained. Git : Started by Linus Torvalds in April 2005, originally for developing the Linux kernel. Distributed version control. Open source. \u2026","title":"Examples of VCS"},{"location":"rackham/","text":"Connecting to Rackham \u00b6 For this course we recommend using ThinLinc, but if you have your own installation of another SSH client that you prefer, you are welcome to use that. We will be using the command line only. Download the client from https://www.cendio.com/thinlinc/download and install it. Start the client. Enter the name of the server: rackham-gui.uppmax.uu.se and then enter your own username. Go to \u201cOptions\u201d -> \u201cSecurity\u201d. Check that authentication method is set to password. Go to \u201cOptions\u201d -> \u201cScreen\u201d and uncheck \u201cFull screen mode\u201d. Enter your UPPMAX password. Click \u201cConnect\u201d. ThinLinc can also be used from a browser: https://rackham-gui.uppmax.uu.se If you prefer a different SSH client (terminal, etc.), you connect with ssh -Y @rackham.uppmax.uu.se NOTE If you are not connecting from within the domain of a Swedish university, 2FA may be needed . You cannot do this through ThinLinc It can be handled by logging in with a regular SSH-client (PuTTy or similar) doing the 2FA and then logging out again there is then a grace period of some minutes for you to login to ThinLinc. More info here: https://www.uu.se/en/centre/uppmax/get-started/2-factor Setting up Git \u00b6 Git is already installed on Rackham, but you need to set your name and email globals unless you have already done this at some earlier time . Open a terminal. In ThinLinc: Go to the menu at the top. Click \u201cApplications\u201d \u2192 \u201cSystem Tools\u201d \u2192 \u201cMATE Terminal\u201d. Set your global name (change \u201cYour Name\u201d): $ git config --global user.name \"Your Name\" Set your global email (change the example): $ git config --global user.email \"name@example.com\" You may also want to set your editor. We recommend nano, but other options are vim and emacs (or notepad on Windows). $ git config --global core.editor nano Testing your configuration \u00b6 Create an example folder and cd into that, then create a file test.txt: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and add the new file: $ git init $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message: $ git commit test.txt Now let us look at the log: $ git log When you do git log , you should see something like: commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git but with name, email and commit message different. If that is the case, your Git should be configured correctly. Download the course materials \u00b6 For the individual hands-on part of the course, we have created some course materials which you will download from either the course website, the course GitHub, or the \u201cimportant information\u201d page. Course website: https://www.hpc2n.umu.se/events/courses/2024/fall/git Course GitHub: https://github.com/hpc2n/course-intro-git Click the green button labeled \u201cCode\u201d for links to clone or download the materials. Either do 1. CLONE or 2. DOWNLOAD , not both! CLONE: Change to the directory where you wish to have the course material and clone with \u2018git clone\u2019 and the url: git clone https://github.com/hpc2n/course-intro-git.git You get the directory: course-intro-git DOWNLOAD Zipfile: Please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Download the Zipfile and move it there. Can be done directly from the terminal with wget https://github.com/hpc2n/course-intro-git/archive/refs/heads/main.zip ) Unpack with unzip main.zip . You will get a directory called course-intro-git-main .","title":"Using Rackham for the Git course"},{"location":"rackham/#connecting__to__rackham","text":"For this course we recommend using ThinLinc, but if you have your own installation of another SSH client that you prefer, you are welcome to use that. We will be using the command line only. Download the client from https://www.cendio.com/thinlinc/download and install it. Start the client. Enter the name of the server: rackham-gui.uppmax.uu.se and then enter your own username. Go to \u201cOptions\u201d -> \u201cSecurity\u201d. Check that authentication method is set to password. Go to \u201cOptions\u201d -> \u201cScreen\u201d and uncheck \u201cFull screen mode\u201d. Enter your UPPMAX password. Click \u201cConnect\u201d. ThinLinc can also be used from a browser: https://rackham-gui.uppmax.uu.se If you prefer a different SSH client (terminal, etc.), you connect with ssh -Y @rackham.uppmax.uu.se NOTE If you are not connecting from within the domain of a Swedish university, 2FA may be needed . You cannot do this through ThinLinc It can be handled by logging in with a regular SSH-client (PuTTy or similar) doing the 2FA and then logging out again there is then a grace period of some minutes for you to login to ThinLinc. More info here: https://www.uu.se/en/centre/uppmax/get-started/2-factor","title":"Connecting to Rackham"},{"location":"rackham/#setting__up__git","text":"Git is already installed on Rackham, but you need to set your name and email globals unless you have already done this at some earlier time . Open a terminal. In ThinLinc: Go to the menu at the top. Click \u201cApplications\u201d \u2192 \u201cSystem Tools\u201d \u2192 \u201cMATE Terminal\u201d. Set your global name (change \u201cYour Name\u201d): $ git config --global user.name \"Your Name\" Set your global email (change the example): $ git config --global user.email \"name@example.com\" You may also want to set your editor. We recommend nano, but other options are vim and emacs (or notepad on Windows). $ git config --global core.editor nano","title":"Setting up Git"},{"location":"rackham/#testing__your__configuration","text":"Create an example folder and cd into that, then create a file test.txt: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and add the new file: $ git init $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message: $ git commit test.txt Now let us look at the log: $ git log When you do git log , you should see something like: commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git but with name, email and commit message different. If that is the case, your Git should be configured correctly.","title":"Testing your configuration"},{"location":"rackham/#download__the__course__materials","text":"For the individual hands-on part of the course, we have created some course materials which you will download from either the course website, the course GitHub, or the \u201cimportant information\u201d page. Course website: https://www.hpc2n.umu.se/events/courses/2024/fall/git Course GitHub: https://github.com/hpc2n/course-intro-git Click the green button labeled \u201cCode\u201d for links to clone or download the materials. Either do 1. CLONE or 2. DOWNLOAD , not both! CLONE: Change to the directory where you wish to have the course material and clone with \u2018git clone\u2019 and the url: git clone https://github.com/hpc2n/course-intro-git.git You get the directory: course-intro-git DOWNLOAD Zipfile: Please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Download the Zipfile and move it there. Can be done directly from the terminal with wget https://github.com/hpc2n/course-intro-git/archive/refs/heads/main.zip ) Unpack with unzip main.zip . You will get a directory called course-intro-git-main .","title":"Download the course materials"},{"location":"remotes-exercises/","text":"Exercises - Working with remotes \u00b6 In order to do these exercises, you need to download the exercises zip file (if you already did so for the previous exercise, you do not need to do so again, of course). You can do that either by cloning the repository or by just getting the zip file with wget . Do ONE of the following: git clone git clone https://github.com/hpc2n/course-intro-git.git cd course-intro-git unzip git_materials.zip cd git_materials cd 6.remotes Fetch with wget wget https://github.com/hpc2n/course-intro-git/raw/refs/heads/main/git_materials.zip unzip git_materials.zip cd git_materials cd 6.remotes You are now in a directory with 2 subdirectories, one for each exercise. Adding remotes \u00b6 Make sure you are in the subdirectory git_materials/6.remotes/1.adding-remotes . Fork the following repository https://github.com/pojeda/pull-request-course.git Clone the forked repository and check the available remotes Add the upstream repository with the name \u201cupstream\u201d Using your cloned version of the forked repository, make some modification to the \u201cREADME.md\u201d file and commit them locally. Then, push the changes to the remote. Finally, make a \u201cpull request\u201d from your GitHub account. Merge conflicts and rebasing \u00b6 Make sure you are in the subdirectory git_materials/6.remotes/2.merge-rebase . Note This exercise demonstrates how to solve a merge conflict using rebasing. Note: for the present example you don\u2019t need to add a remote. It has been added for this example already. Tasks: Enter the repository directory and check the current status. Check that the file file.txt has been modified since the last commit using the diff command Try commiting the changes and push them to the remote Why do the push was unsuccesful? hint: the remote contains changes that are missing from your local remote. Pull the changes from the remote When the text editor opens save the commit message. This means that Git is able to merge the remote and your local changes. Take a look at the commits\u2019 tree graph: git log --all --decorate --oneline --graph and save it into a text file for further investigations. You could simply continue to work normally from here but the merge commit you just created is not actually necessary in this situation. Try falling back to the previous commit: $ git reset --hard HEAD~ Now, pull again but tell Git to rebase your branch: $ git pull --rebase Take a look at the graph once again with: git log --all --decorate --oneline --graph and compare it with the one you saved into a text file. You can now see that the merge commit was not necessary. Finally, you can now push the changes to the remote.","title":"Working with remotes"},{"location":"remotes-exercises/#exercises__-__working__with__remotes","text":"In order to do these exercises, you need to download the exercises zip file (if you already did so for the previous exercise, you do not need to do so again, of course). You can do that either by cloning the repository or by just getting the zip file with wget . Do ONE of the following: git clone git clone https://github.com/hpc2n/course-intro-git.git cd course-intro-git unzip git_materials.zip cd git_materials cd 6.remotes Fetch with wget wget https://github.com/hpc2n/course-intro-git/raw/refs/heads/main/git_materials.zip unzip git_materials.zip cd git_materials cd 6.remotes You are now in a directory with 2 subdirectories, one for each exercise.","title":"Exercises - Working with remotes"},{"location":"remotes-exercises/#adding__remotes","text":"Make sure you are in the subdirectory git_materials/6.remotes/1.adding-remotes . Fork the following repository https://github.com/pojeda/pull-request-course.git Clone the forked repository and check the available remotes Add the upstream repository with the name \u201cupstream\u201d Using your cloned version of the forked repository, make some modification to the \u201cREADME.md\u201d file and commit them locally. Then, push the changes to the remote. Finally, make a \u201cpull request\u201d from your GitHub account.","title":"Adding remotes"},{"location":"remotes-exercises/#merge__conflicts__and__rebasing","text":"Make sure you are in the subdirectory git_materials/6.remotes/2.merge-rebase . Note This exercise demonstrates how to solve a merge conflict using rebasing. Note: for the present example you don\u2019t need to add a remote. It has been added for this example already. Tasks: Enter the repository directory and check the current status. Check that the file file.txt has been modified since the last commit using the diff command Try commiting the changes and push them to the remote Why do the push was unsuccesful? hint: the remote contains changes that are missing from your local remote. Pull the changes from the remote When the text editor opens save the commit message. This means that Git is able to merge the remote and your local changes. Take a look at the commits\u2019 tree graph: git log --all --decorate --oneline --graph and save it into a text file for further investigations. You could simply continue to work normally from here but the merge commit you just created is not actually necessary in this situation. Try falling back to the previous commit: $ git reset --hard HEAD~ Now, pull again but tell Git to rebase your branch: $ git pull --rebase Take a look at the graph once again with: git log --all --decorate --oneline --graph and compare it with the one you saved into a text file. You can now see that the merge commit was not necessary. Finally, you can now push the changes to the remote.","title":"Merge conflicts and rebasing"},{"location":"remotes/","text":"Lecture 6: Working with remotes \u00b6 Concepts \u00b6 A remote repository is a version of the project which can be hosted in your local machine, some network, or over the internet (Pro Git, 2nd. Ed., Scott Chacon and Ben Straub) where you and your collaborators can push or pull code modifications. In addition to this, a remote is a way to backup your repository. Updated scheme for file stages \u00b6 Concepts cont. \u00b6 The command $ git remote - v origin git @bitbucket.org : arm2011 / gitcourse . git ( fetch ) origin git @bitbucket.org : arm2011 / gitcourse . git ( push ) displays the remotes that are already set up where you can fetch and pull changes. In this case there is only a single remoted called origin . $ git graph * 2e56d 0 a ( HEAD -> main , origin / main , origin / HEAD ) text of exercise git diff usage * 22 a7316 Adding yet more lectures * 0d db791 Adding some more of the lectures * 3f f9f8f Adding some of the lectures Adding remotes \u00b6 A remote repository can be added manually with the command $ git remote add remote_name location $ git remote add remote_name git @github.com : aliceuser2020 / my - first - project . git $ git remote - v remote_name git @github.com : aliceuser2020 / my - first - project . git ( fetch ) remote_name git @github.com : aliceuser2020 / my - first - project . git ( push ) where the location of the remote can be an URL or the path if that is in your local machine. Protocols: local -> git clone /opt/git/project.git SSH -> git clone ssh://user@server:project.git HTTP -> git clone http://example.com/gitproject.git Git Why do we need more than one remote? graph TD bob{\"Bob repo\"} origin[\"origin\"] style origin fill:#ffffff,stroke:#ffffff,color:#ff0000 upstream[\"upstream\"] style upstream fill:#ffffff,stroke:#ffffff,color:#ff0000 upstream -.-> bob origin -.-> alicef alicef([\"Alice fork\"]) alicel([\"Alice local\"]) bob --> alicef alicef --> alicel alicel -.-> bob $ git remote add upstream git @github.com : bob / my - first - project . git $ git remote - v origin git @github.com : aliceuser2020 / my - first - project . git ( fetch ) origin git @github.com : aliceuser2020 / my - first - project . git ( push ) upstream git @github.com : bobuser2020 / my - first - project . git ( fetch ) upstream git @github.com : bobuser2020 / my - first - project . git ( push ) $git graph * 2e56d 0 a ( HEAD -> main , upstream / main , origin / main , origin / HEAD ) text of exercise git diff usage * 22 a7316 Adding yet more lectures * 0d db791 Adding some more of the lectures * 3f f9f8f Adding some of the lectures Working with remotes \u00b6 One can push or fetch/pull to or from remotes: $ git push remote_name branch_name $ git fetch remote_name branch_name $ git pull remote_name branch_name In case you obtained the repository by cloning an existing one you will have the origin remote. You can do push/fetch/pull for this remote with $ git push origin master $ git fetch origin master $ git pull origin master or $ git push $ git fetch $ git pull because the remote origin and the master branch are configured for pushing and pulling by default upon cloning. The command: $ git pull brings all the changes (branches) that are in the remote and tries to merge them with the current branch of the local repo. The default behavior of git pull ( fetch part) is in the $GIT_DIR/config file: [ remote \"origin\" ] fetch = +refs/heads/*:refs/remotes/origin/* In fact, git pull is a combination of two commands: $ git fetch remote_name branch_name $ git merge remote_name/branch_name If you want to fetch all branches and merge the current one: $ git fetch $ git merge Advanced \u00b6 The command $ git push will send the changes in the current branch to the remote by default. The default behavior can be seen with: $ git config --get push.default This can be changed by applying: git config --global push.default matching ( default ) , current, ... If you have a brand-new branch called new , you can push it the first time with the command: git push -u origin new which is equivalent to git push origin new git branch --set-upstream new origin/new then, you will be able to push/pull the changes in the branch by simply typing git push/pull Displaying remote information \u00b6 $ git remote show origin * remote origin Fetch URL: git@bitbucket.org:arm2011/gitcourse.git Push URL: git@bitbucket.org:arm2011/gitcourse.git HEAD branch: master Remote branches: experiment tracked feature tracked less-salt tracked master tracked nested-feature tracked Local branches configured for 'git pull': feature merges with remote feature master merges with remote master nested-feature merges with remote nested-feature Local refs configured for 'git push': feature pushes to feature (fast-forwardable) master pushes to master (up to date) nested-feature pushes to nested-feature (up to date) Renaming remotes \u00b6 $ git remote rename initial_name new_name Deleting remotes \u00b6 $ git remote remove remote_name Bare repositories \u00b6 A bare repository is a repository with no working directory. Creating a bare repository \u00b6 $ mkdir bare.git && cd bare.git $ git init --bare Cloning a bare repository cont. \u00b6 $ git clone --bare location Using GitHub \u00b6 Upon login into your GitHub account you will see the following option to create a new repository Here, you can choose the type of repository that is appropriate to your needs (public/private), if you want to add README and .gitignore files and also the type of license for your project, GitHub will suggest some steps that you can take for your brand-new repository: Setting ssh-keys \u00b6 ssh-keygen -t rsa -b 4096 -C \u201cpedro@gemail.com\u201d eval $(ssh-agent -s) ssh-add ~/.ssh/id_rsa clip < ~/.ssh/id_rsa.pub (it copies the ssh key that has got generated) Go to your remote repository on github.com and then Settings -> SSH and GPG keys ->new SSH key -> write a title and paste the copied SSH key and save it check if the key was properly set on github/bitbucket $ ssh -T git@bitbucket.org $ ssh -T git@github.com Network visualization \u00b6 Working with other\u2019s repos \u00b6 In the following scenario, a developer, Bob, has its repo on GitHub. Another developer, Alice, finds it useful. Alice can clone it but she cannot push changes unless Bob allows it: graph LR bob[\"Bob repo\"] --- n1[\"cloning\"] n1 --> alice([\"Alice cloned\"]) alice -.- n2[\"cannot commit\"] n2 -.-> bob n1@{ shape: text} n2@{ shape: text} style n2 color:#D50000 linkStyle 2 stroke:#D50000,fill:none linkStyle 3 stroke:#D50000,fill:none A better approach is to fork Bob\u2019s repository: graph LR bob[\"Bob's repo (upstream)\"] alicef([\"Alice's repo (origin)\"]) alicel([\"Alice local copy (PC/laptop)\"]) style alicel fill:#ffffff,stroke:#39742b,color:#39742b alicef --> |cloning| alicel alicel --> |can commit| alicef bob --> |forking| alicef alicel -.- n1[\"cannot commit\"] alicel -.- n2[\"can request pulls\"] n1 -.-> bob n2 -.-> bob n1@{ shape: text} n2@{ shape: text} style n1 color:#D50000 style n2 color:#4169E1 linkStyle 3 stroke:#D50000,fill:none linkStyle 4 stroke:#4169E1,fill:none linkStyle 5 stroke:#D50000,fill:none linkStyle 6 stroke:#4169E1,fill:none In this way, Alice can push changes to her repository and eventually make Bob aware of them as well. Forking a repository \u00b6 To fork a repository, Alice go to the URL of the target repository and use the option Fork in Bob\u2019s repository: Forking a repository \u00b6 Then, Alice will see the forked repository on her user space: After doing some changes, Alice push them to her forked repository but she wants Bob become aware of them (1 commit in this case, click on this commit) Pull request \u00b6 A pull request will be suggested: You can then create a the PR: Another way to create PR is with \u201cPull request\u201d option: Then, Bob receives an email with the pull request information about Alice modifications. On the GitHub site he sees the request: Because Bob find the changes from Alice useful and there are no conflicts he can merge them, Issues \u00b6 If you find some issues in the files/code you can open an \u201cIssue\u201d on GitHub You may also assign people to the issues that are more related to that topic. In future commits you may refer to this issue by using the issue number, #2 in this case. This will allow you to track the evolution of the issue on GitHub. Best practices \u00b6 Communicate with your colleagues. Some commands such as git rebase change the history. It wouldn\u2019t be a good idea to use them on public branches. Don\u2019t accept pull requests right away.","title":"Working with remotes"},{"location":"remotes/#lecture__6__working__with__remotes","text":"","title":"Lecture 6: Working with remotes"},{"location":"remotes/#concepts","text":"A remote repository is a version of the project which can be hosted in your local machine, some network, or over the internet (Pro Git, 2nd. Ed., Scott Chacon and Ben Straub) where you and your collaborators can push or pull code modifications. In addition to this, a remote is a way to backup your repository.","title":"Concepts"},{"location":"remotes/#updated__scheme__for__file__stages","text":"","title":"Updated scheme for file stages"},{"location":"remotes/#concepts__cont","text":"The command $ git remote - v origin git @bitbucket.org : arm2011 / gitcourse . git ( fetch ) origin git @bitbucket.org : arm2011 / gitcourse . git ( push ) displays the remotes that are already set up where you can fetch and pull changes. In this case there is only a single remoted called origin . $ git graph * 2e56d 0 a ( HEAD -> main , origin / main , origin / HEAD ) text of exercise git diff usage * 22 a7316 Adding yet more lectures * 0d db791 Adding some more of the lectures * 3f f9f8f Adding some of the lectures","title":"Concepts cont."},{"location":"remotes/#adding__remotes","text":"A remote repository can be added manually with the command $ git remote add remote_name location $ git remote add remote_name git @github.com : aliceuser2020 / my - first - project . git $ git remote - v remote_name git @github.com : aliceuser2020 / my - first - project . git ( fetch ) remote_name git @github.com : aliceuser2020 / my - first - project . git ( push ) where the location of the remote can be an URL or the path if that is in your local machine. Protocols: local -> git clone /opt/git/project.git SSH -> git clone ssh://user@server:project.git HTTP -> git clone http://example.com/gitproject.git Git Why do we need more than one remote? graph TD bob{\"Bob repo\"} origin[\"origin\"] style origin fill:#ffffff,stroke:#ffffff,color:#ff0000 upstream[\"upstream\"] style upstream fill:#ffffff,stroke:#ffffff,color:#ff0000 upstream -.-> bob origin -.-> alicef alicef([\"Alice fork\"]) alicel([\"Alice local\"]) bob --> alicef alicef --> alicel alicel -.-> bob $ git remote add upstream git @github.com : bob / my - first - project . git $ git remote - v origin git @github.com : aliceuser2020 / my - first - project . git ( fetch ) origin git @github.com : aliceuser2020 / my - first - project . git ( push ) upstream git @github.com : bobuser2020 / my - first - project . git ( fetch ) upstream git @github.com : bobuser2020 / my - first - project . git ( push ) $git graph * 2e56d 0 a ( HEAD -> main , upstream / main , origin / main , origin / HEAD ) text of exercise git diff usage * 22 a7316 Adding yet more lectures * 0d db791 Adding some more of the lectures * 3f f9f8f Adding some of the lectures","title":"Adding remotes"},{"location":"remotes/#working__with__remotes","text":"One can push or fetch/pull to or from remotes: $ git push remote_name branch_name $ git fetch remote_name branch_name $ git pull remote_name branch_name In case you obtained the repository by cloning an existing one you will have the origin remote. You can do push/fetch/pull for this remote with $ git push origin master $ git fetch origin master $ git pull origin master or $ git push $ git fetch $ git pull because the remote origin and the master branch are configured for pushing and pulling by default upon cloning. The command: $ git pull brings all the changes (branches) that are in the remote and tries to merge them with the current branch of the local repo. The default behavior of git pull ( fetch part) is in the $GIT_DIR/config file: [ remote \"origin\" ] fetch = +refs/heads/*:refs/remotes/origin/* In fact, git pull is a combination of two commands: $ git fetch remote_name branch_name $ git merge remote_name/branch_name If you want to fetch all branches and merge the current one: $ git fetch $ git merge","title":"Working with remotes"},{"location":"remotes/#advanced","text":"The command $ git push will send the changes in the current branch to the remote by default. The default behavior can be seen with: $ git config --get push.default This can be changed by applying: git config --global push.default matching ( default ) , current, ... If you have a brand-new branch called new , you can push it the first time with the command: git push -u origin new which is equivalent to git push origin new git branch --set-upstream new origin/new then, you will be able to push/pull the changes in the branch by simply typing git push/pull","title":"Advanced"},{"location":"remotes/#displaying__remote__information","text":"$ git remote show origin * remote origin Fetch URL: git@bitbucket.org:arm2011/gitcourse.git Push URL: git@bitbucket.org:arm2011/gitcourse.git HEAD branch: master Remote branches: experiment tracked feature tracked less-salt tracked master tracked nested-feature tracked Local branches configured for 'git pull': feature merges with remote feature master merges with remote master nested-feature merges with remote nested-feature Local refs configured for 'git push': feature pushes to feature (fast-forwardable) master pushes to master (up to date) nested-feature pushes to nested-feature (up to date)","title":"Displaying remote information"},{"location":"remotes/#renaming__remotes","text":"$ git remote rename initial_name new_name","title":"Renaming remotes"},{"location":"remotes/#deleting__remotes","text":"$ git remote remove remote_name","title":"Deleting remotes"},{"location":"remotes/#bare__repositories","text":"A bare repository is a repository with no working directory.","title":"Bare repositories"},{"location":"remotes/#creating__a__bare__repository","text":"$ mkdir bare.git && cd bare.git $ git init --bare","title":"Creating a bare repository"},{"location":"remotes/#cloning__a__bare__repository__cont","text":"$ git clone --bare location","title":"Cloning a bare repository cont."},{"location":"remotes/#using__github","text":"Upon login into your GitHub account you will see the following option to create a new repository Here, you can choose the type of repository that is appropriate to your needs (public/private), if you want to add README and .gitignore files and also the type of license for your project, GitHub will suggest some steps that you can take for your brand-new repository:","title":"Using GitHub"},{"location":"remotes/#setting__ssh-keys","text":"ssh-keygen -t rsa -b 4096 -C \u201cpedro@gemail.com\u201d eval $(ssh-agent -s) ssh-add ~/.ssh/id_rsa clip < ~/.ssh/id_rsa.pub (it copies the ssh key that has got generated) Go to your remote repository on github.com and then Settings -> SSH and GPG keys ->new SSH key -> write a title and paste the copied SSH key and save it check if the key was properly set on github/bitbucket $ ssh -T git@bitbucket.org $ ssh -T git@github.com","title":"Setting ssh-keys"},{"location":"remotes/#network__visualization","text":"","title":"Network visualization"},{"location":"remotes/#working__with__others__repos","text":"In the following scenario, a developer, Bob, has its repo on GitHub. Another developer, Alice, finds it useful. Alice can clone it but she cannot push changes unless Bob allows it: graph LR bob[\"Bob repo\"] --- n1[\"cloning\"] n1 --> alice([\"Alice cloned\"]) alice -.- n2[\"cannot commit\"] n2 -.-> bob n1@{ shape: text} n2@{ shape: text} style n2 color:#D50000 linkStyle 2 stroke:#D50000,fill:none linkStyle 3 stroke:#D50000,fill:none A better approach is to fork Bob\u2019s repository: graph LR bob[\"Bob's repo (upstream)\"] alicef([\"Alice's repo (origin)\"]) alicel([\"Alice local copy (PC/laptop)\"]) style alicel fill:#ffffff,stroke:#39742b,color:#39742b alicef --> |cloning| alicel alicel --> |can commit| alicef bob --> |forking| alicef alicel -.- n1[\"cannot commit\"] alicel -.- n2[\"can request pulls\"] n1 -.-> bob n2 -.-> bob n1@{ shape: text} n2@{ shape: text} style n1 color:#D50000 style n2 color:#4169E1 linkStyle 3 stroke:#D50000,fill:none linkStyle 4 stroke:#4169E1,fill:none linkStyle 5 stroke:#D50000,fill:none linkStyle 6 stroke:#4169E1,fill:none In this way, Alice can push changes to her repository and eventually make Bob aware of them as well.","title":"Working with other&rsquo;s repos"},{"location":"remotes/#forking__a__repository","text":"To fork a repository, Alice go to the URL of the target repository and use the option Fork in Bob\u2019s repository:","title":"Forking a repository"},{"location":"remotes/#forking__a__repository_1","text":"Then, Alice will see the forked repository on her user space: After doing some changes, Alice push them to her forked repository but she wants Bob become aware of them (1 commit in this case, click on this commit)","title":"Forking a repository"},{"location":"remotes/#pull__request","text":"A pull request will be suggested: You can then create a the PR: Another way to create PR is with \u201cPull request\u201d option: Then, Bob receives an email with the pull request information about Alice modifications. On the GitHub site he sees the request: Because Bob find the changes from Alice useful and there are no conflicts he can merge them,","title":"Pull request"},{"location":"remotes/#issues","text":"If you find some issues in the files/code you can open an \u201cIssue\u201d on GitHub You may also assign people to the issues that are more related to that topic. In future commits you may refer to this issue by using the issue number, #2 in this case. This will allow you to track the evolution of the issue on GitHub.","title":"Issues"},{"location":"remotes/#best__practices","text":"Communicate with your colleagues. Some commands such as git rebase change the history. It wouldn\u2019t be a good idea to use them on public branches. Don\u2019t accept pull requests right away.","title":"Best practices"},{"location":"setup/","text":"Lecture 0: Setup \u00b6 Installing and setting up Git \u00b6 We will use Git from the command line in this course. This is normally how you will use it on the various HPC centers, and this way it will also be easier to understand what is going on while you are learning to use Git. On Windows, this means you will be using Git Bash. Graphical tools exists for Git, see below list for a few. All entries on the list are free and unless otherwise mentioned, available for Windows, macOS, and Linux: git-scm (https://git-scm.com) comes with a basic GUI Git Kraken (https://www.gitkraken.com/) Github Desktop (https://desktop.github.com/) Windows and macOS only Sourcetree (https://www.sourcetreeapp.com/) Windows and macOS only TortoiseGit (https://tortoisegit.org/) Windows only Install Git, if you have not already Create a repository with git init Set your name and email with git config (local, global, system). More info in a moment. Test by creating a file Then adding the file with git add Then commiting the file with git commit Check with git log that all looks well. When this is done, you will clone the course materials. NOTE : if you have a problem getting this to work on your own computer, and you have an account at Tetralith or any other HPC system, then you can use that instead. We have some documentation for you for Tetralith: Using Tetralith for the Git course As mentioned, you may also use any other HPC system you have an account at, of course. The above documentation would need only minor adjustements. Git install - Windows \u00b6 Go to the Git-scm website ( https://git-scm.com/downloads ) and click \u201cWindows\u201d to download the Windows version. It should automatically start download of the .exe file. The downloaded file can be installed by double-clicking and choosing \u201cRun\u201d. Click \u201cYes\u201d to let it be installed and then \u201cNext\u201d to accept the GNU GPL. The default options you are presented with should work, and we recommend using those. You will be using Git Bash for this course NOTE: when it comes to choosing the default editor, we recommend using either notepad or vim, unless you have a preferred editor. See the section on \u201cConfigure git\u201d as well as the section on editors at the end of this document for some help. Git install - macOS \u00b6 If you have installed XCode (or its Command Line Tools), Git may already be installed. To find out, open a terminal and enter git --version . If Git is not installed, you have several installation options. Apple maintains their own fork of Git, but it is usually a few versions behind, so we do not recommend installing that. SourceForge: https://sourceforge.net/projects/git-osx-installer/files/ Git-scm.com: https://git-scm.com/downloads If you have Homebrew: brew install git Git install - Linux \u00b6 Git is usually already installed on Linux, but if not, this is how you install it. Installing Git on Linux depends on which distro you are running. sudo apt-get install git (Ubuntu, Debian) sudo dnf install git (RHEL, CentOS) https://git-scm.com/download/linux (other) Git install - primary branch \u00b6 The primary branch will probably be named \u201cmaster\u201d when installing Git. You can choose if you want to instead name it \u201cmain\u201d (which is what GitHub uses as default). Regardless of which you pick, stick to one to avoid problems when pushing a repo You can change the naming of the primary branch in GitHub for a repo Go to repo Pick \u201cSettings\u201d -> \u201cGeneral\u201d Change the name in \u201cDefault branch\u201d Instructions how to rename the primary branch in a repo from \u201cmaster\u201d to \u201cmain\u201d on the command line: https://gist.github.com/danieldogeanu/739f88ea5312aaa23180e162e3ae89ab Configure git (all OS) \u00b6 First check that you have git installed (in a terminal or in Git Bash): $ git --version Now configure git with git config (local, global, system) You should at least set your global name and email (just once): $ git config --global user.name \"Your Name\" $ git config --global user.email \"yourname@example.com\" Setting the editor (once) is also a good idea: $ git config --global core.editor <editor> Choices for editor could be (on Linux, though can be installed together with Git for other OS): * nano * vim * emacs You should be able to use notepad on Windows by setting: git config --global core.editor \"<path-to>/notepad++.exe\" Another option could be to install VS Code and do this config instead: git config --global core.editor \"code --wait\" GitHub has some documentation on choosing and setting editors for various OS: https://docs.github.com/en/get-started/getting-started-with-git/associating-text-editors-with-git See more about configuring and using editors with Git at the end of this document. Test your Git installation \u00b6 Create an example folder and change to that, then create a file test.txt. On Linux you would do this: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and stage the new file: $ git init Initialized empty Git repository in /home/bbrydsoe/test-git/.git/ $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message : $ git commit test.txt [ master ( root-commit ) ff8b6f6 ] Test of git 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 test.txt Now let us look at the log: $ git log commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git When you do git log , you should see something like the above, but with name, email, date, and commit message different. If that is the case, your Git should be configured correctly. Download the course materials \u00b6 For the individual hands-on part of the course, we have created some course materials which you will download from the course GitHub repo: https://github.com/hpc2n/course-intro-git (normally you click the green \u201cCode\u201d button to get the link to clone or download) Please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Do one of : git clone https://github.com/hpc2n/course-intro-git.git Download the zipfile (directly with wget https://github.com/hpc2n/course-intro-git/archive/refs/heads/main.zip or elsewhere then transfer) and unzip. You can also get the link from the course GitHub repo: https://github.com/hpc2n/course-intro-git . Web based Git repositories \u00b6 There are several web based Git repositories. Some of the more popular ones are: GitHub ( https://github.com/ ) GitLab ( https://www.gitlab.com ) Bitbucket ( https://bitbucket.org ) SourceForge ( https://sourceforge.net/ ) GitHub \u00b6 We are going to use GitHub for the part of the hands-on where you will be working together in groups. Please go to https://github.com/ and sign up for an account, if you do not already have one. You will need to setup 2FA also. Create a new SSH key for GitHub \u00b6 Linux and macOS \u00b6 This part will be done before the section \u201cWorking with remotes\u201d on day 4, but you can create and add your SSH key to GitHub now if you want to. Open a terminal. In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name for the new systems - change to what your key was called ( .ssh/id_rsa for the legacy system): $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_ed25519 Switch to the .ssh folder, open the file id_ed25519.pub with some editor and copy it ( id_rsa for legacy systems). Do NOT add any newlines or whitespace! Windows \u00b6 This part will be done during the exercises on day 5, but you can create and add your SSH key to GitHub now if you want to. Open Git Bash. In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name for the new systems - change to what your key was called ( .ssh/id_rsa for the legacy system): $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_ed25519 Switch to the .ssh folder, with some editor, open the file id_ed25519.pub (or id_rsa.pub for the legacy systems) and copy it. Do NOT add any newlines or whitespace! Adding the SSH key to GitHub \u00b6 On GitHub, click your avatar in the top right corner and pick \u201cSettings\u201d. Choose \u201cSSH and GPG keys\u201d Click the green button labeled \u201cNew SSH key\u201d Add a descriptive label for the key in the \u201cTitle\u201d field. In the key field you paste the content of the key (~/.ssh/id_rsa.pub) Click \u201cAdd SSH key\u201d Confirm your GitHub password if you are prompted for it. Testing the SSH keys \u00b6 Open a terminal / the Git bash $ ssh -T git@github.com It will look similar to this: $ ssh -T git@github.com The authenticity of host 'github.com (140.82.121.3)' can't be established. ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM. ECDSA key fingerprint is MD5:7b:99:81:1e:4c:91:a5:0d:5a:2e:2e:80:13:3f:24:ca. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,140.82.121.3' (ECDSA) to the list of known hosts. Hi bbrydsoe! You've successfully authenticated, but GitHub does not provide shell access. Verify that the resulting message contains your username. More on editors \u00b6 Linux \u00b6 Vim You may need to install it first. ( sudo apt-get install vim ) Start with vim <filename> to open a file for editing. The file will be created if it does not exist before. Type i to enter \u2018insert\u2019 mode to be able to write in the editor. Use ESC to go to \u2018command\u2019 mode and then :wq to save and exit the editor. If you decide you do not want to save your changes, instead type :q! while in \u2018command mode\u2019. When you are in \u2018command\u2019 mode, typing dd will delete the whole line your cursor is on. Nano You may need to install it first. ( sudo apt-get install nano ) Start with nano <filename> to open a file for editing. The file will be created if it does not exist before. Ctrl-x will exit the editor, asking first if you want to save the file. If you started with just nano and did not give a filename, it will ask you for a name. Windows \u00b6 Using notepad: if you are using a newer version of Git, then you should be able to choose to install/use notepad during the Git install. git config --global core.editor notepad Otherwise, you need to give the full path to notepad on your system git config --global core.editor \"<path-to>\\notepad++.exe\" Example: git config --global core-editor \"C:\\Program Files (x86)\\Notepad++\\notepad++.exe\" Using vim: this is easy as it can be installed during the Git install and then setting it with git config --global core.editor vim Various OS \u00b6 GitHub has a page for setting some editors for various OS\u2019es: https://docs.github.com/en/get-started/getting-started-with-git/associating-text-editors-with-git . GitHub CLI \u00b6 GitHub also has a command line interface that you can use if you want to. It is available for Windows, macOS, and Linux. You can use it if you prefer to do your workflow through a terminal, and you can call the GitHub API to script various actions as well as set a custom alias for any command. More information and download here: https://cli.github.com/ https://github.blog/2020-09-17-github-cli-1-0-is-now-available/","title":"Setup"},{"location":"setup/#lecture__0__setup","text":"","title":"Lecture 0: Setup"},{"location":"setup/#installing__and__setting__up__git","text":"We will use Git from the command line in this course. This is normally how you will use it on the various HPC centers, and this way it will also be easier to understand what is going on while you are learning to use Git. On Windows, this means you will be using Git Bash. Graphical tools exists for Git, see below list for a few. All entries on the list are free and unless otherwise mentioned, available for Windows, macOS, and Linux: git-scm (https://git-scm.com) comes with a basic GUI Git Kraken (https://www.gitkraken.com/) Github Desktop (https://desktop.github.com/) Windows and macOS only Sourcetree (https://www.sourcetreeapp.com/) Windows and macOS only TortoiseGit (https://tortoisegit.org/) Windows only Install Git, if you have not already Create a repository with git init Set your name and email with git config (local, global, system). More info in a moment. Test by creating a file Then adding the file with git add Then commiting the file with git commit Check with git log that all looks well. When this is done, you will clone the course materials. NOTE : if you have a problem getting this to work on your own computer, and you have an account at Tetralith or any other HPC system, then you can use that instead. We have some documentation for you for Tetralith: Using Tetralith for the Git course As mentioned, you may also use any other HPC system you have an account at, of course. The above documentation would need only minor adjustements.","title":"Installing and setting up Git"},{"location":"setup/#git__install__-__windows","text":"Go to the Git-scm website ( https://git-scm.com/downloads ) and click \u201cWindows\u201d to download the Windows version. It should automatically start download of the .exe file. The downloaded file can be installed by double-clicking and choosing \u201cRun\u201d. Click \u201cYes\u201d to let it be installed and then \u201cNext\u201d to accept the GNU GPL. The default options you are presented with should work, and we recommend using those. You will be using Git Bash for this course NOTE: when it comes to choosing the default editor, we recommend using either notepad or vim, unless you have a preferred editor. See the section on \u201cConfigure git\u201d as well as the section on editors at the end of this document for some help.","title":"Git install - Windows"},{"location":"setup/#git__install__-__macos","text":"If you have installed XCode (or its Command Line Tools), Git may already be installed. To find out, open a terminal and enter git --version . If Git is not installed, you have several installation options. Apple maintains their own fork of Git, but it is usually a few versions behind, so we do not recommend installing that. SourceForge: https://sourceforge.net/projects/git-osx-installer/files/ Git-scm.com: https://git-scm.com/downloads If you have Homebrew: brew install git","title":"Git install - macOS"},{"location":"setup/#git__install__-__linux","text":"Git is usually already installed on Linux, but if not, this is how you install it. Installing Git on Linux depends on which distro you are running. sudo apt-get install git (Ubuntu, Debian) sudo dnf install git (RHEL, CentOS) https://git-scm.com/download/linux (other)","title":"Git install - Linux"},{"location":"setup/#git__install__-__primary__branch","text":"The primary branch will probably be named \u201cmaster\u201d when installing Git. You can choose if you want to instead name it \u201cmain\u201d (which is what GitHub uses as default). Regardless of which you pick, stick to one to avoid problems when pushing a repo You can change the naming of the primary branch in GitHub for a repo Go to repo Pick \u201cSettings\u201d -> \u201cGeneral\u201d Change the name in \u201cDefault branch\u201d Instructions how to rename the primary branch in a repo from \u201cmaster\u201d to \u201cmain\u201d on the command line: https://gist.github.com/danieldogeanu/739f88ea5312aaa23180e162e3ae89ab","title":"Git install - primary branch"},{"location":"setup/#configure__git__all__os","text":"First check that you have git installed (in a terminal or in Git Bash): $ git --version Now configure git with git config (local, global, system) You should at least set your global name and email (just once): $ git config --global user.name \"Your Name\" $ git config --global user.email \"yourname@example.com\" Setting the editor (once) is also a good idea: $ git config --global core.editor <editor> Choices for editor could be (on Linux, though can be installed together with Git for other OS): * nano * vim * emacs You should be able to use notepad on Windows by setting: git config --global core.editor \"<path-to>/notepad++.exe\" Another option could be to install VS Code and do this config instead: git config --global core.editor \"code --wait\" GitHub has some documentation on choosing and setting editors for various OS: https://docs.github.com/en/get-started/getting-started-with-git/associating-text-editors-with-git See more about configuring and using editors with Git at the end of this document.","title":"Configure git (all OS)"},{"location":"setup/#test__your__git__installation","text":"Create an example folder and change to that, then create a file test.txt. On Linux you would do this: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and stage the new file: $ git init Initialized empty Git repository in /home/bbrydsoe/test-git/.git/ $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message : $ git commit test.txt [ master ( root-commit ) ff8b6f6 ] Test of git 1 file changed, 0 insertions ( + ) , 0 deletions ( - ) create mode 100644 test.txt Now let us look at the log: $ git log commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git When you do git log , you should see something like the above, but with name, email, date, and commit message different. If that is the case, your Git should be configured correctly.","title":"Test your Git installation"},{"location":"setup/#download__the__course__materials","text":"For the individual hands-on part of the course, we have created some course materials which you will download from the course GitHub repo: https://github.com/hpc2n/course-intro-git (normally you click the green \u201cCode\u201d button to get the link to clone or download) Please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Do one of : git clone https://github.com/hpc2n/course-intro-git.git Download the zipfile (directly with wget https://github.com/hpc2n/course-intro-git/archive/refs/heads/main.zip or elsewhere then transfer) and unzip. You can also get the link from the course GitHub repo: https://github.com/hpc2n/course-intro-git .","title":"Download the course materials"},{"location":"setup/#web__based__git__repositories","text":"There are several web based Git repositories. Some of the more popular ones are: GitHub ( https://github.com/ ) GitLab ( https://www.gitlab.com ) Bitbucket ( https://bitbucket.org ) SourceForge ( https://sourceforge.net/ )","title":"Web based Git repositories"},{"location":"setup/#github","text":"We are going to use GitHub for the part of the hands-on where you will be working together in groups. Please go to https://github.com/ and sign up for an account, if you do not already have one. You will need to setup 2FA also.","title":"GitHub"},{"location":"setup/#create__a__new__ssh__key__for__github","text":"","title":"Create a new SSH key for GitHub"},{"location":"setup/#linux__and__macos","text":"This part will be done before the section \u201cWorking with remotes\u201d on day 4, but you can create and add your SSH key to GitHub now if you want to. Open a terminal. In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name for the new systems - change to what your key was called ( .ssh/id_rsa for the legacy system): $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_ed25519 Switch to the .ssh folder, open the file id_ed25519.pub with some editor and copy it ( id_rsa for legacy systems). Do NOT add any newlines or whitespace!","title":"Linux and macOS"},{"location":"setup/#windows","text":"This part will be done during the exercises on day 5, but you can create and add your SSH key to GitHub now if you want to. Open Git Bash. In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name for the new systems - change to what your key was called ( .ssh/id_rsa for the legacy system): $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_ed25519 Switch to the .ssh folder, with some editor, open the file id_ed25519.pub (or id_rsa.pub for the legacy systems) and copy it. Do NOT add any newlines or whitespace!","title":"Windows"},{"location":"setup/#adding__the__ssh__key__to__github","text":"On GitHub, click your avatar in the top right corner and pick \u201cSettings\u201d. Choose \u201cSSH and GPG keys\u201d Click the green button labeled \u201cNew SSH key\u201d Add a descriptive label for the key in the \u201cTitle\u201d field. In the key field you paste the content of the key (~/.ssh/id_rsa.pub) Click \u201cAdd SSH key\u201d Confirm your GitHub password if you are prompted for it.","title":"Adding the SSH key to GitHub"},{"location":"setup/#testing__the__ssh__keys","text":"Open a terminal / the Git bash $ ssh -T git@github.com It will look similar to this: $ ssh -T git@github.com The authenticity of host 'github.com (140.82.121.3)' can't be established. ECDSA key fingerprint is SHA256:p2QAMXNIC1TJYWeIOttrVc98/R1BUFWu3/LiyKgUfQM. ECDSA key fingerprint is MD5:7b:99:81:1e:4c:91:a5:0d:5a:2e:2e:80:13:3f:24:ca. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,140.82.121.3' (ECDSA) to the list of known hosts. Hi bbrydsoe! You've successfully authenticated, but GitHub does not provide shell access. Verify that the resulting message contains your username.","title":"Testing the SSH keys"},{"location":"setup/#more__on__editors","text":"","title":"More on editors"},{"location":"setup/#linux","text":"Vim You may need to install it first. ( sudo apt-get install vim ) Start with vim <filename> to open a file for editing. The file will be created if it does not exist before. Type i to enter \u2018insert\u2019 mode to be able to write in the editor. Use ESC to go to \u2018command\u2019 mode and then :wq to save and exit the editor. If you decide you do not want to save your changes, instead type :q! while in \u2018command mode\u2019. When you are in \u2018command\u2019 mode, typing dd will delete the whole line your cursor is on. Nano You may need to install it first. ( sudo apt-get install nano ) Start with nano <filename> to open a file for editing. The file will be created if it does not exist before. Ctrl-x will exit the editor, asking first if you want to save the file. If you started with just nano and did not give a filename, it will ask you for a name.","title":"Linux"},{"location":"setup/#windows_1","text":"Using notepad: if you are using a newer version of Git, then you should be able to choose to install/use notepad during the Git install. git config --global core.editor notepad Otherwise, you need to give the full path to notepad on your system git config --global core.editor \"<path-to>\\notepad++.exe\" Example: git config --global core-editor \"C:\\Program Files (x86)\\Notepad++\\notepad++.exe\" Using vim: this is easy as it can be installed during the Git install and then setting it with git config --global core.editor vim","title":"Windows"},{"location":"setup/#various__os","text":"GitHub has a page for setting some editors for various OS\u2019es: https://docs.github.com/en/get-started/getting-started-with-git/associating-text-editors-with-git .","title":"Various OS"},{"location":"setup/#github__cli","text":"GitHub also has a command line interface that you can use if you want to. It is available for Windows, macOS, and Linux. You can use it if you prefer to do your workflow through a terminal, and you can call the GitHub API to script various actions as well as set a custom alias for any command. More information and download here: https://cli.github.com/ https://github.blog/2020-09-17-github-cli-1-0-is-now-available/","title":"GitHub CLI"},{"location":"teamwork-exercises/","text":"Exercises - Teamwork \u00b6 1. Setting up a repository on GitHub \u00b6 Note In this exercise you will create a repository on GitHub and work with that. You will be working on the GitHub website (so you need to have signed up for an account). Create a repository (click on the + at the top right of the menu or picking \u201cStart a new repository\u201d on your \u201chome screen\u201d) Under \u201cQuick setup\u201d, pick \u201ccreating a new file\u201d. Name the file \u201cREADME.md\u201d (at the top, over the file editor). Put some text in the file \u201cREADME.md\u201d. At the bottom, where it says \u201cCommit new file\u201d you should put a useful commit message. Then click \u201cCommit new file\u201d Notice: the content of README.md appears at top level of the repo Try creating another file in a subdirectory (create subdirectories by adding the name you want after the name of your repo, then adding a \u201c/\u201d and your filename). Try adding a file that you have created on your computer and uploads (Add file -> Upload files) Test out making edits to your files and committing them - all through the GitHub site. If you put a file \u201cREADME.md\u201d in a subdirectory then it will be shown as a \u201cdescription\u201d for the directory When you have made some commits, try click \u201ccommits\u201d above the files in the repo and see a list of your commits. 2. Creating and using SSH-keys \u00b6 Warning Only do this if you did not do that earlier in the week/before! Note In this exercise you create SSH keys and upload to GitHub. Then test that it works. Everyone in the team should do this! Create a new SSH key Open a terminal (Git Bash on Windows). In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name: $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_rsa Switch to the .ssh folder, open the file id_rsa.pub and copy it. Do NOT add any newlines or whitespace! Adding the SSH key to GitHub On GitHub, click your avatar in the top right corner and pick \u201cSettings\u201d. Choose \u201cSSH and GPG keys\u201d Click \u201cAdd new SSH key\u201d Add a descriptive label for the key in the \u201cTitle\u201d field. In the key field you paste the content of the key (~/.ssh/id_rsa.pub) Click \u201cAdd SSH key\u201d Confirm your GitHub password if you are prompted for it. Testing the SSH keys Open a terminal (or Git Bash) $ ssh -T git@github.com It will look similar to this: $ ssh -T git@github.com The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa': Hi bbrydsoe! You've successfully authenticated, but GitHub does not provide shell access. Verify that the resulting message contains your username. NOTE: Optionally, you could run ssh-add to add the key. Then you will only be asked for the passphrase once per session. This is relatively safe on Linux and macOS, but not on Windows where it usually saves the key passphrase permanently. 3. clone, push, pull \u00b6 Note We now have SSH keys set up. Time to test it from your own machine Clone the repository, using the SSH address (click \u201cCODE\u201d on the GitHub repository and pick \u201cSSH\u201d). You will be asked for the key passphrase. Enter the local repository. Do a git pull and see that it works. You will have to enter the key passphrase. Create a file (or edit a file). Add the file. Commit the file ( git add , git commit ) Push the file. Again it will ask for the key passphrase. Success! NOTE: Optionally, you could run ssh-add to add the key. Then you will only be asked for the passphrase once per session. This is relatively safe on Linux and macOS, but not on Windows where it usually saves the key passphrase permanently. 4. Teamwork, push and pull \u00b6 Note One of you should create a repository on GitHub and invite their team. Remember, on the GitHub webpage the option to create a new repository is in the top right corner - click the \u201c+\u201d. To add members: \u201cSettings\u201d -> \u201cManage access\u201d. Each person should create a file in the repository (Add and commit the file) On the command line, do a git status . Do a git log --graph --oneline --decorate --all NOTE! To avoid errors, do git pull before you stage and commit your file and also the team members should use different names for their files. See the changes appear when you do a git pull after all have added their file(s). You could also try to push a new change before pulling the changes your team members have made. Git will complain, but you should be able to solve this kind of simple problem with git pull --rebase before you re-do git push Try create more files then add and commit. Do git status and git log --graph --oneline --decorate --all before and after each step. Push the files to the repository. Check the log and status again. NOTE: You will be asked for the key passphrase each time you do a push 5. Teamwork, branches and merging \u00b6 Each person creates a branch in the repo you created in the previous exercise. You can use git branch yourbranchname where you put any name you want for the new branch. Switch to the new branch with git checkout yourbranchname Create a uniquely named file. Put anything you want in it. Do git log and git status to see any changes. Stage and commit the file. Check again with git log and git status Push your changes with git push origin -u yourbranchname (or with git push -u origin HEAD for a fast way when using the same name) When everyone has done this, all do a git pull Use git status , git branch , and git log to see what has happened. 6. Teamwork, branches and merging, pull requests \u00b6 (Members) Go to the repository you have worked in on the GitHub page. Submit a pull-request from your branch to the main branch (Owner) The owner of the repository (the person who created it) can then accept them and click to merge them. After doing so, everyone should again do a git pull (on the command line) Use git status , git branch --all , and git log --graph --oneline --decorate --all to see what has happened. Note : It is possible to make the main branch \u201cprotected\u201d so it is not changed without a review from the owner. Try doing this (on GitHub). 7. Teamwork and branches \u00b6 Note Now you will be creating a new branch in the repo your group is sharing, but you will create in from the GitHub page Everyone in the group create a new branch in the repo - this time you could try doing it from the GitHub page Now you are working on the command line Check which remote branches exist with git branch -r Check which local branches you have with git branch Use git status to see which branch you are on. Check with git branch -a to see all local and remote branches Do a git pull from the command line to get a list of all branches. Switch to the branch you created on GitHub with git checkout --track origin/mynewbranch . Again do git branch to see which branch you are on. Create a new file and put some content to it. Add and commit it. Check for changes ( git status , git log ). Push the changes. Try and merge the branches from the command line. Remember to first pull any changes from your other group members. Also remember to switch to the branch you want to merge it to (main in this case). Were you succesful? Why or why not? Is there are difference between what happens when the owner of the branch tries this and when everyone else does? After doing this, everyone should again do a git pull (on the command line) Use git status , git branch , and git log to see what has happened. If you want a \u201cprettier\u201d and sometimes easier to read view, use git log --graph --oneline --decorate --all 8. Deleting branches \u00b6 Everyone should now create two more branches in the repo. In each case, switch to the branch, create a file in it, and push the branch. (You could try this both on the command line and in the web repo on GitHub) Check which branches exist, remotely and locally (on the command line) Try and delete a remote branch with git push origin --delete myownbranch (on the command line) Try delete a local branch with git branch -D <alsomyownbranch> (on the command line) On the command line, do a git status , git log and git branch to see what has happened The branch you deleted locally is still on the repo. Get another copy of it ( git pull and git fetch , possibly with suitable flags will get it back for you - this is again done on the command line) 9. Merge conflicts \u00b6 Note In this exercise everyone in the team will be working in the same branch, for instance the main branch. Merge conflicts generally happen when two (or more) teammembers edit the same file and the same line, or when one edits a file and another deletes it. (One in the team do this) Create a new repository on GitHub. Add your team members as in the previous exercises. Everyone clones the repository (from the command line). Create a couple files. Add, commit, and push. If more than one person creates files, remember to either pull your teammates work first, or do a git pull --rebase before pushing. After doing this, everyone should again do a git pull Now one or more of the team members make changes to the same file, in the same line. Add, commit, push. Did you get a conflict? Use git status , git branch , and git log to see what has happened. Try to resolve the conflict. Now again all will work on one file. One or more will edit it and one deletes it ( git rm file ). What happens when you push your work? You should get a conflict. Try and resolve the conflict you got. Should the file be kept or deleted?","title":"Teamwork"},{"location":"teamwork-exercises/#exercises__-__teamwork","text":"","title":"Exercises - Teamwork"},{"location":"teamwork-exercises/#1__setting__up__a__repository__on__github","text":"Note In this exercise you will create a repository on GitHub and work with that. You will be working on the GitHub website (so you need to have signed up for an account). Create a repository (click on the + at the top right of the menu or picking \u201cStart a new repository\u201d on your \u201chome screen\u201d) Under \u201cQuick setup\u201d, pick \u201ccreating a new file\u201d. Name the file \u201cREADME.md\u201d (at the top, over the file editor). Put some text in the file \u201cREADME.md\u201d. At the bottom, where it says \u201cCommit new file\u201d you should put a useful commit message. Then click \u201cCommit new file\u201d Notice: the content of README.md appears at top level of the repo Try creating another file in a subdirectory (create subdirectories by adding the name you want after the name of your repo, then adding a \u201c/\u201d and your filename). Try adding a file that you have created on your computer and uploads (Add file -> Upload files) Test out making edits to your files and committing them - all through the GitHub site. If you put a file \u201cREADME.md\u201d in a subdirectory then it will be shown as a \u201cdescription\u201d for the directory When you have made some commits, try click \u201ccommits\u201d above the files in the repo and see a list of your commits.","title":"1. Setting up a repository on GitHub"},{"location":"teamwork-exercises/#2__creating__and__using__ssh-keys","text":"Warning Only do this if you did not do that earlier in the week/before! Note In this exercise you create SSH keys and upload to GitHub. Then test that it works. Everyone in the team should do this! Create a new SSH key Open a terminal (Git Bash on Windows). In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name: $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_rsa Switch to the .ssh folder, open the file id_rsa.pub and copy it. Do NOT add any newlines or whitespace! Adding the SSH key to GitHub On GitHub, click your avatar in the top right corner and pick \u201cSettings\u201d. Choose \u201cSSH and GPG keys\u201d Click \u201cAdd new SSH key\u201d Add a descriptive label for the key in the \u201cTitle\u201d field. In the key field you paste the content of the key (~/.ssh/id_rsa.pub) Click \u201cAdd SSH key\u201d Confirm your GitHub password if you are prompted for it. Testing the SSH keys Open a terminal (or Git Bash) $ ssh -T git@github.com It will look similar to this: $ ssh -T git@github.com The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa': Hi bbrydsoe! You've successfully authenticated, but GitHub does not provide shell access. Verify that the resulting message contains your username. NOTE: Optionally, you could run ssh-add to add the key. Then you will only be asked for the passphrase once per session. This is relatively safe on Linux and macOS, but not on Windows where it usually saves the key passphrase permanently.","title":"2. Creating and using SSH-keys"},{"location":"teamwork-exercises/#3__clone__push__pull","text":"Note We now have SSH keys set up. Time to test it from your own machine Clone the repository, using the SSH address (click \u201cCODE\u201d on the GitHub repository and pick \u201cSSH\u201d). You will be asked for the key passphrase. Enter the local repository. Do a git pull and see that it works. You will have to enter the key passphrase. Create a file (or edit a file). Add the file. Commit the file ( git add , git commit ) Push the file. Again it will ask for the key passphrase. Success! NOTE: Optionally, you could run ssh-add to add the key. Then you will only be asked for the passphrase once per session. This is relatively safe on Linux and macOS, but not on Windows where it usually saves the key passphrase permanently.","title":"3. clone, push, pull"},{"location":"teamwork-exercises/#4__teamwork__push__and__pull","text":"Note One of you should create a repository on GitHub and invite their team. Remember, on the GitHub webpage the option to create a new repository is in the top right corner - click the \u201c+\u201d. To add members: \u201cSettings\u201d -> \u201cManage access\u201d. Each person should create a file in the repository (Add and commit the file) On the command line, do a git status . Do a git log --graph --oneline --decorate --all NOTE! To avoid errors, do git pull before you stage and commit your file and also the team members should use different names for their files. See the changes appear when you do a git pull after all have added their file(s). You could also try to push a new change before pulling the changes your team members have made. Git will complain, but you should be able to solve this kind of simple problem with git pull --rebase before you re-do git push Try create more files then add and commit. Do git status and git log --graph --oneline --decorate --all before and after each step. Push the files to the repository. Check the log and status again. NOTE: You will be asked for the key passphrase each time you do a push","title":"4. Teamwork, push and pull"},{"location":"teamwork-exercises/#5__teamwork__branches__and__merging","text":"Each person creates a branch in the repo you created in the previous exercise. You can use git branch yourbranchname where you put any name you want for the new branch. Switch to the new branch with git checkout yourbranchname Create a uniquely named file. Put anything you want in it. Do git log and git status to see any changes. Stage and commit the file. Check again with git log and git status Push your changes with git push origin -u yourbranchname (or with git push -u origin HEAD for a fast way when using the same name) When everyone has done this, all do a git pull Use git status , git branch , and git log to see what has happened.","title":"5. Teamwork, branches and merging"},{"location":"teamwork-exercises/#6__teamwork__branches__and__merging__pull__requests","text":"(Members) Go to the repository you have worked in on the GitHub page. Submit a pull-request from your branch to the main branch (Owner) The owner of the repository (the person who created it) can then accept them and click to merge them. After doing so, everyone should again do a git pull (on the command line) Use git status , git branch --all , and git log --graph --oneline --decorate --all to see what has happened. Note : It is possible to make the main branch \u201cprotected\u201d so it is not changed without a review from the owner. Try doing this (on GitHub).","title":"6. Teamwork, branches and merging, pull requests"},{"location":"teamwork-exercises/#7__teamwork__and__branches","text":"Note Now you will be creating a new branch in the repo your group is sharing, but you will create in from the GitHub page Everyone in the group create a new branch in the repo - this time you could try doing it from the GitHub page Now you are working on the command line Check which remote branches exist with git branch -r Check which local branches you have with git branch Use git status to see which branch you are on. Check with git branch -a to see all local and remote branches Do a git pull from the command line to get a list of all branches. Switch to the branch you created on GitHub with git checkout --track origin/mynewbranch . Again do git branch to see which branch you are on. Create a new file and put some content to it. Add and commit it. Check for changes ( git status , git log ). Push the changes. Try and merge the branches from the command line. Remember to first pull any changes from your other group members. Also remember to switch to the branch you want to merge it to (main in this case). Were you succesful? Why or why not? Is there are difference between what happens when the owner of the branch tries this and when everyone else does? After doing this, everyone should again do a git pull (on the command line) Use git status , git branch , and git log to see what has happened. If you want a \u201cprettier\u201d and sometimes easier to read view, use git log --graph --oneline --decorate --all","title":"7. Teamwork and branches"},{"location":"teamwork-exercises/#8__deleting__branches","text":"Everyone should now create two more branches in the repo. In each case, switch to the branch, create a file in it, and push the branch. (You could try this both on the command line and in the web repo on GitHub) Check which branches exist, remotely and locally (on the command line) Try and delete a remote branch with git push origin --delete myownbranch (on the command line) Try delete a local branch with git branch -D <alsomyownbranch> (on the command line) On the command line, do a git status , git log and git branch to see what has happened The branch you deleted locally is still on the repo. Get another copy of it ( git pull and git fetch , possibly with suitable flags will get it back for you - this is again done on the command line)","title":"8. Deleting branches"},{"location":"teamwork-exercises/#9__merge__conflicts","text":"Note In this exercise everyone in the team will be working in the same branch, for instance the main branch. Merge conflicts generally happen when two (or more) teammembers edit the same file and the same line, or when one edits a file and another deletes it. (One in the team do this) Create a new repository on GitHub. Add your team members as in the previous exercises. Everyone clones the repository (from the command line). Create a couple files. Add, commit, and push. If more than one person creates files, remember to either pull your teammates work first, or do a git pull --rebase before pushing. After doing this, everyone should again do a git pull Now one or more of the team members make changes to the same file, in the same line. Add, commit, push. Did you get a conflict? Use git status , git branch , and git log to see what has happened. Try to resolve the conflict. Now again all will work on one file. One or more will edit it and one deletes it ( git rm file ). What happens when you push your work? You should get a conflict. Try and resolve the conflict you got. Should the file be kept or deleted?","title":"9. Merge conflicts"},{"location":"teamwork/","text":"Lecture 7: Teamwork \u00b6 Teamwork \u00b6 Git is very useful for teamwork. You will often have three types of branches for a project/specific release: main (or master) branch exist for the entire project development/staging branch developing, preparing new releases exists for the entire release of the project, then merged to main (master) feature branch(es) created just for the feature development later merged to development/staging branch NOTE: GitHub previously used \u201cmaster\u201d, but is now using \u201cmain\u201d as the name for the first/default branch in a repo. This can be changed under the repo\u2019s settings. In this session you will be working in small groups of 2-4 people. Each group will go to a Zoom break-out room and work together there. You will be using GitHub for the remote repository. Since GitHub no longer allows you to use username and password unless you are working directly on the site, you will set up and use SSH keys. First you will look around GitHub a little and try creating a repository there, as well as creating and editing a file on the site. The rest of the exercises will be about working together on a small project, and will be done from the command line with GitHub as the remote repository. There will be nine exercises in total in this part. Concepts and commands \u00b6 In these exercises we will use only a few commands. These have all been mentioned before in this course, but as a refresher I will briefly discuss a couple commands here, namely: git fetch : This is a primary command used to download contents from a remote repository. example: your teammate has created a new feature branch which they have pushed to the remote repository, but which you do not yet have in your local repository git push : This is essentially the same as running git merge main from inside the remote repository. It is mostly used to upload local changes to a remote repository. git pull : This will fetch the latest changes from the current branch from a remote, then apply the changes to your local copy of the branch. It is similar to doing a fetch and a merge. Git push \u00b6 $ git push <remote-repo> <branch> or in some cases just $ git push where the default behaviour is pushing to repository \u201corigin\u201d and the same branch as the local. Before pushing: graph LR A((\"Anode\")) style A fill:#ffffff,stroke:#000000,color:#ffffff origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:#000000 B((\"Bnode\")) style B fill:#ffffff,stroke:#000000,color:#ffffff C((\"Cnode\")) style C fill:#ffffff,stroke:#000000,color:#ffffff main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 D((\"Dnode\")) style D fill:#305cde,stroke:#000000,color:#305cde A --- B origin -.-> B B --- C C --- D main -.-> D After pushing: graph LR A((\"Anode\")) style A fill:#ffffff,stroke:#000000,color:#ffffff origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:#000000 B((\"Bnode\")) style B fill:#ffffff,stroke:#000000,color:#ffffff C((\"Cnode\")) style C fill:#ffffff,stroke:#000000,color:#ffffff main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 D((\"Dnode\")) style D fill:#305cde,stroke:#000000,color:#305cde A --- B origin -.-> D B --- C C --- D main -.-> D Pushing a staged and committed file: bbrydsoe@enterprise-a:~/mytestrepo$ git push origin main Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa' : Enumerating objects: 5 , done . Counting objects: 100 % ( 5 /5 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 2 /2 ) , done . Writing objects: 100 % ( 3 /3 ) , 287 bytes | 287 .00 KiB/s, done . Total 3 ( delta 1 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To github.com:bbrydsoe/mytestrepo.git 43110f8..5fd2960 main -> main bbrydsoe@enterprise-a:~/mytestrepo$ git log commit 5fd2960d91a86f8c581d7470b42b1f3814e24d73 ( HEAD -> main, origin/main, origin/HEAD ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Sun Nov 13 15 :43:05 2022 +0100 Adding a file Git pull \u00b6 Fetch the given remote\u2019s copy of the current branch and merge to the local copy: $ git pull <remote-repo> or often just $ git pull Hint \u00b6 If you have forgotten to pull before staging and committing new stuff, and your colleague has added something to the remote repository in between, this is a handy command: $ git pull --rebase <remote> It fetches the remote content but does not create a new merge commit. Assume this situation: graph LR d((\"d\")) style d fill:#ffffff,stroke:#000000,color:#000000 e((\"e\")) style e fill:#ffffff,stroke:#000000,color:#000000 origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:#000000 d --- e origin -.-> e a((\"a\")) style a fill:#ffffff,stroke:#000000,color:#000000 f((\"f\")) style f fill:#ffffff,stroke:#000000,color:#000000 e --- a e --- f b((\"b\")) style b fill:#ffffff,stroke:#000000,color:#000000 g((\"g\")) style g fill:#ffffff,stroke:#000000,color:#000000 main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 c((\"c\")) style c fill:#ffffff,stroke:#000000,color:#000000 a --- b f --- g b --- c main -.-> c Now we do a git pull : graph LR d((\"d\")) style d fill:#ffffff,stroke:#000000,color:#000000 e((\"e\")) style e fill:#ffffff,stroke:#000000,color:#000000 origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:000000 d --- e a((\"a\")) style a fill:#ffffff,stroke:#000000,color:#000000 f((\"f\")) style f fill:#ffffff,stroke:#000000,color:#000000 e --- a e --- f b((\"b\")) style b fill:#ffffff,stroke:#000000,color:#000000 g((\"g\")) style g fill:#ffffff,stroke:#000000,color:#000000 main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 c((\"c\")) style c fill:#ffffff,stroke:#000000,color:#000000 h((\"h\")) style h fill:#ffffff,stroke:#000000,color:#000000 a --- b f --- g b --- c origin -.-> c main -.-> c c --- h g --- h Pull from remote repo, new file \u00b6 Let us do an example where there is a new file on the remote repository: $ git pull remote: Enumerating objects: 4 , done . remote: Counting objects: 100 % ( 4 /4 ) , done . remote: Compressing objects: 100 % ( 2 /2 ) , done . Unpacking objects: 100 % ( 3 /3 ) , done . remote: Total 3 ( delta 0 ) , reused 0 ( delta 0 ) , pack-reused 0 From github.com:bbrydsoe/testrepo 55f35b9..e6ca68c main -> origin/main Updating 55f35b9..e6ca68c Fast-forward newfile.txt | 1 + 1 file changed, 1 insertion ( + ) create mode 100644 newfile.txt Example: creating a new branch, pushing changes \u00b6 Here we create a new branch on a remote repository and add a file to it, then push: Create the branch bbrydsoe@enterprise-a:~/mytestrepo$ git branch mynewbranch bbrydsoe@enterprise-a:~/mytestrepo$ Switch to it bbrydsoe@enterprise-a:~/mytestrepo$ git checkout mynewbranch Switched to branch 'mynewbranch' bbrydsoe@enterprise-a:~/mytestrepo$ I then create a file on my new branch. After this, check the status and log bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch mynewbranch Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: myfile.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) bbrydsoe@enterprise-a:~/mytestrepo$ git log --graph --oneline --decorate --all * accef46 ( HEAD -> mynewbranch, main ) Updating the file funny.txt * 43110f8 ( origin/main, origin/HEAD ) Update funny.txt * af9e1cb Create Weird.txt * db2e945 Create funny.txt * c74b74c Adding the file file4.txt * 805d9b3 Create newfile.txt * c8e5214 Adding some files to play with for the exercise. * 1c8156d ( origin/mytestbranch, mytestbranch ) Adding testfile.txt to mytestbranch * 333d5e5 Merge pull request #2 from bbrydsoe/birgittesbranch | \\ | * 92901fa ( origin/birgittesbranch, birgittesbranch ) Adding my new file to my new branch. * | e7741d8 Merge pull request #1 from bbrydsoe/spocksbranch | \\ \\ | | / | / | | * 6814eb4 ( origin/spocksbranch ) Added a file by user spock | / * d4a666e Adding my new file to the repository. * 303bf63 Create README.md bbrydsoe@enterprise-a:~/mytestrepo$ Note: when you do this it should be coloured for easier readability I stage and commit the file. bbrydsoe@enterprise-a:~/mytestrepo$ git add myfile.txt bbrydsoe@enterprise-a:~/mytestrepo$ git commit -m \" Adding a file to my new branch\" [ mynewbranch c997da0 ] Adding a file to my new branch 1 file changed, 1 insertion ( + ) I will check to confirm I am on the right branch: bbrydsoe@enterprise-a:~/mytestrepo$ git branch birgittesbranch main * mynewbranch mytestbranch bbrydsoe@enterprise-a:~/mytestrepo$ Let us again check with git status and git log ... bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch mynewbranch nothing to commit, working tree clean bbrydsoe@enterprise-a:~/mytestrepo$ bbrydsoe@enterprise-a:~/mytestrepo$ git log --graph --oneline --decorate --all * c997da0 ( HEAD -> mynewbranch ) Adding a file to my new branch * accef46 ( main ) Updating the file funny.txt * 43110f8 ( origin/main, origin/HEAD ) Update funny.txt * af9e1cb Create Weird.txt * db2e945 Create funny.txt * c74b74c Adding the file file4.txt * 805d9b3 Create newfile.txt * c8e5214 Adding some files to play with for the exercise. * 1c8156d ( origin/mytestbranch, mytestbranch ) Adding testfile.txt to mytestbranch * 333d5e5 Merge pull request #2 from bbrydsoe/birgittesbranch | \\ | * 92901fa ( origin/birgittesbranch, birgittesbranch ) Adding my new file to my new branch. * | e7741d8 Merge pull request #1 from bbrydsoe/spocksbranch | \\ \\ | | / | / | | * 6814eb4 ( origin/spocksbranch ) Added a file by user spock | / * d4a666e Adding my new file to the repository. * 303bf63 Create README.md bbrydsoe@enterprise-a:~/mytestrepo$ Push your changes with git push origin -u yourbranchname (or with git push -u origin HEAD ) bbrydsoe@enterprise-a:~/mytestrepo$ git push -u origin HEAD Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa' : Enumerating objects: 9 , done . Counting objects: 100 % ( 9 /9 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 5 /5 ) , done . Writing objects: 100 % ( 6 /6 ) , 619 bytes | 619 .00 KiB/s, done . Total 6 ( delta 2 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 2 /2 ) , completed with 1 local object. remote: remote: Create a pull request for 'mynewbranch' on GitHub by visiting: remote: https://github.com/bbrydsoe/mytestrepo/pull/new/mynewbranch remote: To github.com:bbrydsoe/mytestrepo.git * [ new branch ] HEAD -> mynewbranch Branch 'mynewbranch' set up to track remote branch 'mynewbranch' from 'origin' . bbrydsoe@enterprise-a:~/mytestrepo$ Let us check the status bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch mynewbranch Your branch is up-to-date with 'origin/mynewbranch' . nothing to commit, working tree clean bbrydsoe@enterprise-a:~/mytestrepo$ Example: Merging branches \u00b6 We will merge the branches from the command line. Let us first see which branches exist in my repo - in this case I will check for both local and remote branches bbrydsoe@enterprise-a:~/mytestrepo$ git branch --all birgittesbranch main * mynewbranch mytestbranch remotes/origin/HEAD -> origin/main remotes/origin/birgittesbranch remotes/origin/main remotes/origin/mynewbranch remotes/origin/mytestbranch remotes/origin/spocksbranch I have a bunch of branches (created previously by me and another user, for testing). As you can see, I am on my newest branch \u201cmynewbranch\u201d Switch to the branch we are merging to (main) bbrydsoe@enterprise-a:~/mytestrepo$ git checkout main Switched to branch 'main' Your branch is up-to-date with 'origin/main' . bbrydsoe@enterprise-a:~/mytestrepo$ Do the merge (it will also open an editor where you should write a commit message for why the merge should happen) git merge mynewbranch Merge made by the 'recursive' strategy. myfile.txt | 1 + 1 file changed, 1 insertion ( + ) Let us do a status check bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch main Your branch is ahead of 'origin/main' by 2 commits. ( use \"git push\" to publish your local commits ) nothing to commit, working tree clean Pushing bbrydsoe@enterprise-a:~/mytestrepo$ git push Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa' : Enumerating objects: 4 , done . Counting objects: 100 % ( 4 /4 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 2 /2 ) , done . Writing objects: 100 % ( 2 /2 ) , 303 bytes | 303 .00 KiB/s, done . Total 2 ( delta 1 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To github.com:bbrydsoe/mytestrepo.git 5fd2960..2032676 main -> main Checking status again bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch main Your branch is up-to-date with 'origin/main' . nothing to commit, working tree clean First exercise - GitHub (if not setup already) \u00b6 Create a repository (click on the + at the top right of the menu or picking \u201cStart a new repository\u201d on your \u201chome screen\u201d) Under \u201cQuick setup\u201d, pick \u201ccreating a new file\u201d. Name the file \u201cREADME.md\u201d (at the top, over the file editor). Put some text in the file \u201cREADME.md\u201d. At the bottom, where it says \u201cCommit new file\u201d you should put a useful commit message. Then click \u201cCommit new file\u201d Notice: the content of README.md appears at top level of the repo Try creating another file in a subdirectory (create subdirectories by adding the name you want after the name of your repo, then adding a \u201c/\u201d and your filename). Try adding a file that you have created on your computer and uploads (Add file -> Upload files) Test out making edits to your files and committing them - all through the GitHub site. If you put a file \u201cREADME.md\u201d in a subdirectory then it will be shown as a \u201cdescription\u201d for the directory When you have made some commits, try click \u201ccommits\u201d above the files in the repo and see a list of your commits. Second exercise, SSH keys (if you have not set up already) \u00b6 In this exercise you create SSH keys and upload to GitHub. Then test that it works. Create a new SSH key Open a terminal (Git Bash on Windows). In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name: $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_rsa Switch to the .ssh folder, open the file id_rsa.pub and copy it. Do NOT add any newlines or whitespace! Adding the SSH key to GitHub On GitHub, click your avatar in the top right corner and pick \u201cSettings\u201d. Choose \u201cSSH and GPG keys\u201d Click \u201cAdd new SSH key\u201d Add a descriptive label for the key in the \u201cTitle\u201d field. In the key field you paste the content of the key (~/.ssh/id_rsa.pub) Click \u201cAdd SSH key\u201d Confirm your GitHub password if you are prompted for it. Testing the SSH keys Open a terminal $ ssh -T git@github.com It will look similar to this: $ ssh -T git@github.com The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa': Hi bbrydsoe! You've successfully authenticated, but GitHub does not provide shell access. Verify that the resulting message contains your username. Third exercise, clone, push, pull \u00b6 We now have SSH keys set up. Time to test it from your own machine: Clone the repository, using the SSH address (click CODE on the GitHub repository and pick SSH). You will be asked for the key passphrase. Enter the local repository. Do a git pull and see that it works. You will have to enter the key passphrase. Create a file (or edit a file). Add the file. Commit the file ( git add , git commit ) Push the file. Again it will ask for the key passphrase. Success! NOTE: Optionally, you could run ssh-add to add the key. Then you will only be asked for the passphrase once per session. This is relatively safe on Linux and macOS, but not on Windows where it usually saves the key passphrase permanently. Fourth exercise, teamwork, clone, push, pull \u00b6 One of you should create a repository on GitHub and invite their team. Remember, on the GitHub webpage the option to create a new repository is in the top right corner - click the \u201c+\u201d. To add members: \u201cSettings\u201d -> \u201cManage access\u201d. Each person should create a file in the repository (Add and commit the file) On the command line, do a git status . Do a git log --graph --oneline --decorate --all NOTE! To avoid errors, do git pull before you stage and commit your file and also the team members should use different names for their files. See the changes appear when you do a git pull after all have added their file(s). You could also try to push a new change before pulling the changes your team members have made. Git will complain, but you should be able to solve this kind of simple problem with git pull --rebase before you re-do git push Try create more files then add and commit. Do git status and git log --graph --oneline --decorate --all before and after each step. Push the files to the repository. Check the log and status again. NOTE: You will be asked for the key passphrase each time you do a push Fifth exercise, teamwork, branches and merging \u00b6 Each person creates a branch in the repo you created in the previous exercise. You can use git branch yourbranchname where you put any name you want for the new branch. Switch to the new branch with git checkout yourbranchname Create a uniquely named file. Put anything you want in it. Do git log and git status to see any changes. Stage and commit the file. Check again with git log and git status Push your changes with git push origin -u yourbranchname (or with git push -u origin HEAD for a fast way when using the same name) When everyone has done this, all do a git pull Use git status , git branch , and git log to see what has happened. Sixth exercise, teamwork, branches and merging, pull requests \u00b6 Go to the repository on the GitHub page. Submit a pull-request from your branch to the main branch The owner of the repository (the person who created it) can then accept them and click to merge them. After doing so, everyone should again do a git pull (on the command line) Use git status , git branch --all , and git log --graph --oneline --decorate --all to see what has happened. Note : It is possible to make the main branch \u201cprotected\u201d so it is not changed without a review from the owner. Try doing this (on GitHub). Seventh exercise, teamwork and branches \u00b6 Everyone in the group create a new branch in the repo - this time you could try doing it from the GitHub page Check which remote branches exist with git branch -r Check which local branches you have with git branch Use git status to see which branch you are on. Check with git branch -a to see all local and remote branches Do a git pull from the command line to get a list of all branches. Switch to the branch you created on GitHub with git checkout --track origin/mynewbranch . Again do git branch to see which branch you are on. Create a new file and put some content to it. Add and commit it. Check for changes ( git status , git log ). Push the changes. Try and merge the branches from the command line. Remember to first pull any changes from your other group members. Also remember to switch to the branch you want to merge it to (main in this case). Were you succesful? Why or why not? Is there are difference between what happens when the owner of the branch tries this and when everyone else does? After doing this, everyone should again do a git pull (on the command line) Use git status , git branch , and git log to see what has happened. If you want a \u201cprettier\u201d and sometimes easier to read view, use git log --graph --oneline --decorate --all Eighth exercise, deleting branches \u00b6 Everyone should now create two more branches in the repo. In each case, switch to the branch, create a file in it, and push the branch Check which branches exist, remotely and locally Try and delete a remote branch with `git push origin \u2013delete myownbranch Try delete a local branch with git branch -D <alsomyownbranch > Do a git status , git log and git branch to see what has happened The branch you deleted locally is still on the repo. Get another copy of it ( git pull and git fetch , possibly with suitable flags will get it back for you) Ninth exercise, merge conflicts \u00b6 In this exercise everyone in the team will be working in the same branch, for instance the main branch. Merge conflicts generally happen when two (or more) teammembers edit the same file and the same line, or when one edits a file and another deletes it. Create a new repository on GitHub. Add your team members as in the previous exercises. Everyone clones the repository (from the command line). Create a couple files. Add, commit, and push. If more than one creates files, remember to either pull your teammates work first, or do a git pull --rebase before pushing. After doing this, everyone should again do a git pull Now one or more make changes to the same file, in the same line. Add, commit, push. Did you get a conflict? Use git status , git branch , and git log to see what has happened. Try to resolve the conflict. Now again all will work on one file. One or more edit it and one deletes it ( git rm file ). What happens when you push your work? You should get a conflict. Try and resolve the conflict. Should the file be kept or deleted?","title":"Teamwork"},{"location":"teamwork/#lecture__7__teamwork","text":"","title":"Lecture 7: Teamwork"},{"location":"teamwork/#teamwork","text":"Git is very useful for teamwork. You will often have three types of branches for a project/specific release: main (or master) branch exist for the entire project development/staging branch developing, preparing new releases exists for the entire release of the project, then merged to main (master) feature branch(es) created just for the feature development later merged to development/staging branch NOTE: GitHub previously used \u201cmaster\u201d, but is now using \u201cmain\u201d as the name for the first/default branch in a repo. This can be changed under the repo\u2019s settings. In this session you will be working in small groups of 2-4 people. Each group will go to a Zoom break-out room and work together there. You will be using GitHub for the remote repository. Since GitHub no longer allows you to use username and password unless you are working directly on the site, you will set up and use SSH keys. First you will look around GitHub a little and try creating a repository there, as well as creating and editing a file on the site. The rest of the exercises will be about working together on a small project, and will be done from the command line with GitHub as the remote repository. There will be nine exercises in total in this part.","title":"Teamwork"},{"location":"teamwork/#concepts__and__commands","text":"In these exercises we will use only a few commands. These have all been mentioned before in this course, but as a refresher I will briefly discuss a couple commands here, namely: git fetch : This is a primary command used to download contents from a remote repository. example: your teammate has created a new feature branch which they have pushed to the remote repository, but which you do not yet have in your local repository git push : This is essentially the same as running git merge main from inside the remote repository. It is mostly used to upload local changes to a remote repository. git pull : This will fetch the latest changes from the current branch from a remote, then apply the changes to your local copy of the branch. It is similar to doing a fetch and a merge.","title":"Concepts and commands"},{"location":"teamwork/#git__push","text":"$ git push <remote-repo> <branch> or in some cases just $ git push where the default behaviour is pushing to repository \u201corigin\u201d and the same branch as the local. Before pushing: graph LR A((\"Anode\")) style A fill:#ffffff,stroke:#000000,color:#ffffff origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:#000000 B((\"Bnode\")) style B fill:#ffffff,stroke:#000000,color:#ffffff C((\"Cnode\")) style C fill:#ffffff,stroke:#000000,color:#ffffff main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 D((\"Dnode\")) style D fill:#305cde,stroke:#000000,color:#305cde A --- B origin -.-> B B --- C C --- D main -.-> D After pushing: graph LR A((\"Anode\")) style A fill:#ffffff,stroke:#000000,color:#ffffff origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:#000000 B((\"Bnode\")) style B fill:#ffffff,stroke:#000000,color:#ffffff C((\"Cnode\")) style C fill:#ffffff,stroke:#000000,color:#ffffff main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 D((\"Dnode\")) style D fill:#305cde,stroke:#000000,color:#305cde A --- B origin -.-> D B --- C C --- D main -.-> D Pushing a staged and committed file: bbrydsoe@enterprise-a:~/mytestrepo$ git push origin main Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa' : Enumerating objects: 5 , done . Counting objects: 100 % ( 5 /5 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 2 /2 ) , done . Writing objects: 100 % ( 3 /3 ) , 287 bytes | 287 .00 KiB/s, done . Total 3 ( delta 1 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To github.com:bbrydsoe/mytestrepo.git 43110f8..5fd2960 main -> main bbrydsoe@enterprise-a:~/mytestrepo$ git log commit 5fd2960d91a86f8c581d7470b42b1f3814e24d73 ( HEAD -> main, origin/main, origin/HEAD ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Sun Nov 13 15 :43:05 2022 +0100 Adding a file","title":"Git push"},{"location":"teamwork/#git__pull","text":"Fetch the given remote\u2019s copy of the current branch and merge to the local copy: $ git pull <remote-repo> or often just $ git pull","title":"Git pull"},{"location":"teamwork/#hint","text":"If you have forgotten to pull before staging and committing new stuff, and your colleague has added something to the remote repository in between, this is a handy command: $ git pull --rebase <remote> It fetches the remote content but does not create a new merge commit. Assume this situation: graph LR d((\"d\")) style d fill:#ffffff,stroke:#000000,color:#000000 e((\"e\")) style e fill:#ffffff,stroke:#000000,color:#000000 origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:#000000 d --- e origin -.-> e a((\"a\")) style a fill:#ffffff,stroke:#000000,color:#000000 f((\"f\")) style f fill:#ffffff,stroke:#000000,color:#000000 e --- a e --- f b((\"b\")) style b fill:#ffffff,stroke:#000000,color:#000000 g((\"g\")) style g fill:#ffffff,stroke:#000000,color:#000000 main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 c((\"c\")) style c fill:#ffffff,stroke:#000000,color:#000000 a --- b f --- g b --- c main -.-> c Now we do a git pull : graph LR d((\"d\")) style d fill:#ffffff,stroke:#000000,color:#000000 e((\"e\")) style e fill:#ffffff,stroke:#000000,color:#000000 origin[\"origin/main\"] style origin fill:#add8e6,stroke:#000000,color:000000 d --- e a((\"a\")) style a fill:#ffffff,stroke:#000000,color:#000000 f((\"f\")) style f fill:#ffffff,stroke:#000000,color:#000000 e --- a e --- f b((\"b\")) style b fill:#ffffff,stroke:#000000,color:#000000 g((\"g\")) style g fill:#ffffff,stroke:#000000,color:#000000 main[\"main\"] style main fill:#add8e6,stroke:#000000,color:#000000 c((\"c\")) style c fill:#ffffff,stroke:#000000,color:#000000 h((\"h\")) style h fill:#ffffff,stroke:#000000,color:#000000 a --- b f --- g b --- c origin -.-> c main -.-> c c --- h g --- h","title":"Hint"},{"location":"teamwork/#pull__from__remote__repo__new__file","text":"Let us do an example where there is a new file on the remote repository: $ git pull remote: Enumerating objects: 4 , done . remote: Counting objects: 100 % ( 4 /4 ) , done . remote: Compressing objects: 100 % ( 2 /2 ) , done . Unpacking objects: 100 % ( 3 /3 ) , done . remote: Total 3 ( delta 0 ) , reused 0 ( delta 0 ) , pack-reused 0 From github.com:bbrydsoe/testrepo 55f35b9..e6ca68c main -> origin/main Updating 55f35b9..e6ca68c Fast-forward newfile.txt | 1 + 1 file changed, 1 insertion ( + ) create mode 100644 newfile.txt","title":"Pull from remote repo, new file"},{"location":"teamwork/#example__creating__a__new__branch__pushing__changes","text":"Here we create a new branch on a remote repository and add a file to it, then push: Create the branch bbrydsoe@enterprise-a:~/mytestrepo$ git branch mynewbranch bbrydsoe@enterprise-a:~/mytestrepo$ Switch to it bbrydsoe@enterprise-a:~/mytestrepo$ git checkout mynewbranch Switched to branch 'mynewbranch' bbrydsoe@enterprise-a:~/mytestrepo$ I then create a file on my new branch. After this, check the status and log bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch mynewbranch Changes not staged for commit: ( use \"git add <file>...\" to update what will be committed ) ( use \"git restore <file>...\" to discard changes in working directory ) modified: myfile.txt no changes added to commit ( use \"git add\" and/or \"git commit -a\" ) bbrydsoe@enterprise-a:~/mytestrepo$ git log --graph --oneline --decorate --all * accef46 ( HEAD -> mynewbranch, main ) Updating the file funny.txt * 43110f8 ( origin/main, origin/HEAD ) Update funny.txt * af9e1cb Create Weird.txt * db2e945 Create funny.txt * c74b74c Adding the file file4.txt * 805d9b3 Create newfile.txt * c8e5214 Adding some files to play with for the exercise. * 1c8156d ( origin/mytestbranch, mytestbranch ) Adding testfile.txt to mytestbranch * 333d5e5 Merge pull request #2 from bbrydsoe/birgittesbranch | \\ | * 92901fa ( origin/birgittesbranch, birgittesbranch ) Adding my new file to my new branch. * | e7741d8 Merge pull request #1 from bbrydsoe/spocksbranch | \\ \\ | | / | / | | * 6814eb4 ( origin/spocksbranch ) Added a file by user spock | / * d4a666e Adding my new file to the repository. * 303bf63 Create README.md bbrydsoe@enterprise-a:~/mytestrepo$ Note: when you do this it should be coloured for easier readability I stage and commit the file. bbrydsoe@enterprise-a:~/mytestrepo$ git add myfile.txt bbrydsoe@enterprise-a:~/mytestrepo$ git commit -m \" Adding a file to my new branch\" [ mynewbranch c997da0 ] Adding a file to my new branch 1 file changed, 1 insertion ( + ) I will check to confirm I am on the right branch: bbrydsoe@enterprise-a:~/mytestrepo$ git branch birgittesbranch main * mynewbranch mytestbranch bbrydsoe@enterprise-a:~/mytestrepo$ Let us again check with git status and git log ... bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch mynewbranch nothing to commit, working tree clean bbrydsoe@enterprise-a:~/mytestrepo$ bbrydsoe@enterprise-a:~/mytestrepo$ git log --graph --oneline --decorate --all * c997da0 ( HEAD -> mynewbranch ) Adding a file to my new branch * accef46 ( main ) Updating the file funny.txt * 43110f8 ( origin/main, origin/HEAD ) Update funny.txt * af9e1cb Create Weird.txt * db2e945 Create funny.txt * c74b74c Adding the file file4.txt * 805d9b3 Create newfile.txt * c8e5214 Adding some files to play with for the exercise. * 1c8156d ( origin/mytestbranch, mytestbranch ) Adding testfile.txt to mytestbranch * 333d5e5 Merge pull request #2 from bbrydsoe/birgittesbranch | \\ | * 92901fa ( origin/birgittesbranch, birgittesbranch ) Adding my new file to my new branch. * | e7741d8 Merge pull request #1 from bbrydsoe/spocksbranch | \\ \\ | | / | / | | * 6814eb4 ( origin/spocksbranch ) Added a file by user spock | / * d4a666e Adding my new file to the repository. * 303bf63 Create README.md bbrydsoe@enterprise-a:~/mytestrepo$ Push your changes with git push origin -u yourbranchname (or with git push -u origin HEAD ) bbrydsoe@enterprise-a:~/mytestrepo$ git push -u origin HEAD Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa' : Enumerating objects: 9 , done . Counting objects: 100 % ( 9 /9 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 5 /5 ) , done . Writing objects: 100 % ( 6 /6 ) , 619 bytes | 619 .00 KiB/s, done . Total 6 ( delta 2 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 2 /2 ) , completed with 1 local object. remote: remote: Create a pull request for 'mynewbranch' on GitHub by visiting: remote: https://github.com/bbrydsoe/mytestrepo/pull/new/mynewbranch remote: To github.com:bbrydsoe/mytestrepo.git * [ new branch ] HEAD -> mynewbranch Branch 'mynewbranch' set up to track remote branch 'mynewbranch' from 'origin' . bbrydsoe@enterprise-a:~/mytestrepo$ Let us check the status bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch mynewbranch Your branch is up-to-date with 'origin/mynewbranch' . nothing to commit, working tree clean bbrydsoe@enterprise-a:~/mytestrepo$","title":"Example: creating a new branch, pushing changes"},{"location":"teamwork/#example__merging__branches","text":"We will merge the branches from the command line. Let us first see which branches exist in my repo - in this case I will check for both local and remote branches bbrydsoe@enterprise-a:~/mytestrepo$ git branch --all birgittesbranch main * mynewbranch mytestbranch remotes/origin/HEAD -> origin/main remotes/origin/birgittesbranch remotes/origin/main remotes/origin/mynewbranch remotes/origin/mytestbranch remotes/origin/spocksbranch I have a bunch of branches (created previously by me and another user, for testing). As you can see, I am on my newest branch \u201cmynewbranch\u201d Switch to the branch we are merging to (main) bbrydsoe@enterprise-a:~/mytestrepo$ git checkout main Switched to branch 'main' Your branch is up-to-date with 'origin/main' . bbrydsoe@enterprise-a:~/mytestrepo$ Do the merge (it will also open an editor where you should write a commit message for why the merge should happen) git merge mynewbranch Merge made by the 'recursive' strategy. myfile.txt | 1 + 1 file changed, 1 insertion ( + ) Let us do a status check bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch main Your branch is ahead of 'origin/main' by 2 commits. ( use \"git push\" to publish your local commits ) nothing to commit, working tree clean Pushing bbrydsoe@enterprise-a:~/mytestrepo$ git push Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa' : Enumerating objects: 4 , done . Counting objects: 100 % ( 4 /4 ) , done . Delta compression using up to 4 threads Compressing objects: 100 % ( 2 /2 ) , done . Writing objects: 100 % ( 2 /2 ) , 303 bytes | 303 .00 KiB/s, done . Total 2 ( delta 1 ) , reused 0 ( delta 0 ) remote: Resolving deltas: 100 % ( 1 /1 ) , completed with 1 local object. To github.com:bbrydsoe/mytestrepo.git 5fd2960..2032676 main -> main Checking status again bbrydsoe@enterprise-a:~/mytestrepo$ git status On branch main Your branch is up-to-date with 'origin/main' . nothing to commit, working tree clean","title":"Example: Merging branches"},{"location":"teamwork/#first__exercise__-__github__if__not__setup__already","text":"Create a repository (click on the + at the top right of the menu or picking \u201cStart a new repository\u201d on your \u201chome screen\u201d) Under \u201cQuick setup\u201d, pick \u201ccreating a new file\u201d. Name the file \u201cREADME.md\u201d (at the top, over the file editor). Put some text in the file \u201cREADME.md\u201d. At the bottom, where it says \u201cCommit new file\u201d you should put a useful commit message. Then click \u201cCommit new file\u201d Notice: the content of README.md appears at top level of the repo Try creating another file in a subdirectory (create subdirectories by adding the name you want after the name of your repo, then adding a \u201c/\u201d and your filename). Try adding a file that you have created on your computer and uploads (Add file -> Upload files) Test out making edits to your files and committing them - all through the GitHub site. If you put a file \u201cREADME.md\u201d in a subdirectory then it will be shown as a \u201cdescription\u201d for the directory When you have made some commits, try click \u201ccommits\u201d above the files in the repo and see a list of your commits.","title":"First exercise - GitHub (if not setup already)"},{"location":"teamwork/#second__exercise__ssh__keys__if__you__have__not__set__up__already","text":"In this exercise you create SSH keys and upload to GitHub. Then test that it works. Create a new SSH key Open a terminal (Git Bash on Windows). In the command below, \u201cGitHub\u201d is a label added to the key for clarity. You can add any you want: a. Do this $ ssh-keygen -t ed25519 -C \"GitHub\" b. If you have an older system, this may work better $ ssh-keygen -t rsa -b 4096 -C \"GitHub\" You will be asked for a file to save the key. Unless you have an existing SSH key, accept the default. Enter a passphrase and repeat it. Add the key to the ssh-agent. Here we assume the default name: $ eval \"$(ssh-agent -s)\" $ ssh-add ~/.ssh/id_rsa Switch to the .ssh folder, open the file id_rsa.pub and copy it. Do NOT add any newlines or whitespace! Adding the SSH key to GitHub On GitHub, click your avatar in the top right corner and pick \u201cSettings\u201d. Choose \u201cSSH and GPG keys\u201d Click \u201cAdd new SSH key\u201d Add a descriptive label for the key in the \u201cTitle\u201d field. In the key field you paste the content of the key (~/.ssh/id_rsa.pub) Click \u201cAdd SSH key\u201d Confirm your GitHub password if you are prompted for it. Testing the SSH keys Open a terminal $ ssh -T git@github.com It will look similar to this: $ ssh -T git@github.com The authenticity of host 'github.com (140.82.121.4)' can't be established. RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added 'github.com,140.82.121.4' (RSA) to the list of known hosts. Enter passphrase for key '/home/bbrydsoe/.ssh/id_rsa': Hi bbrydsoe! You've successfully authenticated, but GitHub does not provide shell access. Verify that the resulting message contains your username.","title":"Second exercise, SSH keys (if you have not set up already)"},{"location":"teamwork/#third__exercise__clone__push__pull","text":"We now have SSH keys set up. Time to test it from your own machine: Clone the repository, using the SSH address (click CODE on the GitHub repository and pick SSH). You will be asked for the key passphrase. Enter the local repository. Do a git pull and see that it works. You will have to enter the key passphrase. Create a file (or edit a file). Add the file. Commit the file ( git add , git commit ) Push the file. Again it will ask for the key passphrase. Success! NOTE: Optionally, you could run ssh-add to add the key. Then you will only be asked for the passphrase once per session. This is relatively safe on Linux and macOS, but not on Windows where it usually saves the key passphrase permanently.","title":"Third exercise, clone, push, pull"},{"location":"teamwork/#fourth__exercise__teamwork__clone__push__pull","text":"One of you should create a repository on GitHub and invite their team. Remember, on the GitHub webpage the option to create a new repository is in the top right corner - click the \u201c+\u201d. To add members: \u201cSettings\u201d -> \u201cManage access\u201d. Each person should create a file in the repository (Add and commit the file) On the command line, do a git status . Do a git log --graph --oneline --decorate --all NOTE! To avoid errors, do git pull before you stage and commit your file and also the team members should use different names for their files. See the changes appear when you do a git pull after all have added their file(s). You could also try to push a new change before pulling the changes your team members have made. Git will complain, but you should be able to solve this kind of simple problem with git pull --rebase before you re-do git push Try create more files then add and commit. Do git status and git log --graph --oneline --decorate --all before and after each step. Push the files to the repository. Check the log and status again. NOTE: You will be asked for the key passphrase each time you do a push","title":"Fourth exercise, teamwork, clone, push, pull"},{"location":"teamwork/#fifth__exercise__teamwork__branches__and__merging","text":"Each person creates a branch in the repo you created in the previous exercise. You can use git branch yourbranchname where you put any name you want for the new branch. Switch to the new branch with git checkout yourbranchname Create a uniquely named file. Put anything you want in it. Do git log and git status to see any changes. Stage and commit the file. Check again with git log and git status Push your changes with git push origin -u yourbranchname (or with git push -u origin HEAD for a fast way when using the same name) When everyone has done this, all do a git pull Use git status , git branch , and git log to see what has happened.","title":"Fifth exercise, teamwork, branches and merging"},{"location":"teamwork/#sixth__exercise__teamwork__branches__and__merging__pull__requests","text":"Go to the repository on the GitHub page. Submit a pull-request from your branch to the main branch The owner of the repository (the person who created it) can then accept them and click to merge them. After doing so, everyone should again do a git pull (on the command line) Use git status , git branch --all , and git log --graph --oneline --decorate --all to see what has happened. Note : It is possible to make the main branch \u201cprotected\u201d so it is not changed without a review from the owner. Try doing this (on GitHub).","title":"Sixth exercise, teamwork, branches and merging, pull requests"},{"location":"teamwork/#seventh__exercise__teamwork__and__branches","text":"Everyone in the group create a new branch in the repo - this time you could try doing it from the GitHub page Check which remote branches exist with git branch -r Check which local branches you have with git branch Use git status to see which branch you are on. Check with git branch -a to see all local and remote branches Do a git pull from the command line to get a list of all branches. Switch to the branch you created on GitHub with git checkout --track origin/mynewbranch . Again do git branch to see which branch you are on. Create a new file and put some content to it. Add and commit it. Check for changes ( git status , git log ). Push the changes. Try and merge the branches from the command line. Remember to first pull any changes from your other group members. Also remember to switch to the branch you want to merge it to (main in this case). Were you succesful? Why or why not? Is there are difference between what happens when the owner of the branch tries this and when everyone else does? After doing this, everyone should again do a git pull (on the command line) Use git status , git branch , and git log to see what has happened. If you want a \u201cprettier\u201d and sometimes easier to read view, use git log --graph --oneline --decorate --all","title":"Seventh exercise, teamwork and branches"},{"location":"teamwork/#eighth__exercise__deleting__branches","text":"Everyone should now create two more branches in the repo. In each case, switch to the branch, create a file in it, and push the branch Check which branches exist, remotely and locally Try and delete a remote branch with `git push origin \u2013delete myownbranch Try delete a local branch with git branch -D <alsomyownbranch > Do a git status , git log and git branch to see what has happened The branch you deleted locally is still on the repo. Get another copy of it ( git pull and git fetch , possibly with suitable flags will get it back for you)","title":"Eighth exercise, deleting branches"},{"location":"teamwork/#ninth__exercise__merge__conflicts","text":"In this exercise everyone in the team will be working in the same branch, for instance the main branch. Merge conflicts generally happen when two (or more) teammembers edit the same file and the same line, or when one edits a file and another deletes it. Create a new repository on GitHub. Add your team members as in the previous exercises. Everyone clones the repository (from the command line). Create a couple files. Add, commit, and push. If more than one creates files, remember to either pull your teammates work first, or do a git pull --rebase before pushing. After doing this, everyone should again do a git pull Now one or more make changes to the same file, in the same line. Add, commit, push. Did you get a conflict? Use git status , git branch , and git log to see what has happened. Try to resolve the conflict. Now again all will work on one file. One or more edit it and one deletes it ( git rm file ). What happens when you push your work? You should get a conflict. Try and resolve the conflict. Should the file be kept or deleted?","title":"Ninth exercise, merge conflicts"},{"location":"tetralith/","text":"Connecting to Tetralith \u00b6 ThinLinc \u00b6 For this course we recommend using ThinLinc, but if you have your own installation of another SSH client that you prefer, you are welcome to use that. We will be using the command line only, so an SSH client like PuTTY would also work. Download the ThinLinc client from https://www.cendio.com/thinlinc/download and install it. Logging in \u00b6 Start the client. Enter the name of the server: tetralith.nsc.liu.se and then enter your own username. Go to \u201cOptions\u201d -> \u201cSecurity\u201d. Check that authentication method is set to password. Go to \u201cOptions\u201d -> \u201cScreen\u201d and uncheck \u201cFull screen mode\u201d. Enter your NSC password. Click \u201cConnect\u201d. If you prefer a different SSH client (terminal, etc.), you connect with ssh -Y <user>@tetralith.nsc.liu.se NOTE 2FA is needed. Information about connecting: https://www.nsc.liu.se/support/getting-started/ More specific about 2FA: https://www.nsc.liu.se/support/2fa/ Setting up Git \u00b6 Git is already installed on Tetralith, but you need to set your name and email globals unless you have already done this at some earlier time . Open a terminal. In ThinLinc: Go to the menu at the top. Click \u201cApplications\u201d \u2192 \u201cSystem Tools\u201d \u2192 \u201cMATE Terminal\u201d. Set your global name (change \u201cYour Name\u201d): $ git config --global user.name \"Your Name\" Set your global email (change the example): $ git config --global user.email \"name@example.com\" You may also want to set your editor. We recommend nano, but other options are vim and emacs (or notepad on Windows). $ git config --global core.editor nano Testing your configuration \u00b6 Create an example folder and cd into that, then create a file test.txt: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and add the new file: $ git init $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message: $ git commit test.txt Now let us look at the log: $ git log When you do git log , you should see something like: commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git but with name, email and commit message different. If that is the case, your Git should be configured correctly. Download the course materials \u00b6 For the individual hands-on part of the course, we have created some course materials which you will download from either the course website, the course GitHub, or the \u201cimportant information\u201d page. Course website: https://www.hpc2n.umu.se/events/courses/2024/fall/git Course GitHub: https://github.com/hpc2n/course-intro-git Click the green button labeled \u201cCode\u201d for links to clone or download the materials. Either do 1. CLONE or 2. DOWNLOAD , not both! CLONE: Change to the directory where you wish to have the course material and clone with \u2018git clone\u2019 and the url: git clone https://github.com/hpc2n/course-intro-git.git You get the directory: course-intro-git DOWNLOAD Zipfile: Please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Download the Zipfile and move it there. Can be done directly from the terminal with wget https://github.com/hpc2n/course-intro-git/archive/refs/heads/main.zip ) Unpack with unzip main.zip . You will get a directory called course-intro-git-main . GitHub and SSH keys \u00b6 You need to create an account on GitHub for the course You also need to create SSH keys on Tetralith and install these on GitHub We will go through this in a general way which should work regardless of system you are using We will go through it before the Teamwork session. The material for creating and setting up SSH keys are here: https://hackmd.io/@git-fall-2024/LC-github","title":"Using Tetralith for the Git course"},{"location":"tetralith/#connecting__to__tetralith","text":"","title":"Connecting to Tetralith"},{"location":"tetralith/#thinlinc","text":"For this course we recommend using ThinLinc, but if you have your own installation of another SSH client that you prefer, you are welcome to use that. We will be using the command line only, so an SSH client like PuTTY would also work. Download the ThinLinc client from https://www.cendio.com/thinlinc/download and install it.","title":"ThinLinc"},{"location":"tetralith/#logging__in","text":"Start the client. Enter the name of the server: tetralith.nsc.liu.se and then enter your own username. Go to \u201cOptions\u201d -> \u201cSecurity\u201d. Check that authentication method is set to password. Go to \u201cOptions\u201d -> \u201cScreen\u201d and uncheck \u201cFull screen mode\u201d. Enter your NSC password. Click \u201cConnect\u201d. If you prefer a different SSH client (terminal, etc.), you connect with ssh -Y <user>@tetralith.nsc.liu.se NOTE 2FA is needed. Information about connecting: https://www.nsc.liu.se/support/getting-started/ More specific about 2FA: https://www.nsc.liu.se/support/2fa/","title":"Logging in"},{"location":"tetralith/#setting__up__git","text":"Git is already installed on Tetralith, but you need to set your name and email globals unless you have already done this at some earlier time . Open a terminal. In ThinLinc: Go to the menu at the top. Click \u201cApplications\u201d \u2192 \u201cSystem Tools\u201d \u2192 \u201cMATE Terminal\u201d. Set your global name (change \u201cYour Name\u201d): $ git config --global user.name \"Your Name\" Set your global email (change the example): $ git config --global user.email \"name@example.com\" You may also want to set your editor. We recommend nano, but other options are vim and emacs (or notepad on Windows). $ git config --global core.editor nano","title":"Setting up Git"},{"location":"tetralith/#testing__your__configuration","text":"Create an example folder and cd into that, then create a file test.txt: $ mkdir <mydir> $ cd <mydir> $ touch test.txt Now initialize a repository and add the new file: $ git init $ git add test.txt Now commit the change. The editor which you configured earlier should open. Add an example commit message: $ git commit test.txt Now let us look at the log: $ git log When you do git log , you should see something like: commit ff8b6f699d98c72d5cffc64d65a1c618b976b45a ( HEAD -> master ) Author: Birgitte Bryds\u00f6 <bbrydsoe@cs.umu.se> Date: Thu Sep 17 13 :53:59 2020 +0200 Test of git but with name, email and commit message different. If that is the case, your Git should be configured correctly.","title":"Testing your configuration"},{"location":"tetralith/#download__the__course__materials","text":"For the individual hands-on part of the course, we have created some course materials which you will download from either the course website, the course GitHub, or the \u201cimportant information\u201d page. Course website: https://www.hpc2n.umu.se/events/courses/2024/fall/git Course GitHub: https://github.com/hpc2n/course-intro-git Click the green button labeled \u201cCode\u201d for links to clone or download the materials. Either do 1. CLONE or 2. DOWNLOAD , not both! CLONE: Change to the directory where you wish to have the course material and clone with \u2018git clone\u2019 and the url: git clone https://github.com/hpc2n/course-intro-git.git You get the directory: course-intro-git DOWNLOAD Zipfile: Please go to the terminal window where you have downloaded and set up Git. Change the directory to wherever you wish to have the course material. Download the Zipfile and move it there. Can be done directly from the terminal with wget https://github.com/hpc2n/course-intro-git/archive/refs/heads/main.zip ) Unpack with unzip main.zip . You will get a directory called course-intro-git-main .","title":"Download the course materials"},{"location":"tetralith/#github__and__ssh__keys","text":"You need to create an account on GitHub for the course You also need to create SSH keys on Tetralith and install these on GitHub We will go through this in a general way which should work regardless of system you are using We will go through it before the Teamwork session. The material for creating and setting up SSH keys are here: https://hackmd.io/@git-fall-2024/LC-github","title":"GitHub and SSH keys"}]}